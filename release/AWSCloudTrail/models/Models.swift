// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AddTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tagslist0 in tagsList {
                try tagsListContainer.encode(tagslist0)
            }
        }
    }
}

extension AddTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies the tags to add to a trail.
public struct AddTagsInput: Swift.Equatable {
    /// Specifies the ARN of the trail to which one or more tags will be added. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var resourceId: Swift.String?
    /// Contains a list of tags, up to a limit of 50
    public var tagsList: [CloudTrailClientTypes.Tag]?

    public init (
        resourceId: Swift.String? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagsList = tagsList
    }
}

struct AddTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagsList: [CloudTrailClientTypes.Tag]?
}

extension AddTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension AddTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameter" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceTypeNotSupported" : self = .resourceTypeNotSupportedException(try ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsLimitExceeded" : self = .tagsLimitExceededException(try TagsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case invalidTagParameterException(InvalidTagParameterException)
    case invalidTrailNameException(InvalidTrailNameException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceTypeNotSupportedException(ResourceTypeNotSupportedException)
    case tagsLimitExceededException(TagsLimitExceededException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Returns the objects or data if successful. Otherwise, returns an error.
public struct AddTagsOutputResponse: Swift.Equatable {

}

extension CloudTrailClientTypes.AdvancedEventSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldSelectors = "FieldSelectors"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldSelectors = fieldSelectors {
            var fieldSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldSelectors)
            for advancedfieldselectors0 in fieldSelectors {
                try fieldSelectorsContainer.encode(advancedfieldselectors0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fieldSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedFieldSelector?].self, forKey: .fieldSelectors)
        var fieldSelectorsDecoded0:[CloudTrailClientTypes.AdvancedFieldSelector]? = nil
        if let fieldSelectorsContainer = fieldSelectorsContainer {
            fieldSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedFieldSelector]()
            for structure0 in fieldSelectorsContainer {
                if let structure0 = structure0 {
                    fieldSelectorsDecoded0?.append(structure0)
                }
            }
        }
        fieldSelectors = fieldSelectorsDecoded0
    }
}

extension CloudTrailClientTypes {
    /// Advanced event selectors let you create fine-grained selectors for the following CloudTrail event record Ô¨Åelds. They help you control costs by logging only those events that are important to you. For more information about advanced event selectors, see [Logging data events for trails](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html) in the CloudTrail User Guide.
    ///
    /// * readOnly
    ///
    /// * eventSource
    ///
    /// * eventName
    ///
    /// * eventCategory
    ///
    /// * resources.type
    ///
    /// * resources.ARN
    ///
    ///
    /// You cannot apply both event selectors and advanced event selectors to a trail.
    public struct AdvancedEventSelector: Swift.Equatable {
        /// Contains all selector statements in an advanced event selector.
        /// This member is required.
        public var fieldSelectors: [CloudTrailClientTypes.AdvancedFieldSelector]?
        /// An optional, descriptive name for an advanced event selector, such as "Log data events for only two S3 buckets".
        public var name: Swift.String?

        public init (
            fieldSelectors: [CloudTrailClientTypes.AdvancedFieldSelector]? = nil,
            name: Swift.String? = nil
        )
        {
            self.fieldSelectors = fieldSelectors
            self.name = name
        }
    }

}

extension CloudTrailClientTypes.AdvancedFieldSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endsWith = "EndsWith"
        case equals = "Equals"
        case field = "Field"
        case notEndsWith = "NotEndsWith"
        case notEquals = "NotEquals"
        case notStartsWith = "NotStartsWith"
        case startsWith = "StartsWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endsWith = endsWith {
            var endsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endsWith)
            for operator0 in endsWith {
                try endsWithContainer.encode(operator0)
            }
        }
        if let equals = equals {
            var equalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .equals)
            for operator0 in equals {
                try equalsContainer.encode(operator0)
            }
        }
        if let field = field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let notEndsWith = notEndsWith {
            var notEndsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEndsWith)
            for operator0 in notEndsWith {
                try notEndsWithContainer.encode(operator0)
            }
        }
        if let notEquals = notEquals {
            var notEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEquals)
            for operator0 in notEquals {
                try notEqualsContainer.encode(operator0)
            }
        }
        if let notStartsWith = notStartsWith {
            var notStartsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notStartsWith)
            for operator0 in notStartsWith {
                try notStartsWithContainer.encode(operator0)
            }
        }
        if let startsWith = startsWith {
            var startsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startsWith)
            for operator0 in startsWith {
                try startsWithContainer.encode(operator0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let equalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .equals)
        var equalsDecoded0:[Swift.String]? = nil
        if let equalsContainer = equalsContainer {
            equalsDecoded0 = [Swift.String]()
            for string0 in equalsContainer {
                if let string0 = string0 {
                    equalsDecoded0?.append(string0)
                }
            }
        }
        equals = equalsDecoded0
        let startsWithContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startsWith)
        var startsWithDecoded0:[Swift.String]? = nil
        if let startsWithContainer = startsWithContainer {
            startsWithDecoded0 = [Swift.String]()
            for string0 in startsWithContainer {
                if let string0 = string0 {
                    startsWithDecoded0?.append(string0)
                }
            }
        }
        startsWith = startsWithDecoded0
        let endsWithContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endsWith)
        var endsWithDecoded0:[Swift.String]? = nil
        if let endsWithContainer = endsWithContainer {
            endsWithDecoded0 = [Swift.String]()
            for string0 in endsWithContainer {
                if let string0 = string0 {
                    endsWithDecoded0?.append(string0)
                }
            }
        }
        endsWith = endsWithDecoded0
        let notEqualsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notEquals)
        var notEqualsDecoded0:[Swift.String]? = nil
        if let notEqualsContainer = notEqualsContainer {
            notEqualsDecoded0 = [Swift.String]()
            for string0 in notEqualsContainer {
                if let string0 = string0 {
                    notEqualsDecoded0?.append(string0)
                }
            }
        }
        notEquals = notEqualsDecoded0
        let notStartsWithContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notStartsWith)
        var notStartsWithDecoded0:[Swift.String]? = nil
        if let notStartsWithContainer = notStartsWithContainer {
            notStartsWithDecoded0 = [Swift.String]()
            for string0 in notStartsWithContainer {
                if let string0 = string0 {
                    notStartsWithDecoded0?.append(string0)
                }
            }
        }
        notStartsWith = notStartsWithDecoded0
        let notEndsWithContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notEndsWith)
        var notEndsWithDecoded0:[Swift.String]? = nil
        if let notEndsWithContainer = notEndsWithContainer {
            notEndsWithDecoded0 = [Swift.String]()
            for string0 in notEndsWithContainer {
                if let string0 = string0 {
                    notEndsWithDecoded0?.append(string0)
                }
            }
        }
        notEndsWith = notEndsWithDecoded0
    }
}

extension CloudTrailClientTypes {
    /// A single selector statement in an advanced event selector.
    public struct AdvancedFieldSelector: Swift.Equatable {
        /// An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        public var endsWith: [Swift.String]?
        /// An operator that includes events that match the exact value of the event record field specified as the value of Field. This is the only valid operator that you can use with the readOnly, eventCategory, and resources.type fields.
        public var equals: [Swift.String]?
        /// A field in an event record on which to filter events to be logged. Supported fields include readOnly, eventCategory, eventSource (for management events), eventName, resources.type, and resources.ARN.
        ///
        /// * readOnly - Optional. Can be set to Equals a value of true or false. A value of false logs both read and write events.
        ///
        /// * eventSource - For filtering management events only. This can be set only to NotEqualskms.amazonaws.com.
        ///
        /// * eventName - Can use any operator. You can use it to Ô¨Ålter in or Ô¨Ålter out any data event logged to CloudTrail, such as PutBucket or GetSnapshotBlock. You can have multiple values for this Ô¨Åeld, separated by commas.
        ///
        /// * eventCategory - This is required. It must be set to Equals, and the value must be Management or Data.
        ///
        /// * resources.type - This Ô¨Åeld is required. resources.type can only use the Equals operator, and the value can be one of the following:
        ///
        /// * AWS::S3::Object
        ///
        /// * AWS::Lambda::Function
        ///
        /// * AWS::DynamoDB::Table
        ///
        /// * AWS::S3Outposts::Object
        ///
        /// * AWS::ManagedBlockchain::Node
        ///
        /// * AWS::S3ObjectLambda::AccessPoint
        ///
        /// * AWS::EC2::Snapshot
        ///
        /// * AWS::S3::AccessPoint
        ///
        /// * AWS::DynamoDB::Stream
        ///
        ///
        /// You can have only one resources.type Ô¨Åeld per selector. To log data events on more than one resource type, add another selector.
        ///
        /// * resources.ARN - You can use any operator with resources.ARN, but if you use Equals or NotEquals, the value must exactly match the ARN of a valid resource of the type you've speciÔ¨Åed in the template as the value of resources.type. For example, if resources.type equals AWS::S3::Object, the ARN must be in one of the following formats. To log all data events for all objects in a specific S3 bucket, use the StartsWith operator, and include only the bucket ARN as the matching value. The trailing slash is intentional; do not exclude it. Replace the text between less than and greater than symbols (<>) with resource-specific information.
        ///
        /// * arn::s3:::/
        ///
        /// * arn::s3::://
        ///
        ///
        /// When resources.type equals AWS::S3::AccessPoint, and the operator is set to Equals or NotEquals, the ARN must be in one of the following formats. To log events on all objects in an S3 access point, we recommend that you use only the access point ARN, don‚Äôt include the object path, and use the StartsWith or NotStartsWith operators.
        ///
        /// * arn::s3:::accesspoint/
        ///
        /// * arn::s3:::accesspoint//object/
        ///
        ///
        /// When resources.type equals AWS::Lambda::Function, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::lambda:::function:
        ///
        ///
        /// When resources.type equals AWS::DynamoDB::Table, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::dynamodb:::table/
        ///
        ///
        /// When resources.type equals AWS::S3Outposts::Object, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::s3-outposts:::
        ///
        ///
        /// When resources.type equals AWS::ManagedBlockchain::Node, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::managedblockchain:::nodes/
        ///
        ///
        /// When resources.type equals AWS::S3ObjectLambda::AccessPoint, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::s3-object-lambda:::accesspoint/
        ///
        ///
        /// When resources.type equals AWS::EC2::Snapshot, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::ec2:::snapshot/
        ///
        ///
        /// When resources.type equals AWS::DynamoDB::Stream, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::dynamodb:::table//stream/
        /// This member is required.
        public var field: Swift.String?
        /// An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        public var notEndsWith: [Swift.String]?
        /// An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        public var notEquals: [Swift.String]?
        /// An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        public var notStartsWith: [Swift.String]?
        /// An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        public var startsWith: [Swift.String]?

        public init (
            endsWith: [Swift.String]? = nil,
            equals: [Swift.String]? = nil,
            field: Swift.String? = nil,
            notEndsWith: [Swift.String]? = nil,
            notEquals: [Swift.String]? = nil,
            notStartsWith: [Swift.String]? = nil,
            startsWith: [Swift.String]? = nil
        )
        {
            self.endsWith = endsWith
            self.equals = equals
            self.field = field
            self.notEndsWith = notEndsWith
            self.notEquals = notEquals
            self.notStartsWith = notStartsWith
            self.startsWith = startsWith
        }
    }

}

extension CloudTrailARNInvalidException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloudTrailARNInvalidExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when an operation is called with a trail ARN that is not valid. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
public struct CloudTrailARNInvalidException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudTrailARNInvalidExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudTrailARNInvalidExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailAccessNotEnabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloudTrailAccessNotEnabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when trusted access has not been enabled between CloudTrail and Organizations. For more information, see [Enabling Trusted Access with Other Amazon Web Services Services](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_integrate_services.html) and [Prepare For Creating a Trail For Your Organization](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html).
public struct CloudTrailAccessNotEnabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudTrailAccessNotEnabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudTrailAccessNotEnabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailInvalidClientTokenIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloudTrailInvalidClientTokenIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when a call results in the InvalidClientTokenId error code. This can occur when you are creating or updating a trail to send notifications to an Amazon SNS topic that is in a suspended Amazon Web Services account.
public struct CloudTrailInvalidClientTokenIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudTrailInvalidClientTokenIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudTrailInvalidClientTokenIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudWatchLogsDeliveryUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloudWatchLogsDeliveryUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot set a CloudWatch Logs delivery for this region.
public struct CloudWatchLogsDeliveryUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudWatchLogsDeliveryUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudWatchLogsDeliveryUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified resource is not ready for an operation. This can occur when you try to run an operation on a trail before CloudTrail has time to fully load the trail. If this exception occurs, wait a few minutes, and then try the operation again.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateTrailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let enableLogFileValidation = enableLogFileValidation {
            try encodeContainer.encode(enableLogFileValidation, forKey: .enableLogFileValidation)
        }
        if let includeGlobalServiceEvents = includeGlobalServiceEvents {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if let isMultiRegionTrail = isMultiRegionTrail {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if let isOrganizationTrail = isOrganizationTrail {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicName = snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tagslist0 in tagsList {
                try tagsListContainer.encode(tagslist0)
            }
        }
    }
}

extension CreateTrailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies the settings for each trail.
public struct CreateTrailInput: Swift.Equatable {
    /// Specifies a log group name using an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered. Not required unless you specify CloudWatchLogsRoleArn.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether log file integrity validation is enabled. The default is false. When you disable log file integrity validation, the chain of digest files is broken after one hour. CloudTrail does not create digest files for log files that were delivered during a period in which log file integrity validation was disabled. For example, if you enable log file integrity validation at noon on January 1, disable it at noon on January 2, and re-enable it at noon on January 10, digest files will not be created for the log files delivered from noon on January 2 to noon on January 10. The same applies whenever you stop CloudTrail logging or delete a trail.
    public var enableLogFileValidation: Swift.Bool?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail is created in the current region or in all regions. The default is false, which creates a trail only in the region where you are signed in. As a best practice, consider creating trails that log events in all regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is created for all accounts in an organization in Organizations, or only for the current Amazon Web Services account. The default is false, and cannot be true unless the call is made on behalf of an Amazon Web Services account that is the management account for an organization in Organizations.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. The value can be an alias name prefixed by "alias/", a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies the name of the trail. The name must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files. See [Amazon S3 Bucket Naming Requirements](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create_trail_naming_policy.html).
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html). The maximum length is 200 characters.
    public var s3KeyPrefix: Swift.String?
    /// Specifies the name of the Amazon SNS topic defined for notification of log file delivery. The maximum length is 256 characters.
    public var snsTopicName: Swift.String?
    /// A list of tags.
    public var tagsList: [CloudTrailClientTypes.Tag]?

    public init (
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        enableLogFileValidation: Swift.Bool? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicName: Swift.String? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.enableLogFileValidation = enableLogFileValidation
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicName = snsTopicName
        self.tagsList = tagsList
    }
}

struct CreateTrailInputBody: Swift.Equatable {
    let name: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let snsTopicName: Swift.String?
    let includeGlobalServiceEvents: Swift.Bool?
    let isMultiRegionTrail: Swift.Bool?
    let enableLogFileValidation: Swift.Bool?
    let cloudWatchLogsLogGroupArn: Swift.String?
    let cloudWatchLogsRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let isOrganizationTrail: Swift.Bool?
    let tagsList: [CloudTrailClientTypes.Tag]?
}

extension CreateTrailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
        case tagsList = "TagsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let enableLogFileValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableLogFileValidation)
        enableLogFileValidation = enableLogFileValidationDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension CreateTrailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTrailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailAccessNotEnabled" : self = .cloudTrailAccessNotEnabledException(try CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudTrailInvalidClientTokenId" : self = .cloudTrailInvalidClientTokenIdException(try CloudTrailInvalidClientTokenIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudWatchLogsDeliveryUnavailable" : self = .cloudWatchLogsDeliveryUnavailableException(try CloudWatchLogsDeliveryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientEncryptionPolicy" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientS3BucketPolicy" : self = .insufficientS3BucketPolicyException(try InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientSnsTopicPolicy" : self = .insufficientSnsTopicPolicyException(try InsufficientSnsTopicPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchLogsLogGroupArn" : self = .invalidCloudWatchLogsLogGroupArnException(try InvalidCloudWatchLogsLogGroupArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchLogsRoleArn" : self = .invalidCloudWatchLogsRoleArnException(try InvalidCloudWatchLogsRoleArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKmsKeyId" : self = .invalidKmsKeyIdException(try InvalidKmsKeyIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationError" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketName" : self = .invalidS3BucketNameException(try InvalidS3BucketNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3Prefix" : self = .invalidS3PrefixException(try InvalidS3PrefixException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSnsTopicName" : self = .invalidSnsTopicNameException(try InvalidSnsTopicNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameter" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyDisabled" : self = .kmsKeyDisabledException(try KmsKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyNotFound" : self = .kmsKeyNotFoundException(try KmsKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumNumberOfTrailsExceeded" : self = .maximumNumberOfTrailsExceededException(try MaximumNumberOfTrailsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesMode" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationsNotInUse" : self = .organizationsNotInUseException(try OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3BucketDoesNotExist" : self = .s3BucketDoesNotExistException(try S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailAlreadyExists" : self = .trailAlreadyExistsException(try TrailAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotProvided" : self = .trailNotProvidedException(try TrailNotProvidedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTrailOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailAccessNotEnabledException(CloudTrailAccessNotEnabledException)
    case cloudTrailInvalidClientTokenIdException(CloudTrailInvalidClientTokenIdException)
    case cloudWatchLogsDeliveryUnavailableException(CloudWatchLogsDeliveryUnavailableException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case insufficientS3BucketPolicyException(InsufficientS3BucketPolicyException)
    case insufficientSnsTopicPolicyException(InsufficientSnsTopicPolicyException)
    case invalidCloudWatchLogsLogGroupArnException(InvalidCloudWatchLogsLogGroupArnException)
    case invalidCloudWatchLogsRoleArnException(InvalidCloudWatchLogsRoleArnException)
    case invalidKmsKeyIdException(InvalidKmsKeyIdException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidS3BucketNameException(InvalidS3BucketNameException)
    case invalidS3PrefixException(InvalidS3PrefixException)
    case invalidSnsTopicNameException(InvalidSnsTopicNameException)
    case invalidTagParameterException(InvalidTagParameterException)
    case invalidTrailNameException(InvalidTrailNameException)
    case kmsException(KmsException)
    case kmsKeyDisabledException(KmsKeyDisabledException)
    case kmsKeyNotFoundException(KmsKeyNotFoundException)
    case maximumNumberOfTrailsExceededException(MaximumNumberOfTrailsExceededException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case organizationsNotInUseException(OrganizationsNotInUseException)
    case s3BucketDoesNotExistException(S3BucketDoesNotExistException)
    case trailAlreadyExistsException(TrailAlreadyExistsException)
    case trailNotProvidedException(TrailNotProvidedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTrailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTrailOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchLogsLogGroupArn = output.cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = output.cloudWatchLogsRoleArn
            self.includeGlobalServiceEvents = output.includeGlobalServiceEvents
            self.isMultiRegionTrail = output.isMultiRegionTrail
            self.isOrganizationTrail = output.isOrganizationTrail
            self.kmsKeyId = output.kmsKeyId
            self.logFileValidationEnabled = output.logFileValidationEnabled
            self.name = output.name
            self.s3BucketName = output.s3BucketName
            self.s3KeyPrefix = output.s3KeyPrefix
            self.snsTopicARN = output.snsTopicARN
            self.snsTopicName = output.snsTopicName
            self.trailARN = output.trailARN
        } else {
            self.cloudWatchLogsLogGroupArn = nil
            self.cloudWatchLogsRoleArn = nil
            self.includeGlobalServiceEvents = nil
            self.isMultiRegionTrail = nil
            self.isOrganizationTrail = nil
            self.kmsKeyId = nil
            self.logFileValidationEnabled = nil
            self.name = nil
            self.s3BucketName = nil
            self.s3KeyPrefix = nil
            self.snsTopicARN = nil
            self.snsTopicName = nil
            self.trailARN = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct CreateTrailOutputResponse: Swift.Equatable {
    /// Specifies the Amazon Resource Name (ARN) of the log group to which CloudTrail logs will be delivered.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail exists in one region or in all regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is an organization trail.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID that encrypts the logs delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether log file integrity validation is enabled.
    public var logFileValidationEnabled: Swift.Bool?
    /// Specifies the name of the trail.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files.
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html).
    public var s3KeyPrefix: Swift.String?
    /// Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The format of a topic ARN is: arn:aws:sns:us-east-2:123456789012:MyTopic
    public var snsTopicARN: Swift.String?
    /// This field is no longer in use. Use SnsTopicARN.
    @available(*, deprecated)
    public var snsTopicName: Swift.String?
    /// Specifies the ARN of the trail that was created. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    public var trailARN: Swift.String?

    public init (
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        logFileValidationEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicARN: Swift.String? = nil,
        snsTopicName: Swift.String? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.logFileValidationEnabled = logFileValidationEnabled
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicARN = snsTopicARN
        self.snsTopicName = snsTopicName
        self.trailARN = trailARN
    }
}

struct CreateTrailOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let snsTopicName: Swift.String?
    let snsTopicARN: Swift.String?
    let includeGlobalServiceEvents: Swift.Bool?
    let isMultiRegionTrail: Swift.Bool?
    let trailARN: Swift.String?
    let logFileValidationEnabled: Swift.Bool?
    let cloudWatchLogsLogGroupArn: Swift.String?
    let cloudWatchLogsRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let isOrganizationTrail: Swift.Bool?
}

extension CreateTrailOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicARN = "SnsTopicARN"
        case snsTopicName = "SnsTopicName"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

extension CloudTrailClientTypes.DataResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for dataresourcevalues0 in values {
                try valuesContainer.encode(dataresourcevalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CloudTrailClientTypes {
    /// The Amazon S3 buckets, Lambda functions, or Amazon DynamoDB tables that you specify in your event selectors for your trail to log data events. Data events provide information about the resource operations performed on or within a resource itself. These are also known as data plane operations. You can specify up to 250 data resources for a trail. The total number of allowed data resources is 250. This number can be distributed between 1 and 5 event selectors, but the total cannot exceed 250 across all selectors. If you are using advanced event selectors, the maximum total number of values for all conditions, across all advanced event selectors for the trail, is 500. The following example demonstrates how logging works when you configure logging of all data events for an S3 bucket named bucket-1. In this example, the CloudTrail user specified an empty prefix, and the option to log both Read and Write data events.
    ///
    /// * A user uploads an image file to bucket-1.
    ///
    /// * The PutObject API operation is an Amazon S3 object-level API. It is recorded as a data event in CloudTrail. Because the CloudTrail user specified an S3 bucket with an empty prefix, events that occur on any object in that bucket are logged. The trail processes and logs the event.
    ///
    /// * A user uploads an object to an Amazon S3 bucket named arn:aws:s3:::bucket-2.
    ///
    /// * The PutObject API operation occurred for an object in an S3 bucket that the CloudTrail user didn't specify for the trail. The trail doesn‚Äôt log the event.
    ///
    ///
    /// The following example demonstrates how logging works when you configure logging of Lambda data events for a Lambda function named MyLambdaFunction, but not for all Lambda functions.
    ///
    /// * A user runs a script that includes a call to the MyLambdaFunction function and the MyOtherLambdaFunction function.
    ///
    /// * The Invoke API operation on MyLambdaFunction is an Lambda API. It is recorded as a data event in CloudTrail. Because the CloudTrail user specified logging data events for MyLambdaFunction, any invocations of that function are logged. The trail processes and logs the event.
    ///
    /// * The Invoke API operation on MyOtherLambdaFunction is an Lambda API. Because the CloudTrail user did not specify logging data events for all Lambda functions, the Invoke operation for MyOtherLambdaFunction does not match the function specified for the trail. The trail doesn‚Äôt log the event.
    public struct DataResource: Swift.Equatable {
        /// The resource type in which you want to log data events. You can specify the following basic event selector resource types:
        ///
        /// * AWS::S3::Object
        ///
        /// * AWS::Lambda::Function
        ///
        /// * AWS::DynamoDB::Table
        ///
        ///
        /// The following resource types are also availble through advanced event selectors. Basic event selector resource types are valid in advanced event selectors, but advanced event selector resource types are not valid in basic event selectors. For more information, see [AdvancedFieldSelector$Field].
        ///
        /// * AWS::S3Outposts::Object
        ///
        /// * AWS::ManagedBlockchain::Node
        ///
        /// * AWS::S3ObjectLambda::AccessPoint
        ///
        /// * AWS::EC2::Snapshot
        ///
        /// * AWS::S3::AccessPoint
        ///
        /// * AWS::DynamoDB::Stream
        public var type: Swift.String?
        /// An array of Amazon Resource Name (ARN) strings or partial ARN strings for the specified objects.
        ///
        /// * To log data events for all objects in all S3 buckets in your Amazon Web Services account, specify the prefix as arn:aws:s3:::. This also enables logging of data event activity performed by any user or role in your Amazon Web Services account, even if that activity is performed on a bucket that belongs to another Amazon Web Services account.
        ///
        /// * To log data events for all objects in an S3 bucket, specify the bucket and an empty object prefix such as arn:aws:s3:::bucket-1/. The trail logs data events for all objects in this S3 bucket.
        ///
        /// * To log data events for specific objects, specify the S3 bucket and object prefix such as arn:aws:s3:::bucket-1/example-images. The trail logs data events for objects in this S3 bucket that match the prefix.
        ///
        /// * To log data events for all Lambda functions in your Amazon Web Services account, specify the prefix as arn:aws:lambda. This also enables logging of Invoke activity performed by any user or role in your Amazon Web Services account, even if that activity is performed on a function that belongs to another Amazon Web Services account.
        ///
        /// * To log data events for a specific Lambda function, specify the function ARN. Lambda function ARNs are exact. For example, if you specify a function ARN arn:aws:lambda:us-west-2:111111111111:function:helloworld, data events will only be logged for arn:aws:lambda:us-west-2:111111111111:function:helloworld. They will not be logged for arn:aws:lambda:us-west-2:111111111111:function:helloworld2.
        ///
        /// * To log data events for all DynamoDB tables in your Amazon Web Services account, specify the prefix as arn:aws:dynamodb.
        public var values: [Swift.String]?

        public init (
            type: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.type = type
            self.values = values
        }
    }

}

extension DeleteTrailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteTrailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The request that specifies the name of a trail to delete.
public struct DeleteTrailInput: Swift.Equatable {
    /// Specifies the name or the CloudTrail ARN of the trail to be deleted. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteTrailInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteTrailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteTrailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTrailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegion" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTrailOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidTrailNameException(InvalidTrailNameException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTrailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct DeleteTrailOutputResponse: Swift.Equatable {

}

extension DescribeTrailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeShadowTrails
        case trailNameList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeShadowTrails = includeShadowTrails {
            try encodeContainer.encode(includeShadowTrails, forKey: .includeShadowTrails)
        }
        if let trailNameList = trailNameList {
            var trailNameListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trailNameList)
            for trailnamelist0 in trailNameList {
                try trailNameListContainer.encode(trailnamelist0)
            }
        }
    }
}

extension DescribeTrailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Returns information about the trail.
public struct DescribeTrailsInput: Swift.Equatable {
    /// Specifies whether to include shadow trails in the response. A shadow trail is the replication in a region of a trail that was created in a different region, or in the case of an organization trail, the replication of an organization trail in member accounts. If you do not include shadow trails, organization trails in a member account and region replication trails will not be returned. The default is true.
    public var includeShadowTrails: Swift.Bool?
    /// Specifies a list of trail names, trail ARNs, or both, of the trails to describe. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail If an empty list is specified, information for the trail in the current region is returned.
    ///
    /// * If an empty list is specified and IncludeShadowTrails is false, then information for all trails in the current region is returned.
    ///
    /// * If an empty list is specified and IncludeShadowTrails is null or true, then information for all trails in the current region and any associated shadow trails in other regions is returned.
    ///
    ///
    /// If one or more trail names are specified, information is returned only if the names match the names of trails belonging only to the current region. To return information about a trail in another region, you must specify its trail ARN.
    public var trailNameList: [Swift.String]?

    public init (
        includeShadowTrails: Swift.Bool? = nil,
        trailNameList: [Swift.String]? = nil
    )
    {
        self.includeShadowTrails = includeShadowTrails
        self.trailNameList = trailNameList
    }
}

struct DescribeTrailsInputBody: Swift.Equatable {
    let trailNameList: [Swift.String]?
    let includeShadowTrails: Swift.Bool?
}

extension DescribeTrailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeShadowTrails
        case trailNameList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trailNameList)
        var trailNameListDecoded0:[Swift.String]? = nil
        if let trailNameListContainer = trailNameListContainer {
            trailNameListDecoded0 = [Swift.String]()
            for string0 in trailNameListContainer {
                if let string0 = string0 {
                    trailNameListDecoded0?.append(string0)
                }
            }
        }
        trailNameList = trailNameListDecoded0
        let includeShadowTrailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeShadowTrails)
        includeShadowTrails = includeShadowTrailsDecoded
    }
}

extension DescribeTrailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrailsOutputError: Swift.Error, Swift.Equatable {
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trailList = output.trailList
        } else {
            self.trailList = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct DescribeTrailsOutputResponse: Swift.Equatable {
    /// The list of trail objects. Trail objects with string values are only returned if values for the objects exist in a trail's configuration. For example, SNSTopicName and SNSTopicARN are only returned in results if a trail is configured to send SNS notifications. Similarly, KMSKeyId only appears in results if a trail's log files are encrypted with KMS customer managed keys.
    public var trailList: [CloudTrailClientTypes.Trail]?

    public init (
        trailList: [CloudTrailClientTypes.Trail]? = nil
    )
    {
        self.trailList = trailList
    }
}

struct DescribeTrailsOutputResponseBody: Swift.Equatable {
    let trailList: [CloudTrailClientTypes.Trail]?
}

extension DescribeTrailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Trail?].self, forKey: .trailList)
        var trailListDecoded0:[CloudTrailClientTypes.Trail]? = nil
        if let trailListContainer = trailListContainer {
            trailListDecoded0 = [CloudTrailClientTypes.Trail]()
            for structure0 in trailListContainer {
                if let structure0 = structure0 {
                    trailListDecoded0?.append(structure0)
                }
            }
        }
        trailList = trailListDecoded0
    }
}

extension CloudTrailClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case cloudTrailEvent = "CloudTrailEvent"
        case eventId = "EventId"
        case eventName = "EventName"
        case eventSource = "EventSource"
        case eventTime = "EventTime"
        case readOnly = "ReadOnly"
        case resources = "Resources"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let cloudTrailEvent = cloudTrailEvent {
            try encodeContainer.encode(cloudTrailEvent, forKey: .cloudTrailEvent)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventName = eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let eventSource = eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let eventTime = eventTime {
            try encodeContainer.encode(eventTime.timeIntervalSince1970, forKey: .eventTime)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resourcelist0 in resources {
                try resourcesContainer.encode(resourcelist0)
            }
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let eventTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[CloudTrailClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [CloudTrailClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let cloudTrailEventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudTrailEvent)
        cloudTrailEvent = cloudTrailEventDecoded
    }
}

extension CloudTrailClientTypes {
    /// Contains information about an event that was returned by a lookup request. The result includes a representation of a CloudTrail event.
    public struct Event: Swift.Equatable {
        /// The Amazon Web Services access key ID that was used to sign the request. If the request was made with temporary security credentials, this is the access key ID of the temporary credentials.
        public var accessKeyId: Swift.String?
        /// A JSON string that contains a representation of the event returned.
        public var cloudTrailEvent: Swift.String?
        /// The CloudTrail ID of the event returned.
        public var eventId: Swift.String?
        /// The name of the event returned.
        public var eventName: Swift.String?
        /// The Amazon Web Services service to which the request was made.
        public var eventSource: Swift.String?
        /// The date and time of the event returned.
        public var eventTime: ClientRuntime.Date?
        /// Information about whether the event is a write event or a read event.
        public var readOnly: Swift.String?
        /// A list of resources referenced by the event returned.
        public var resources: [CloudTrailClientTypes.Resource]?
        /// A user name or role name of the requester that called the API in the event returned.
        public var username: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            cloudTrailEvent: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventName: Swift.String? = nil,
            eventSource: Swift.String? = nil,
            eventTime: ClientRuntime.Date? = nil,
            readOnly: Swift.String? = nil,
            resources: [CloudTrailClientTypes.Resource]? = nil,
            username: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.cloudTrailEvent = cloudTrailEvent
            self.eventId = eventId
            self.eventName = eventName
            self.eventSource = eventSource
            self.eventTime = eventTime
            self.readOnly = readOnly
            self.resources = resources
            self.username = username
        }
    }

}

extension CloudTrailClientTypes {
    public enum EventCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insight
        case sdkUnknown(Swift.String)

        public static var allCases: [EventCategory] {
            return [
                .insight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insight: return "insight"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventCategory(rawValue: rawValue) ?? EventCategory.sdkUnknown(rawValue)
        }
    }
}

extension CloudTrailClientTypes.EventSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataResources = "DataResources"
        case excludeManagementEventSources = "ExcludeManagementEventSources"
        case includeManagementEvents = "IncludeManagementEvents"
        case readWriteType = "ReadWriteType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataResources = dataResources {
            var dataResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataResources)
            for dataresources0 in dataResources {
                try dataResourcesContainer.encode(dataresources0)
            }
        }
        if let excludeManagementEventSources = excludeManagementEventSources {
            var excludeManagementEventSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeManagementEventSources)
            for excludemanagementeventsources0 in excludeManagementEventSources {
                try excludeManagementEventSourcesContainer.encode(excludemanagementeventsources0)
            }
        }
        if let includeManagementEvents = includeManagementEvents {
            try encodeContainer.encode(includeManagementEvents, forKey: .includeManagementEvents)
        }
        if let readWriteType = readWriteType {
            try encodeContainer.encode(readWriteType.rawValue, forKey: .readWriteType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readWriteTypeDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ReadWriteType.self, forKey: .readWriteType)
        readWriteType = readWriteTypeDecoded
        let includeManagementEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeManagementEvents)
        includeManagementEvents = includeManagementEventsDecoded
        let dataResourcesContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.DataResource?].self, forKey: .dataResources)
        var dataResourcesDecoded0:[CloudTrailClientTypes.DataResource]? = nil
        if let dataResourcesContainer = dataResourcesContainer {
            dataResourcesDecoded0 = [CloudTrailClientTypes.DataResource]()
            for structure0 in dataResourcesContainer {
                if let structure0 = structure0 {
                    dataResourcesDecoded0?.append(structure0)
                }
            }
        }
        dataResources = dataResourcesDecoded0
        let excludeManagementEventSourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeManagementEventSources)
        var excludeManagementEventSourcesDecoded0:[Swift.String]? = nil
        if let excludeManagementEventSourcesContainer = excludeManagementEventSourcesContainer {
            excludeManagementEventSourcesDecoded0 = [Swift.String]()
            for string0 in excludeManagementEventSourcesContainer {
                if let string0 = string0 {
                    excludeManagementEventSourcesDecoded0?.append(string0)
                }
            }
        }
        excludeManagementEventSources = excludeManagementEventSourcesDecoded0
    }
}

extension CloudTrailClientTypes {
    /// Use event selectors to further specify the management and data event settings for your trail. By default, trails created without specific event selectors will be configured to log all read and write management events, and no data events. When an event occurs in your account, CloudTrail evaluates the event selector for all trails. For each trail, if the event matches any event selector, the trail processes and logs the event. If the event doesn't match any event selector, the trail doesn't log the event. You can configure up to five event selectors for a trail. You cannot apply both event selectors and advanced event selectors to a trail.
    public struct EventSelector: Swift.Equatable {
        /// CloudTrail supports data event logging for Amazon S3 objects, Lambda functions, and Amazon DynamoDB tables with basic event selectors. You can specify up to 250 resources for an individual event selector, but the total number of data resources cannot exceed 250 across all event selectors in a trail. This limit does not apply if you configure resource logging for all data events. For more information, see [Data Events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-management-and-data-events-with-cloudtrail.html#logging-data-events) and [Limits in CloudTrail](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/WhatIsCloudTrail-Limits.html) in the CloudTrail User Guide.
        public var dataResources: [CloudTrailClientTypes.DataResource]?
        /// An optional list of service event sources from which you do not want management events to be logged on your trail. In this release, the list can be empty (disables the filter), or it can filter out Key Management Service or Amazon RDS Data API events by containing kms.amazonaws.com or rdsdata.amazonaws.com. By default, ExcludeManagementEventSources is empty, and KMS and Amazon RDS Data API events are logged to your trail.
        public var excludeManagementEventSources: [Swift.String]?
        /// Specify if you want your event selector to include management events for your trail. For more information, see [Management Events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-management-and-data-events-with-cloudtrail.html#logging-management-events) in the CloudTrail User Guide. By default, the value is true. The first copy of management events is free. You are charged for additional copies of management events that you are logging on any subsequent trail in the same region. For more information about CloudTrail pricing, see [CloudTrail Pricing](http://aws.amazon.com/cloudtrail/pricing/).
        public var includeManagementEvents: Swift.Bool?
        /// Specify if you want your trail to log read-only events, write-only events, or all. For example, the EC2 GetConsoleOutput is a read-only API operation and RunInstances is a write-only API operation. By default, the value is All.
        public var readWriteType: CloudTrailClientTypes.ReadWriteType?

        public init (
            dataResources: [CloudTrailClientTypes.DataResource]? = nil,
            excludeManagementEventSources: [Swift.String]? = nil,
            includeManagementEvents: Swift.Bool? = nil,
            readWriteType: CloudTrailClientTypes.ReadWriteType? = nil
        )
        {
            self.dataResources = dataResources
            self.excludeManagementEventSources = excludeManagementEventSources
            self.includeManagementEvents = includeManagementEvents
            self.readWriteType = readWriteType
        }
    }

}

extension GetEventSelectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailName = "TrailName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trailName = trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

extension GetEventSelectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEventSelectorsInput: Swift.Equatable {
    /// Specifies the name of the trail or trail ARN. If you specify a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If you specify a trail ARN, it must be in the format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var trailName: Swift.String?

    public init (
        trailName: Swift.String? = nil
    )
    {
        self.trailName = trailName
    }
}

struct GetEventSelectorsInputBody: Swift.Equatable {
    let trailName: Swift.String?
}

extension GetEventSelectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailName = "TrailName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailName)
        trailName = trailNameDecoded
    }
}

extension GetEventSelectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventSelectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventSelectorsOutputError: Swift.Error, Swift.Equatable {
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventSelectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEventSelectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.eventSelectors = output.eventSelectors
            self.trailARN = output.trailARN
        } else {
            self.advancedEventSelectors = nil
            self.eventSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct GetEventSelectorsOutputResponse: Swift.Equatable {
    /// The advanced event selectors that are configured for the trail.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The event selectors that are configured for the trail.
    public var eventSelectors: [CloudTrailClientTypes.EventSelector]?
    /// The specified trail ARN that has the event selectors.
    public var trailARN: Swift.String?

    public init (
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventSelectors: [CloudTrailClientTypes.EventSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailARN = trailARN
    }
}

struct GetEventSelectorsOutputResponseBody: Swift.Equatable {
    let trailARN: Swift.String?
    let eventSelectors: [CloudTrailClientTypes.EventSelector]?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
}

extension GetEventSelectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let eventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.EventSelector?].self, forKey: .eventSelectors)
        var eventSelectorsDecoded0:[CloudTrailClientTypes.EventSelector]? = nil
        if let eventSelectorsContainer = eventSelectorsContainer {
            eventSelectorsDecoded0 = [CloudTrailClientTypes.EventSelector]()
            for structure0 in eventSelectorsContainer {
                if let structure0 = structure0 {
                    eventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        eventSelectors = eventSelectorsDecoded0
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

extension GetInsightSelectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailName = "TrailName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trailName = trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

extension GetInsightSelectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInsightSelectorsInput: Swift.Equatable {
    /// Specifies the name of the trail or trail ARN. If you specify a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If you specify a trail ARN, it must be in the format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var trailName: Swift.String?

    public init (
        trailName: Swift.String? = nil
    )
    {
        self.trailName = trailName
    }
}

struct GetInsightSelectorsInputBody: Swift.Equatable {
    let trailName: Swift.String?
}

extension GetInsightSelectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailName = "TrailName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailName)
        trailName = trailNameDecoded
    }
}

extension GetInsightSelectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightSelectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsightNotEnabled" : self = .insightNotEnabledException(try InsightNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInsightSelectorsOutputError: Swift.Error, Swift.Equatable {
    case insightNotEnabledException(InsightNotEnabledException)
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightSelectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInsightSelectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.insightSelectors = output.insightSelectors
            self.trailARN = output.trailARN
        } else {
            self.insightSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct GetInsightSelectorsOutputResponse: Swift.Equatable {
    /// A JSON string that contains the insight types you want to log on a trail. In this release, only ApiCallRateInsight is supported as an insight type.
    public var insightSelectors: [CloudTrailClientTypes.InsightSelector]?
    /// The Amazon Resource Name (ARN) of a trail for which you want to get Insights selectors.
    public var trailARN: Swift.String?

    public init (
        insightSelectors: [CloudTrailClientTypes.InsightSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.insightSelectors = insightSelectors
        self.trailARN = trailARN
    }
}

struct GetInsightSelectorsOutputResponseBody: Swift.Equatable {
    let trailARN: Swift.String?
    let insightSelectors: [CloudTrailClientTypes.InsightSelector]?
}

extension GetInsightSelectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let insightSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.InsightSelector?].self, forKey: .insightSelectors)
        var insightSelectorsDecoded0:[CloudTrailClientTypes.InsightSelector]? = nil
        if let insightSelectorsContainer = insightSelectorsContainer {
            insightSelectorsDecoded0 = [CloudTrailClientTypes.InsightSelector]()
            for structure0 in insightSelectorsContainer {
                if let structure0 = structure0 {
                    insightSelectorsDecoded0?.append(structure0)
                }
            }
        }
        insightSelectors = insightSelectorsDecoded0
    }
}

extension GetTrailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetTrailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTrailInput: Swift.Equatable {
    /// The name or the Amazon Resource Name (ARN) of the trail for which you want to retrieve settings information.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetTrailInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetTrailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTrailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTrailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTrailOutputError: Swift.Error, Swift.Equatable {
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTrailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTrailOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trail = output.trail
        } else {
            self.trail = nil
        }
    }
}

public struct GetTrailOutputResponse: Swift.Equatable {
    /// The settings for a trail.
    public var trail: CloudTrailClientTypes.Trail?

    public init (
        trail: CloudTrailClientTypes.Trail? = nil
    )
    {
        self.trail = trail
    }
}

struct GetTrailOutputResponseBody: Swift.Equatable {
    let trail: CloudTrailClientTypes.Trail?
}

extension GetTrailOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trail = "Trail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.Trail.self, forKey: .trail)
        trail = trailDecoded
    }
}

extension GetTrailStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetTrailStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The name of a trail about which you want the current status.
public struct GetTrailStatusInput: Swift.Equatable {
    /// Specifies the name or the CloudTrail ARN of the trail for which you are requesting status. To get the status of a shadow trail (a replication of the trail in another region), you must specify its ARN. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetTrailStatusInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetTrailStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTrailStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTrailStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTrailStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTrailStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTrailStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isLogging = output.isLogging
            self.latestCloudWatchLogsDeliveryError = output.latestCloudWatchLogsDeliveryError
            self.latestCloudWatchLogsDeliveryTime = output.latestCloudWatchLogsDeliveryTime
            self.latestDeliveryAttemptSucceeded = output.latestDeliveryAttemptSucceeded
            self.latestDeliveryAttemptTime = output.latestDeliveryAttemptTime
            self.latestDeliveryError = output.latestDeliveryError
            self.latestDeliveryTime = output.latestDeliveryTime
            self.latestDigestDeliveryError = output.latestDigestDeliveryError
            self.latestDigestDeliveryTime = output.latestDigestDeliveryTime
            self.latestNotificationAttemptSucceeded = output.latestNotificationAttemptSucceeded
            self.latestNotificationAttemptTime = output.latestNotificationAttemptTime
            self.latestNotificationError = output.latestNotificationError
            self.latestNotificationTime = output.latestNotificationTime
            self.startLoggingTime = output.startLoggingTime
            self.stopLoggingTime = output.stopLoggingTime
            self.timeLoggingStarted = output.timeLoggingStarted
            self.timeLoggingStopped = output.timeLoggingStopped
        } else {
            self.isLogging = nil
            self.latestCloudWatchLogsDeliveryError = nil
            self.latestCloudWatchLogsDeliveryTime = nil
            self.latestDeliveryAttemptSucceeded = nil
            self.latestDeliveryAttemptTime = nil
            self.latestDeliveryError = nil
            self.latestDeliveryTime = nil
            self.latestDigestDeliveryError = nil
            self.latestDigestDeliveryTime = nil
            self.latestNotificationAttemptSucceeded = nil
            self.latestNotificationAttemptTime = nil
            self.latestNotificationError = nil
            self.latestNotificationTime = nil
            self.startLoggingTime = nil
            self.stopLoggingTime = nil
            self.timeLoggingStarted = nil
            self.timeLoggingStopped = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct GetTrailStatusOutputResponse: Swift.Equatable {
    /// Whether the CloudTrail trail is currently logging Amazon Web Services API calls.
    public var isLogging: Swift.Bool?
    /// Displays any CloudWatch Logs error that CloudTrail encountered when attempting to deliver logs to CloudWatch Logs.
    public var latestCloudWatchLogsDeliveryError: Swift.String?
    /// Displays the most recent date and time when CloudTrail delivered logs to CloudWatch Logs.
    public var latestCloudWatchLogsDeliveryTime: ClientRuntime.Date?
    /// This field is no longer in use.
    public var latestDeliveryAttemptSucceeded: Swift.String?
    /// This field is no longer in use.
    public var latestDeliveryAttemptTime: Swift.String?
    /// Displays any Amazon S3 error that CloudTrail encountered when attempting to deliver log files to the designated bucket. For more information, see [Error Responses](https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html) in the Amazon S3 API Reference. This error occurs only when there is a problem with the destination S3 bucket, and does not occur for requests that time out. To resolve the issue, create a new bucket, and then call UpdateTrail to specify the new bucket; or fix the existing objects so that CloudTrail can again write to the bucket.
    public var latestDeliveryError: Swift.String?
    /// Specifies the date and time that CloudTrail last delivered log files to an account's Amazon S3 bucket.
    public var latestDeliveryTime: ClientRuntime.Date?
    /// Displays any Amazon S3 error that CloudTrail encountered when attempting to deliver a digest file to the designated bucket. For more information, see [Error Responses](https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html) in the Amazon S3 API Reference. This error occurs only when there is a problem with the destination S3 bucket, and does not occur for requests that time out. To resolve the issue, create a new bucket, and then call UpdateTrail to specify the new bucket; or fix the existing objects so that CloudTrail can again write to the bucket.
    public var latestDigestDeliveryError: Swift.String?
    /// Specifies the date and time that CloudTrail last delivered a digest file to an account's Amazon S3 bucket.
    public var latestDigestDeliveryTime: ClientRuntime.Date?
    /// This field is no longer in use.
    public var latestNotificationAttemptSucceeded: Swift.String?
    /// This field is no longer in use.
    public var latestNotificationAttemptTime: Swift.String?
    /// Displays any Amazon SNS error that CloudTrail encountered when attempting to send a notification. For more information about Amazon SNS errors, see the [Amazon SNS Developer Guide](https://docs.aws.amazon.com/sns/latest/dg/welcome.html).
    public var latestNotificationError: Swift.String?
    /// Specifies the date and time of the most recent Amazon SNS notification that CloudTrail has written a new log file to an account's Amazon S3 bucket.
    public var latestNotificationTime: ClientRuntime.Date?
    /// Specifies the most recent date and time when CloudTrail started recording API calls for an Amazon Web Services account.
    public var startLoggingTime: ClientRuntime.Date?
    /// Specifies the most recent date and time when CloudTrail stopped recording API calls for an Amazon Web Services account.
    public var stopLoggingTime: ClientRuntime.Date?
    /// This field is no longer in use.
    public var timeLoggingStarted: Swift.String?
    /// This field is no longer in use.
    public var timeLoggingStopped: Swift.String?

    public init (
        isLogging: Swift.Bool? = nil,
        latestCloudWatchLogsDeliveryError: Swift.String? = nil,
        latestCloudWatchLogsDeliveryTime: ClientRuntime.Date? = nil,
        latestDeliveryAttemptSucceeded: Swift.String? = nil,
        latestDeliveryAttemptTime: Swift.String? = nil,
        latestDeliveryError: Swift.String? = nil,
        latestDeliveryTime: ClientRuntime.Date? = nil,
        latestDigestDeliveryError: Swift.String? = nil,
        latestDigestDeliveryTime: ClientRuntime.Date? = nil,
        latestNotificationAttemptSucceeded: Swift.String? = nil,
        latestNotificationAttemptTime: Swift.String? = nil,
        latestNotificationError: Swift.String? = nil,
        latestNotificationTime: ClientRuntime.Date? = nil,
        startLoggingTime: ClientRuntime.Date? = nil,
        stopLoggingTime: ClientRuntime.Date? = nil,
        timeLoggingStarted: Swift.String? = nil,
        timeLoggingStopped: Swift.String? = nil
    )
    {
        self.isLogging = isLogging
        self.latestCloudWatchLogsDeliveryError = latestCloudWatchLogsDeliveryError
        self.latestCloudWatchLogsDeliveryTime = latestCloudWatchLogsDeliveryTime
        self.latestDeliveryAttemptSucceeded = latestDeliveryAttemptSucceeded
        self.latestDeliveryAttemptTime = latestDeliveryAttemptTime
        self.latestDeliveryError = latestDeliveryError
        self.latestDeliveryTime = latestDeliveryTime
        self.latestDigestDeliveryError = latestDigestDeliveryError
        self.latestDigestDeliveryTime = latestDigestDeliveryTime
        self.latestNotificationAttemptSucceeded = latestNotificationAttemptSucceeded
        self.latestNotificationAttemptTime = latestNotificationAttemptTime
        self.latestNotificationError = latestNotificationError
        self.latestNotificationTime = latestNotificationTime
        self.startLoggingTime = startLoggingTime
        self.stopLoggingTime = stopLoggingTime
        self.timeLoggingStarted = timeLoggingStarted
        self.timeLoggingStopped = timeLoggingStopped
    }
}

struct GetTrailStatusOutputResponseBody: Swift.Equatable {
    let isLogging: Swift.Bool?
    let latestDeliveryError: Swift.String?
    let latestNotificationError: Swift.String?
    let latestDeliveryTime: ClientRuntime.Date?
    let latestNotificationTime: ClientRuntime.Date?
    let startLoggingTime: ClientRuntime.Date?
    let stopLoggingTime: ClientRuntime.Date?
    let latestCloudWatchLogsDeliveryError: Swift.String?
    let latestCloudWatchLogsDeliveryTime: ClientRuntime.Date?
    let latestDigestDeliveryTime: ClientRuntime.Date?
    let latestDigestDeliveryError: Swift.String?
    let latestDeliveryAttemptTime: Swift.String?
    let latestNotificationAttemptTime: Swift.String?
    let latestNotificationAttemptSucceeded: Swift.String?
    let latestDeliveryAttemptSucceeded: Swift.String?
    let timeLoggingStarted: Swift.String?
    let timeLoggingStopped: Swift.String?
}

extension GetTrailStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLogging = "IsLogging"
        case latestCloudWatchLogsDeliveryError = "LatestCloudWatchLogsDeliveryError"
        case latestCloudWatchLogsDeliveryTime = "LatestCloudWatchLogsDeliveryTime"
        case latestDeliveryAttemptSucceeded = "LatestDeliveryAttemptSucceeded"
        case latestDeliveryAttemptTime = "LatestDeliveryAttemptTime"
        case latestDeliveryError = "LatestDeliveryError"
        case latestDeliveryTime = "LatestDeliveryTime"
        case latestDigestDeliveryError = "LatestDigestDeliveryError"
        case latestDigestDeliveryTime = "LatestDigestDeliveryTime"
        case latestNotificationAttemptSucceeded = "LatestNotificationAttemptSucceeded"
        case latestNotificationAttemptTime = "LatestNotificationAttemptTime"
        case latestNotificationError = "LatestNotificationError"
        case latestNotificationTime = "LatestNotificationTime"
        case startLoggingTime = "StartLoggingTime"
        case stopLoggingTime = "StopLoggingTime"
        case timeLoggingStarted = "TimeLoggingStarted"
        case timeLoggingStopped = "TimeLoggingStopped"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isLoggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLogging)
        isLogging = isLoggingDecoded
        let latestDeliveryErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDeliveryError)
        latestDeliveryError = latestDeliveryErrorDecoded
        let latestNotificationErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestNotificationError)
        latestNotificationError = latestNotificationErrorDecoded
        let latestDeliveryTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .latestDeliveryTime)
        latestDeliveryTime = latestDeliveryTimeDecoded
        let latestNotificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .latestNotificationTime)
        latestNotificationTime = latestNotificationTimeDecoded
        let startLoggingTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startLoggingTime)
        startLoggingTime = startLoggingTimeDecoded
        let stopLoggingTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopLoggingTime)
        stopLoggingTime = stopLoggingTimeDecoded
        let latestCloudWatchLogsDeliveryErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestCloudWatchLogsDeliveryError)
        latestCloudWatchLogsDeliveryError = latestCloudWatchLogsDeliveryErrorDecoded
        let latestCloudWatchLogsDeliveryTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .latestCloudWatchLogsDeliveryTime)
        latestCloudWatchLogsDeliveryTime = latestCloudWatchLogsDeliveryTimeDecoded
        let latestDigestDeliveryTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .latestDigestDeliveryTime)
        latestDigestDeliveryTime = latestDigestDeliveryTimeDecoded
        let latestDigestDeliveryErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDigestDeliveryError)
        latestDigestDeliveryError = latestDigestDeliveryErrorDecoded
        let latestDeliveryAttemptTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDeliveryAttemptTime)
        latestDeliveryAttemptTime = latestDeliveryAttemptTimeDecoded
        let latestNotificationAttemptTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestNotificationAttemptTime)
        latestNotificationAttemptTime = latestNotificationAttemptTimeDecoded
        let latestNotificationAttemptSucceededDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestNotificationAttemptSucceeded)
        latestNotificationAttemptSucceeded = latestNotificationAttemptSucceededDecoded
        let latestDeliveryAttemptSucceededDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDeliveryAttemptSucceeded)
        latestDeliveryAttemptSucceeded = latestDeliveryAttemptSucceededDecoded
        let timeLoggingStartedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeLoggingStarted)
        timeLoggingStarted = timeLoggingStartedDecoded
        let timeLoggingStoppedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeLoggingStopped)
        timeLoggingStopped = timeLoggingStoppedDecoded
    }
}

extension InsightNotEnabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InsightNotEnabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// If you run GetInsightSelectors on a trail that does not have Insights events enabled, the operation throws the exception InsightNotEnabledException.
public struct InsightNotEnabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsightNotEnabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsightNotEnabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.InsightSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightType = "InsightType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightType = insightType {
            try encodeContainer.encode(insightType.rawValue, forKey: .insightType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightTypeDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.InsightType.self, forKey: .insightType)
        insightType = insightTypeDecoded
    }
}

extension CloudTrailClientTypes {
    /// A JSON string that contains a list of insight types that are logged on a trail.
    public struct InsightSelector: Swift.Equatable {
        /// The type of Insights events to log on a trail. The valid Insights type in this release is ApiCallRateInsight.
        public var insightType: CloudTrailClientTypes.InsightType?

        public init (
            insightType: CloudTrailClientTypes.InsightType? = nil
        )
        {
            self.insightType = insightType
        }
    }

}

extension CloudTrailClientTypes {
    public enum InsightType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apicallrateinsight
        case apierrorrateinsight
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightType] {
            return [
                .apicallrateinsight,
                .apierrorrateinsight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apicallrateinsight: return "ApiCallRateInsight"
            case .apierrorrateinsight: return "ApiErrorRateInsight"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightType(rawValue: rawValue) ?? InsightType.sdkUnknown(rawValue)
        }
    }
}

extension InsufficientDependencyServiceAccessPermissionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InsufficientDependencyServiceAccessPermissionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the IAM user or role that is used to create the organization trail is lacking one or more required permissions for creating an organization trail in a required service. For more information, see [Prepare For Creating a Trail For Your Organization](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html).
public struct InsufficientDependencyServiceAccessPermissionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDependencyServiceAccessPermissionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientDependencyServiceAccessPermissionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientEncryptionPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InsufficientEncryptionPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the policy on the S3 bucket or KMS key is not sufficient.
public struct InsufficientEncryptionPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientEncryptionPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientEncryptionPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientS3BucketPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InsufficientS3BucketPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the policy on the S3 bucket is not sufficient.
public struct InsufficientS3BucketPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientS3BucketPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientS3BucketPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientSnsTopicPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InsufficientSnsTopicPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the policy on the Amazon SNS topic is not sufficient.
public struct InsufficientSnsTopicPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientSnsTopicPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientSnsTopicPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCloudWatchLogsLogGroupArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidCloudWatchLogsLogGroupArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided CloudWatch Logs log group is not valid.
public struct InvalidCloudWatchLogsLogGroupArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCloudWatchLogsLogGroupArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCloudWatchLogsLogGroupArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCloudWatchLogsRoleArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidCloudWatchLogsRoleArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided role is not valid.
public struct InvalidCloudWatchLogsRoleArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCloudWatchLogsRoleArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCloudWatchLogsRoleArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventCategoryException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidEventCategoryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs if an event category that is not valid is specified as a value of EventCategory.
public struct InvalidEventCategoryException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventCategoryExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEventCategoryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventSelectorsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidEventSelectorsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the PutEventSelectors operation is called with a number of event selectors, advanced event selectors, or data resources that is not valid. The combination of event selectors or advanced event selectors and data resources is not valid. A trail can have up to 5 event selectors. If a trail uses advanced event selectors, a maximum of 500 total values for all conditions in all advanced event selectors is allowed. A trail is limited to 250 data resources. These data resources can be distributed across event selectors, but the overall total cannot exceed 250. You can:
///
/// * Specify a valid number of event selectors (1 to 5) for a trail.
///
/// * Specify a valid number of data resources (1 to 250) for an event selector. The limit of number of resources on an individual event selector is configurable up to 250. However, this upper limit is allowed only if the total number of data resources does not exceed 250 across all event selectors for a trail.
///
/// * Specify up to 500 values for all conditions in all advanced event selectors for a trail.
///
/// * Specify a valid value for a parameter. For example, specifying the ReadWriteType parameter with a value of read-only is not valid.
public struct InvalidEventSelectorsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventSelectorsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEventSelectorsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHomeRegionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidHomeRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when an operation is called on a trail from a region other than the region in which the trail was created.
public struct InvalidHomeRegionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidHomeRegionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidHomeRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInsightSelectorsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInsightSelectorsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The formatting or syntax of the InsightSelectors JSON statement in your PutInsightSelectors or GetInsightSelectors request is not valid, or the specified insight type in the InsightSelectors statement is not a valid insight type.
public struct InvalidInsightSelectorsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInsightSelectorsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInsightSelectorsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidKmsKeyIdException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidKmsKeyIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the KMS key ARN is not valid.
public struct InvalidKmsKeyIdException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidKmsKeyIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidKmsKeyIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLookupAttributesException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidLookupAttributesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs when a lookup attribute is specified that is not valid.
public struct InvalidLookupAttributesException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLookupAttributesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLookupAttributesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxResultsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidMaxResultsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown if the limit specified is not valid.
public struct InvalidMaxResultsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxResultsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMaxResultsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A token that is not valid, or a token that was previously used in a request with different parameters. This exception is thrown if the token is not valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the combination of parameters provided is not valid.
public struct InvalidParameterCombinationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3BucketNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidS3BucketNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided S3 bucket name is not valid.
public struct InvalidS3BucketNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3BucketNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3BucketNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3PrefixException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidS3PrefixExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided S3 prefix is not valid.
public struct InvalidS3PrefixException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3PrefixExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3PrefixExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSnsTopicNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSnsTopicNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided SNS topic name is not valid.
public struct InvalidSnsTopicNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSnsTopicNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSnsTopicNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTagParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified tag key or values are not valid. It can also occur if there are duplicate tags or too many tags on the resource.
public struct InvalidTagParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTimeRangeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTimeRangeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs if the timestamp values are not valid. Either the start time occurs after the end time, or the time range is outside the range of possible values.
public struct InvalidTimeRangeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTimeRangeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTimeRangeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Reserved for future use.
public struct InvalidTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTrailNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTrailNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:
///
/// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
///
/// * Start with a letter or number, and end with a letter or number
///
/// * Be between 3 and 128 characters
///
/// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
///
/// * Not be in IP address format (for example, 192.168.5.4)
public struct InvalidTrailNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTrailNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTrailNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KmsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when there is an issue with the specified KMS key and the trail can‚Äôt be updated.
public struct KmsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KmsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KmsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsKeyDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KmsKeyDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is no longer in use.
@available(*, deprecated)
public struct KmsKeyDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KmsKeyDisabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KmsKeyDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsKeyNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KmsKeyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the KMS key does not exist, when the S3 bucket and the KMS key are not in the same region, or when the KMS key associated with the Amazon SNS topic either does not exist or is not in the same region.
public struct KmsKeyNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KmsKeyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KmsKeyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListPublicKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

extension ListPublicKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Requests the public keys for a specified time range.
public struct ListPublicKeysInput: Swift.Equatable {
    /// Optionally specifies, in UTC, the end of the time range to look up public keys for CloudTrail digest files. If not specified, the current time is used.
    public var endTime: ClientRuntime.Date?
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Optionally specifies, in UTC, the start of the time range to look up public keys for CloudTrail digest files. If not specified, the current time is used, and the current public key is returned.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct ListPublicKeysInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let nextToken: Swift.String?
}

extension ListPublicKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPublicKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPublicKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTimeRange" : self = .invalidTimeRangeException(try InvalidTimeRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidToken" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPublicKeysOutputError: Swift.Error, Swift.Equatable {
    case invalidTimeRangeException(InvalidTimeRangeException)
    case invalidTokenException(InvalidTokenException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPublicKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPublicKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.publicKeyList = output.publicKeyList
        } else {
            self.nextToken = nil
            self.publicKeyList = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct ListPublicKeysOutputResponse: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Contains an array of PublicKey objects. The returned public keys may have validity time ranges that overlap.
    public var publicKeyList: [CloudTrailClientTypes.PublicKey]?

    public init (
        nextToken: Swift.String? = nil,
        publicKeyList: [CloudTrailClientTypes.PublicKey]? = nil
    )
    {
        self.nextToken = nextToken
        self.publicKeyList = publicKeyList
    }
}

struct ListPublicKeysOutputResponseBody: Swift.Equatable {
    let publicKeyList: [CloudTrailClientTypes.PublicKey]?
    let nextToken: Swift.String?
}

extension ListPublicKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case publicKeyList = "PublicKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.PublicKey?].self, forKey: .publicKeyList)
        var publicKeyListDecoded0:[CloudTrailClientTypes.PublicKey]? = nil
        if let publicKeyListContainer = publicKeyListContainer {
            publicKeyListDecoded0 = [CloudTrailClientTypes.PublicKey]()
            for structure0 in publicKeyListContainer {
                if let structure0 = structure0 {
                    publicKeyListDecoded0?.append(structure0)
                }
            }
        }
        publicKeyList = publicKeyListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceIdList = "ResourceIdList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIdList = resourceIdList {
            var resourceIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIdList)
            for resourceidlist0 in resourceIdList {
                try resourceIdListContainer.encode(resourceidlist0)
            }
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies a list of trail tags to return.
public struct ListTagsInput: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Specifies a list of trail ARNs whose tags will be listed. The list has a limit of 20 ARNs. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var resourceIdList: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        resourceIdList: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdList = resourceIdList
    }
}

struct ListTagsInputBody: Swift.Equatable {
    let resourceIdList: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceIdList = "ResourceIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIdList)
        var resourceIdListDecoded0:[Swift.String]? = nil
        if let resourceIdListContainer = resourceIdListContainer {
            resourceIdListDecoded0 = [Swift.String]()
            for string0 in resourceIdListContainer {
                if let string0 = string0 {
                    resourceIdListDecoded0?.append(string0)
                }
            }
        }
        resourceIdList = resourceIdListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidToken" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceTypeNotSupported" : self = .resourceTypeNotSupportedException(try ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case invalidTokenException(InvalidTokenException)
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceTypeNotSupportedException(ResourceTypeNotSupportedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceTagList = output.resourceTagList
        } else {
            self.nextToken = nil
            self.resourceTagList = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct ListTagsOutputResponse: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// A list of resource tags.
    public var resourceTagList: [CloudTrailClientTypes.ResourceTag]?

    public init (
        nextToken: Swift.String? = nil,
        resourceTagList: [CloudTrailClientTypes.ResourceTag]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTagList = resourceTagList
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    let resourceTagList: [CloudTrailClientTypes.ResourceTag]?
    let nextToken: Swift.String?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceTagList = "ResourceTagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTagListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.ResourceTag?].self, forKey: .resourceTagList)
        var resourceTagListDecoded0:[CloudTrailClientTypes.ResourceTag]? = nil
        if let resourceTagListContainer = resourceTagListContainer {
            resourceTagListDecoded0 = [CloudTrailClientTypes.ResourceTag]()
            for structure0 in resourceTagListContainer {
                if let structure0 = structure0 {
                    resourceTagListDecoded0?.append(structure0)
                }
            }
        }
        resourceTagList = resourceTagListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTrailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTrailsInput: Swift.Equatable {
    /// The token to use to get the next page of results after a previous API call. This token must be passed in with the same parameters that were specified in the the original call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListTrailsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListTrailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTrailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTrailsOutputError: Swift.Error, Swift.Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTrailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTrailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trails = output.trails
        } else {
            self.nextToken = nil
            self.trails = nil
        }
    }
}

public struct ListTrailsOutputResponse: Swift.Equatable {
    /// The token to use to get the next page of results after a previous API call. If the token does not appear, there are no more results to return. The token must be passed in with the same parameters as the previous call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?
    /// Returns the name, ARN, and home region of trails in the current account.
    public var trails: [CloudTrailClientTypes.TrailInfo]?

    public init (
        nextToken: Swift.String? = nil,
        trails: [CloudTrailClientTypes.TrailInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.trails = trails
    }
}

struct ListTrailsOutputResponseBody: Swift.Equatable {
    let trails: [CloudTrailClientTypes.TrailInfo]?
    let nextToken: Swift.String?
}

extension ListTrailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case trails = "Trails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.TrailInfo?].self, forKey: .trails)
        var trailsDecoded0:[CloudTrailClientTypes.TrailInfo]? = nil
        if let trailsContainer = trailsContainer {
            trailsDecoded0 = [CloudTrailClientTypes.TrailInfo]()
            for structure0 in trailsContainer {
                if let structure0 = structure0 {
                    trailsDecoded0?.append(structure0)
                }
            }
        }
        trails = trailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudTrailClientTypes.LookupAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeKey = "AttributeKey"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeKey = attributeKey {
            try encodeContainer.encode(attributeKey.rawValue, forKey: .attributeKey)
        }
        if let attributeValue = attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeKeyDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.LookupAttributeKey.self, forKey: .attributeKey)
        attributeKey = attributeKeyDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension CloudTrailClientTypes {
    /// Specifies an attribute and value that filter the events returned.
    public struct LookupAttribute: Swift.Equatable {
        /// Specifies an attribute on which to filter the events returned.
        /// This member is required.
        public var attributeKey: CloudTrailClientTypes.LookupAttributeKey?
        /// Specifies a value for the specified AttributeKey.
        /// This member is required.
        public var attributeValue: Swift.String?

        public init (
            attributeKey: CloudTrailClientTypes.LookupAttributeKey? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributeKey = attributeKey
            self.attributeValue = attributeValue
        }
    }

}

extension CloudTrailClientTypes {
    public enum LookupAttributeKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessKeyId
        case eventId
        case eventName
        case eventSource
        case readOnly
        case resourceName
        case resourceType
        case username
        case sdkUnknown(Swift.String)

        public static var allCases: [LookupAttributeKey] {
            return [
                .accessKeyId,
                .eventId,
                .eventName,
                .eventSource,
                .readOnly,
                .resourceName,
                .resourceType,
                .username,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessKeyId: return "AccessKeyId"
            case .eventId: return "EventId"
            case .eventName: return "EventName"
            case .eventSource: return "EventSource"
            case .readOnly: return "ReadOnly"
            case .resourceName: return "ResourceName"
            case .resourceType: return "ResourceType"
            case .username: return "Username"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LookupAttributeKey(rawValue: rawValue) ?? LookupAttributeKey.sdkUnknown(rawValue)
        }
    }
}

extension LookupEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case eventCategory = "EventCategory"
        case lookupAttributes = "LookupAttributes"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let eventCategory = eventCategory {
            try encodeContainer.encode(eventCategory.rawValue, forKey: .eventCategory)
        }
        if let lookupAttributes = lookupAttributes {
            var lookupAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lookupAttributes)
            for lookupattributeslist0 in lookupAttributes {
                try lookupAttributesContainer.encode(lookupattributeslist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

extension LookupEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains a request for LookupEvents.
public struct LookupEventsInput: Swift.Equatable {
    /// Specifies that only events that occur before or at the specified time are returned. If the specified end time is before the specified start time, an error is returned.
    public var endTime: ClientRuntime.Date?
    /// Specifies the event category. If you do not specify an event category, events of the category are not returned in the response. For example, if you do not specify insight as the value of EventCategory, no Insights events are returned.
    public var eventCategory: CloudTrailClientTypes.EventCategory?
    /// Contains a list of lookup attributes. Currently the list can contain only one item.
    public var lookupAttributes: [CloudTrailClientTypes.LookupAttribute]?
    /// The number of events to return. Possible values are 1 through 50. The default is 50.
    public var maxResults: Swift.Int?
    /// The token to use to get the next page of results after a previous API call. This token must be passed in with the same parameters that were specified in the the original call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?
    /// Specifies that only events that occur after or at the specified time are returned. If the specified start time is after the specified end time, an error is returned.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        eventCategory: CloudTrailClientTypes.EventCategory? = nil,
        lookupAttributes: [CloudTrailClientTypes.LookupAttribute]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventCategory = eventCategory
        self.lookupAttributes = lookupAttributes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct LookupEventsInputBody: Swift.Equatable {
    let lookupAttributes: [CloudTrailClientTypes.LookupAttribute]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let eventCategory: CloudTrailClientTypes.EventCategory?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension LookupEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case eventCategory = "EventCategory"
        case lookupAttributes = "LookupAttributes"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lookupAttributesContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.LookupAttribute?].self, forKey: .lookupAttributes)
        var lookupAttributesDecoded0:[CloudTrailClientTypes.LookupAttribute]? = nil
        if let lookupAttributesContainer = lookupAttributesContainer {
            lookupAttributesDecoded0 = [CloudTrailClientTypes.LookupAttribute]()
            for structure0 in lookupAttributesContainer {
                if let structure0 = structure0 {
                    lookupAttributesDecoded0?.append(structure0)
                }
            }
        }
        lookupAttributes = lookupAttributesDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let eventCategoryDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventCategory.self, forKey: .eventCategory)
        eventCategory = eventCategoryDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LookupEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LookupEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEventCategory" : self = .invalidEventCategoryException(try InvalidEventCategoryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLookupAttributes" : self = .invalidLookupAttributesException(try InvalidLookupAttributesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResults" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTimeRange" : self = .invalidTimeRangeException(try InvalidTimeRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LookupEventsOutputError: Swift.Error, Swift.Equatable {
    case invalidEventCategoryException(InvalidEventCategoryException)
    case invalidLookupAttributesException(InvalidLookupAttributesException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidTimeRangeException(InvalidTimeRangeException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension LookupEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LookupEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

/// Contains a response to a LookupEvents action.
public struct LookupEventsOutputResponse: Swift.Equatable {
    /// A list of events returned based on the lookup attributes specified and the CloudTrail event. The events list is sorted by time. The most recent event is listed first.
    public var events: [CloudTrailClientTypes.Event]?
    /// The token to use to get the next page of results after a previous API call. If the token does not appear, there are no more results to return. The token must be passed in with the same parameters as the previous call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?

    public init (
        events: [CloudTrailClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct LookupEventsOutputResponseBody: Swift.Equatable {
    let events: [CloudTrailClientTypes.Event]?
    let nextToken: Swift.String?
}

extension LookupEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[CloudTrailClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [CloudTrailClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MaximumNumberOfTrailsExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MaximumNumberOfTrailsExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the maximum number of trails is reached.
public struct MaximumNumberOfTrailsExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumNumberOfTrailsExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumNumberOfTrailsExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotOrganizationMasterAccountException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotOrganizationMasterAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail is not the management account for an organization in Organizations. For more information, see [Prepare For Creating a Trail For Your Organization](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html).
public struct NotOrganizationMasterAccountException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotOrganizationMasterAccountExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotOrganizationMasterAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotPermittedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the requested operation is not permitted.
public struct OperationNotPermittedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNotInAllFeaturesModeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OrganizationNotInAllFeaturesModeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when Organizations is not configured to support all features. All features must be enabled in Organizations to support creating an organization trail. For more information, see [Prepare For Creating a Trail For Your Organization](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html).
public struct OrganizationNotInAllFeaturesModeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationNotInAllFeaturesModeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationNotInAllFeaturesModeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationsNotInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OrganizationsNotInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the request is made from an Amazon Web Services account that is not a member of an organization. To make this request, sign in using the credentials of an account that belongs to an organization.
public struct OrganizationsNotInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationsNotInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationsNotInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.PublicKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fingerprint = "Fingerprint"
        case validityEndTime = "ValidityEndTime"
        case validityStartTime = "ValidityStartTime"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fingerprint = fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
        if let validityEndTime = validityEndTime {
            try encodeContainer.encode(validityEndTime.timeIntervalSince1970, forKey: .validityEndTime)
        }
        if let validityStartTime = validityStartTime {
            try encodeContainer.encode(validityStartTime.timeIntervalSince1970, forKey: .validityStartTime)
        }
        if let value = value {
            try encodeContainer.encode(value.base64EncodedString(), forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .value)
        value = valueDecoded
        let validityStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .validityStartTime)
        validityStartTime = validityStartTimeDecoded
        let validityEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .validityEndTime)
        validityEndTime = validityEndTimeDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
    }
}

extension CloudTrailClientTypes {
    /// Contains information about a returned public key.
    public struct PublicKey: Swift.Equatable {
        /// The fingerprint of the public key.
        public var fingerprint: Swift.String?
        /// The ending time of validity of the public key.
        public var validityEndTime: ClientRuntime.Date?
        /// The starting time of validity of the public key.
        public var validityStartTime: ClientRuntime.Date?
        /// The DER encoded public key value in PKCS#1 format.
        public var value: ClientRuntime.Data?

        public init (
            fingerprint: Swift.String? = nil,
            validityEndTime: ClientRuntime.Date? = nil,
            validityStartTime: ClientRuntime.Date? = nil,
            value: ClientRuntime.Data? = nil
        )
        {
            self.fingerprint = fingerprint
            self.validityEndTime = validityEndTime
            self.validityStartTime = validityStartTime
            self.value = value
        }
    }

}

extension PutEventSelectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailName = "TrailName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedEventSelectors = advancedEventSelectors {
            var advancedEventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedEventSelectors)
            for advancedeventselectors0 in advancedEventSelectors {
                try advancedEventSelectorsContainer.encode(advancedeventselectors0)
            }
        }
        if let eventSelectors = eventSelectors {
            var eventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSelectors)
            for eventselectors0 in eventSelectors {
                try eventSelectorsContainer.encode(eventselectors0)
            }
        }
        if let trailName = trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

extension PutEventSelectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutEventSelectorsInput: Swift.Equatable {
    /// Specifies the settings for advanced event selectors. You can add advanced event selectors, and conditions for your advanced event selectors, up to a maximum of 500 values for all conditions and selectors on a trail. You can use either AdvancedEventSelectors or EventSelectors, but not both. If you apply AdvancedEventSelectors to a trail, any existing EventSelectors are overwritten. For more information about advanced event selectors, see [Logging data events for trails](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html) in the CloudTrail User Guide.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// Specifies the settings for your event selectors. You can configure up to five event selectors for a trail. You can use either EventSelectors or AdvancedEventSelectors in a PutEventSelectors request, but not both. If you apply EventSelectors to a trail, any existing AdvancedEventSelectors are overwritten.
    public var eventSelectors: [CloudTrailClientTypes.EventSelector]?
    /// Specifies the name of the trail or trail ARN. If you specify a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If you specify a trail ARN, it must be in the following format. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var trailName: Swift.String?

    public init (
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventSelectors: [CloudTrailClientTypes.EventSelector]? = nil,
        trailName: Swift.String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailName = trailName
    }
}

struct PutEventSelectorsInputBody: Swift.Equatable {
    let trailName: Swift.String?
    let eventSelectors: [CloudTrailClientTypes.EventSelector]?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
}

extension PutEventSelectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailName = "TrailName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailName)
        trailName = trailNameDecoded
        let eventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.EventSelector?].self, forKey: .eventSelectors)
        var eventSelectorsDecoded0:[CloudTrailClientTypes.EventSelector]? = nil
        if let eventSelectorsContainer = eventSelectorsContainer {
            eventSelectorsDecoded0 = [CloudTrailClientTypes.EventSelector]()
            for structure0 in eventSelectorsContainer {
                if let structure0 = structure0 {
                    eventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        eventSelectors = eventSelectorsDecoded0
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

extension PutEventSelectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEventSelectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventSelectors" : self = .invalidEventSelectorsException(try InvalidEventSelectorsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegion" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEventSelectorsOutputError: Swift.Error, Swift.Equatable {
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidEventSelectorsException(InvalidEventSelectorsException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidTrailNameException(InvalidTrailNameException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEventSelectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutEventSelectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.eventSelectors = output.eventSelectors
            self.trailARN = output.trailARN
        } else {
            self.advancedEventSelectors = nil
            self.eventSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct PutEventSelectorsOutputResponse: Swift.Equatable {
    /// Specifies the advanced event selectors configured for your trail.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// Specifies the event selectors configured for your trail.
    public var eventSelectors: [CloudTrailClientTypes.EventSelector]?
    /// Specifies the ARN of the trail that was updated with event selectors. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    public var trailARN: Swift.String?

    public init (
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventSelectors: [CloudTrailClientTypes.EventSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailARN = trailARN
    }
}

struct PutEventSelectorsOutputResponseBody: Swift.Equatable {
    let trailARN: Swift.String?
    let eventSelectors: [CloudTrailClientTypes.EventSelector]?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
}

extension PutEventSelectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let eventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.EventSelector?].self, forKey: .eventSelectors)
        var eventSelectorsDecoded0:[CloudTrailClientTypes.EventSelector]? = nil
        if let eventSelectorsContainer = eventSelectorsContainer {
            eventSelectorsDecoded0 = [CloudTrailClientTypes.EventSelector]()
            for structure0 in eventSelectorsContainer {
                if let structure0 = structure0 {
                    eventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        eventSelectors = eventSelectorsDecoded0
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

extension PutInsightSelectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailName = "TrailName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightSelectors = insightSelectors {
            var insightSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insightSelectors)
            for insightselectors0 in insightSelectors {
                try insightSelectorsContainer.encode(insightselectors0)
            }
        }
        if let trailName = trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

extension PutInsightSelectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutInsightSelectorsInput: Swift.Equatable {
    /// A JSON string that contains the Insights types that you want to log on a trail. The valid Insights type in this release is ApiCallRateInsight.
    /// This member is required.
    public var insightSelectors: [CloudTrailClientTypes.InsightSelector]?
    /// The name of the CloudTrail trail for which you want to change or add Insights selectors.
    /// This member is required.
    public var trailName: Swift.String?

    public init (
        insightSelectors: [CloudTrailClientTypes.InsightSelector]? = nil,
        trailName: Swift.String? = nil
    )
    {
        self.insightSelectors = insightSelectors
        self.trailName = trailName
    }
}

struct PutInsightSelectorsInputBody: Swift.Equatable {
    let trailName: Swift.String?
    let insightSelectors: [CloudTrailClientTypes.InsightSelector]?
}

extension PutInsightSelectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailName = "TrailName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailName)
        trailName = trailNameDecoded
        let insightSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.InsightSelector?].self, forKey: .insightSelectors)
        var insightSelectorsDecoded0:[CloudTrailClientTypes.InsightSelector]? = nil
        if let insightSelectorsContainer = insightSelectorsContainer {
            insightSelectorsDecoded0 = [CloudTrailClientTypes.InsightSelector]()
            for structure0 in insightSelectorsContainer {
                if let structure0 = structure0 {
                    insightSelectorsDecoded0?.append(structure0)
                }
            }
        }
        insightSelectors = insightSelectorsDecoded0
    }
}

extension PutInsightSelectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutInsightSelectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientEncryptionPolicy" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientS3BucketPolicy" : self = .insufficientS3BucketPolicyException(try InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegion" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInsightSelectors" : self = .invalidInsightSelectorsException(try InvalidInsightSelectorsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3BucketDoesNotExist" : self = .s3BucketDoesNotExistException(try S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutInsightSelectorsOutputError: Swift.Error, Swift.Equatable {
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case insufficientS3BucketPolicyException(InsufficientS3BucketPolicyException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidInsightSelectorsException(InvalidInsightSelectorsException)
    case invalidTrailNameException(InvalidTrailNameException)
    case kmsException(KmsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case s3BucketDoesNotExistException(S3BucketDoesNotExistException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutInsightSelectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutInsightSelectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.insightSelectors = output.insightSelectors
            self.trailARN = output.trailARN
        } else {
            self.insightSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct PutInsightSelectorsOutputResponse: Swift.Equatable {
    /// A JSON string that contains the Insights event types that you want to log on a trail. The valid Insights type in this release is ApiCallRateInsight.
    public var insightSelectors: [CloudTrailClientTypes.InsightSelector]?
    /// The Amazon Resource Name (ARN) of a trail for which you want to change or add Insights selectors.
    public var trailARN: Swift.String?

    public init (
        insightSelectors: [CloudTrailClientTypes.InsightSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.insightSelectors = insightSelectors
        self.trailARN = trailARN
    }
}

struct PutInsightSelectorsOutputResponseBody: Swift.Equatable {
    let trailARN: Swift.String?
    let insightSelectors: [CloudTrailClientTypes.InsightSelector]?
}

extension PutInsightSelectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let insightSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.InsightSelector?].self, forKey: .insightSelectors)
        var insightSelectorsDecoded0:[CloudTrailClientTypes.InsightSelector]? = nil
        if let insightSelectorsContainer = insightSelectorsContainer {
            insightSelectorsDecoded0 = [CloudTrailClientTypes.InsightSelector]()
            for structure0 in insightSelectorsContainer {
                if let structure0 = structure0 {
                    insightSelectorsDecoded0?.append(structure0)
                }
            }
        }
        insightSelectors = insightSelectorsDecoded0
    }
}

extension CloudTrailClientTypes {
    public enum ReadWriteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case readonly
        case writeonly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadWriteType] {
            return [
                .all,
                .readonly,
                .writeonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .readonly: return "ReadOnly"
            case .writeonly: return "WriteOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadWriteType(rawValue: rawValue) ?? ReadWriteType.sdkUnknown(rawValue)
        }
    }
}

extension RemoveTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tagslist0 in tagsList {
                try tagsListContainer.encode(tagslist0)
            }
        }
    }
}

extension RemoveTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies the tags to remove from a trail.
public struct RemoveTagsInput: Swift.Equatable {
    /// Specifies the ARN of the trail from which tags should be removed. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specifies a list of tags to be removed.
    public var tagsList: [CloudTrailClientTypes.Tag]?

    public init (
        resourceId: Swift.String? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagsList = tagsList
    }
}

struct RemoveTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagsList: [CloudTrailClientTypes.Tag]?
}

extension RemoveTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension RemoveTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalid" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameter" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceTypeNotSupported" : self = .resourceTypeNotSupportedException(try ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case invalidTagParameterException(InvalidTagParameterException)
    case invalidTrailNameException(InvalidTrailNameException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceTypeNotSupportedException(ResourceTypeNotSupportedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct RemoveTagsOutputResponse: Swift.Equatable {

}

extension CloudTrailClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CloudTrailClientTypes {
    /// Specifies the type and name of a resource referenced by an event.
    public struct Resource: Swift.Equatable {
        /// The name of the resource referenced by the event returned. These are user-created names whose values will depend on the environment. For example, the resource name might be "auto-scaling-test-group" for an Auto Scaling Group or "i-1234567" for an EC2 Instance.
        public var resourceName: Swift.String?
        /// The type of a resource referenced by the event returned. When the resource type cannot be determined, null is returned. Some examples of resource types are: Instance for EC2, Trail for CloudTrail, DBInstance for Amazon RDS, and AccessKey for IAM. To learn more about how to look up and filter events by the resource types supported for a service, see [Filtering CloudTrail Events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/view-cloudtrail-events-console.html#filtering-cloudtrail-events).
        public var resourceType: Swift.String?

        public init (
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified resource is not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.ResourceTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tagslist0 in tagsList {
                try tagsListContainer.encode(tagslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension CloudTrailClientTypes {
    /// A resource tag.
    public struct ResourceTag: Swift.Equatable {
        /// Specifies the ARN of the resource.
        public var resourceId: Swift.String?
        /// A list of tags.
        public var tagsList: [CloudTrailClientTypes.Tag]?

        public init (
            resourceId: Swift.String? = nil,
            tagsList: [CloudTrailClientTypes.Tag]? = nil
        )
        {
            self.resourceId = resourceId
            self.tagsList = tagsList
        }
    }

}

extension ResourceTypeNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceTypeNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified resource type is not supported by CloudTrail.
public struct ResourceTypeNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceTypeNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceTypeNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3BucketDoesNotExistException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: S3BucketDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified S3 bucket does not exist.
public struct S3BucketDoesNotExistException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct S3BucketDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension S3BucketDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartLoggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StartLoggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The request to CloudTrail to start logging Amazon Web Services API calls for an account.
public struct StartLoggingInput: Swift.Equatable {
    /// Specifies the name or the CloudTrail ARN of the trail for which CloudTrail logs Amazon Web Services API calls. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StartLoggingInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StartLoggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartLoggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartLoggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegion" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartLoggingOutputError: Swift.Error, Swift.Equatable {
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidTrailNameException(InvalidTrailNameException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartLoggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct StartLoggingOutputResponse: Swift.Equatable {

}

extension StopLoggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StopLoggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Passes the request to CloudTrail to stop logging Amazon Web Services API calls for the specified account.
public struct StopLoggingInput: Swift.Equatable {
    /// Specifies the name or the CloudTrail ARN of the trail for which CloudTrail will stop logging Amazon Web Services API calls. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StopLoggingInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StopLoggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopLoggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopLoggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegion" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopLoggingOutputError: Swift.Error, Swift.Equatable {
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidTrailNameException(InvalidTrailNameException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopLoggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct StopLoggingOutputResponse: Swift.Equatable {

}

extension CloudTrailClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudTrailClientTypes {
    /// A custom key-value pair associated with a resource such as a CloudTrail trail.
    public struct Tag: Swift.Equatable {
        /// The key in a key-value pair. The key must be must be no longer than 128 Unicode characters. The key must be unique for the resource to which it applies.
        /// This member is required.
        public var key: Swift.String?
        /// The value in a key-value pair of a tag. The value must be no longer than 256 Unicode characters.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagsLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagsLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of tags per trail has exceeded the permitted amount. Currently, the limit is 50.
public struct TagsLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagsLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagsLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.Trail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case hasCustomEventSelectors = "HasCustomEventSelectors"
        case hasInsightSelectors = "HasInsightSelectors"
        case homeRegion = "HomeRegion"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicARN = "SnsTopicARN"
        case snsTopicName = "SnsTopicName"
        case trailARN = "TrailARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let hasCustomEventSelectors = hasCustomEventSelectors {
            try encodeContainer.encode(hasCustomEventSelectors, forKey: .hasCustomEventSelectors)
        }
        if let hasInsightSelectors = hasInsightSelectors {
            try encodeContainer.encode(hasInsightSelectors, forKey: .hasInsightSelectors)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let includeGlobalServiceEvents = includeGlobalServiceEvents {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if let isMultiRegionTrail = isMultiRegionTrail {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if let isOrganizationTrail = isOrganizationTrail {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let logFileValidationEnabled = logFileValidationEnabled {
            try encodeContainer.encode(logFileValidationEnabled, forKey: .logFileValidationEnabled)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicARN = snsTopicARN {
            try encodeContainer.encode(snsTopicARN, forKey: .snsTopicARN)
        }
        if let snsTopicName = snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
        if let trailARN = trailARN {
            try encodeContainer.encode(trailARN, forKey: .trailARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let hasCustomEventSelectorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasCustomEventSelectors)
        hasCustomEventSelectors = hasCustomEventSelectorsDecoded
        let hasInsightSelectorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasInsightSelectors)
        hasInsightSelectors = hasInsightSelectorsDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

extension CloudTrailClientTypes {
    /// The settings for a trail.
    public struct Trail: Swift.Equatable {
        /// Specifies an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
        public var cloudWatchLogsRoleArn: Swift.String?
        /// Specifies if the trail has custom event selectors.
        public var hasCustomEventSelectors: Swift.Bool?
        /// Specifies whether a trail has insight types specified in an InsightSelector list.
        public var hasInsightSelectors: Swift.Bool?
        /// The region in which the trail was created.
        public var homeRegion: Swift.String?
        /// Set to True to include Amazon Web Services API calls from Amazon Web Services global services such as IAM. Otherwise, False.
        public var includeGlobalServiceEvents: Swift.Bool?
        /// Specifies whether the trail exists only in one region or exists in all regions.
        public var isMultiRegionTrail: Swift.Bool?
        /// Specifies whether the trail is an organization trail.
        public var isOrganizationTrail: Swift.Bool?
        /// Specifies the KMS key ID that encrypts the logs delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
        public var kmsKeyId: Swift.String?
        /// Specifies whether log file validation is enabled.
        public var logFileValidationEnabled: Swift.Bool?
        /// Name of the trail set by calling [CreateTrail]. The maximum length is 128 characters.
        public var name: Swift.String?
        /// Name of the Amazon S3 bucket into which CloudTrail delivers your trail files. See [Amazon S3 Bucket Naming Requirements](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create_trail_naming_policy.html).
        public var s3BucketName: Swift.String?
        /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html). The maximum length is 200 characters.
        public var s3KeyPrefix: Swift.String?
        /// Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The following is the format of a topic ARN. arn:aws:sns:us-east-2:123456789012:MyTopic
        public var snsTopicARN: Swift.String?
        /// This field is no longer in use. Use SnsTopicARN.
        @available(*, deprecated)
        public var snsTopicName: Swift.String?
        /// Specifies the ARN of the trail. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
        public var trailARN: Swift.String?

        public init (
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            cloudWatchLogsRoleArn: Swift.String? = nil,
            hasCustomEventSelectors: Swift.Bool? = nil,
            hasInsightSelectors: Swift.Bool? = nil,
            homeRegion: Swift.String? = nil,
            includeGlobalServiceEvents: Swift.Bool? = nil,
            isMultiRegionTrail: Swift.Bool? = nil,
            isOrganizationTrail: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            logFileValidationEnabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            snsTopicARN: Swift.String? = nil,
            snsTopicName: Swift.String? = nil,
            trailARN: Swift.String? = nil
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.hasCustomEventSelectors = hasCustomEventSelectors
            self.hasInsightSelectors = hasInsightSelectors
            self.homeRegion = homeRegion
            self.includeGlobalServiceEvents = includeGlobalServiceEvents
            self.isMultiRegionTrail = isMultiRegionTrail
            self.isOrganizationTrail = isOrganizationTrail
            self.kmsKeyId = kmsKeyId
            self.logFileValidationEnabled = logFileValidationEnabled
            self.name = name
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.snsTopicARN = snsTopicARN
            self.snsTopicName = snsTopicName
            self.trailARN = trailARN
        }
    }

}

extension TrailAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TrailAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the specified trail already exists.
public struct TrailAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrailAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrailAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.TrailInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegion = "HomeRegion"
        case name = "Name"
        case trailARN = "TrailARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let trailARN = trailARN {
            try encodeContainer.encode(trailARN, forKey: .trailARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
    }
}

extension CloudTrailClientTypes {
    /// Information about a CloudTrail trail, including the trail's name, home region, and Amazon Resource Name (ARN).
    public struct TrailInfo: Swift.Equatable {
        /// The Amazon Web Services Region in which a trail was created.
        public var homeRegion: Swift.String?
        /// The name of a trail.
        public var name: Swift.String?
        /// The ARN of a trail.
        public var trailARN: Swift.String?

        public init (
            homeRegion: Swift.String? = nil,
            name: Swift.String? = nil,
            trailARN: Swift.String? = nil
        )
        {
            self.homeRegion = homeRegion
            self.name = name
            self.trailARN = trailARN
        }
    }

}

extension TrailNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TrailNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the trail with the given name is not found.
public struct TrailNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrailNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrailNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrailNotProvidedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TrailNotProvidedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is no longer in use.
public struct TrailNotProvidedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrailNotProvidedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrailNotProvidedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the requested operation is not supported.
public struct UnsupportedOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Brief description of the exception returned by the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateTrailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let enableLogFileValidation = enableLogFileValidation {
            try encodeContainer.encode(enableLogFileValidation, forKey: .enableLogFileValidation)
        }
        if let includeGlobalServiceEvents = includeGlobalServiceEvents {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if let isMultiRegionTrail = isMultiRegionTrail {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if let isOrganizationTrail = isOrganizationTrail {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicName = snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
    }
}

extension UpdateTrailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies settings to update for the trail.
public struct UpdateTrailInput: Swift.Equatable {
    /// Specifies a log group name using an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs are delivered. Not required unless you specify CloudWatchLogsRoleArn.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether log file validation is enabled. The default is false. When you disable log file integrity validation, the chain of digest files is broken after one hour. CloudTrail does not create digest files for log files that were delivered during a period in which log file integrity validation was disabled. For example, if you enable log file integrity validation at noon on January 1, disable it at noon on January 2, and re-enable it at noon on January 10, digest files will not be created for the log files delivered from noon on January 2 to noon on January 10. The same applies whenever you stop CloudTrail logging or delete a trail.
    public var enableLogFileValidation: Swift.Bool?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail applies only to the current region or to all regions. The default is false. If the trail exists only in the current region and this value is set to true, shadow trails (replications of the trail) will be created in the other regions. If the trail exists in all regions and this value is set to false, the trail will remain in the region where it was created, and its shadow trails in other regions will be deleted. As a best practice, consider using trails that log events in all regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is applied to all accounts in an organization in Organizations, or only for the current Amazon Web Services account. The default is false, and cannot be true unless the call is made on behalf of an Amazon Web Services account that is the management account for an organization in Organizations. If the trail is not an organization trail and this is set to true, the trail will be created in all Amazon Web Services accounts that belong to the organization. If the trail is an organization trail and this is set to false, the trail will remain in the current Amazon Web Services account but be deleted from all member accounts in the organization.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. The value can be an alias name prefixed by "alias/", a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies the name of the trail or trail ARN. If Name is a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If Name is a trail ARN, it must be in the following format. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files. See [Amazon S3 Bucket Naming Requirements](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create_trail_naming_policy.html).
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html). The maximum length is 200 characters.
    public var s3KeyPrefix: Swift.String?
    /// Specifies the name of the Amazon SNS topic defined for notification of log file delivery. The maximum length is 256 characters.
    public var snsTopicName: Swift.String?

    public init (
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        enableLogFileValidation: Swift.Bool? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicName: Swift.String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.enableLogFileValidation = enableLogFileValidation
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicName = snsTopicName
    }
}

struct UpdateTrailInputBody: Swift.Equatable {
    let name: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let snsTopicName: Swift.String?
    let includeGlobalServiceEvents: Swift.Bool?
    let isMultiRegionTrail: Swift.Bool?
    let enableLogFileValidation: Swift.Bool?
    let cloudWatchLogsLogGroupArn: Swift.String?
    let cloudWatchLogsRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let isOrganizationTrail: Swift.Bool?
}

extension UpdateTrailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let enableLogFileValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableLogFileValidation)
        enableLogFileValidation = enableLogFileValidationDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

extension UpdateTrailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTrailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudTrailAccessNotEnabled" : self = .cloudTrailAccessNotEnabledException(try CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudTrailInvalidClientTokenId" : self = .cloudTrailInvalidClientTokenIdException(try CloudTrailInvalidClientTokenIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudWatchLogsDeliveryUnavailable" : self = .cloudWatchLogsDeliveryUnavailableException(try CloudWatchLogsDeliveryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermission" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientEncryptionPolicy" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientS3BucketPolicy" : self = .insufficientS3BucketPolicyException(try InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientSnsTopicPolicy" : self = .insufficientSnsTopicPolicyException(try InsufficientSnsTopicPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchLogsLogGroupArn" : self = .invalidCloudWatchLogsLogGroupArnException(try InvalidCloudWatchLogsLogGroupArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchLogsRoleArn" : self = .invalidCloudWatchLogsRoleArnException(try InvalidCloudWatchLogsRoleArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventSelectors" : self = .invalidEventSelectorsException(try InvalidEventSelectorsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegion" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKmsKeyId" : self = .invalidKmsKeyIdException(try InvalidKmsKeyIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationError" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketName" : self = .invalidS3BucketNameException(try InvalidS3BucketNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3Prefix" : self = .invalidS3PrefixException(try InvalidS3PrefixException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSnsTopicName" : self = .invalidSnsTopicNameException(try InvalidSnsTopicNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailName" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyDisabled" : self = .kmsKeyDisabledException(try KmsKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyNotFound" : self = .kmsKeyNotFoundException(try KmsKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccount" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesMode" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationsNotInUse" : self = .organizationsNotInUseException(try OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3BucketDoesNotExist" : self = .s3BucketDoesNotExistException(try S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFound" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotProvided" : self = .trailNotProvidedException(try TrailNotProvidedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTrailOutputError: Swift.Error, Swift.Equatable {
    case cloudTrailAccessNotEnabledException(CloudTrailAccessNotEnabledException)
    case cloudTrailInvalidClientTokenIdException(CloudTrailInvalidClientTokenIdException)
    case cloudWatchLogsDeliveryUnavailableException(CloudWatchLogsDeliveryUnavailableException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case insufficientS3BucketPolicyException(InsufficientS3BucketPolicyException)
    case insufficientSnsTopicPolicyException(InsufficientSnsTopicPolicyException)
    case invalidCloudWatchLogsLogGroupArnException(InvalidCloudWatchLogsLogGroupArnException)
    case invalidCloudWatchLogsRoleArnException(InvalidCloudWatchLogsRoleArnException)
    case invalidEventSelectorsException(InvalidEventSelectorsException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidKmsKeyIdException(InvalidKmsKeyIdException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidS3BucketNameException(InvalidS3BucketNameException)
    case invalidS3PrefixException(InvalidS3PrefixException)
    case invalidSnsTopicNameException(InvalidSnsTopicNameException)
    case invalidTrailNameException(InvalidTrailNameException)
    case kmsException(KmsException)
    case kmsKeyDisabledException(KmsKeyDisabledException)
    case kmsKeyNotFoundException(KmsKeyNotFoundException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case organizationsNotInUseException(OrganizationsNotInUseException)
    case s3BucketDoesNotExistException(S3BucketDoesNotExistException)
    case trailNotFoundException(TrailNotFoundException)
    case trailNotProvidedException(TrailNotProvidedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTrailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTrailOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchLogsLogGroupArn = output.cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = output.cloudWatchLogsRoleArn
            self.includeGlobalServiceEvents = output.includeGlobalServiceEvents
            self.isMultiRegionTrail = output.isMultiRegionTrail
            self.isOrganizationTrail = output.isOrganizationTrail
            self.kmsKeyId = output.kmsKeyId
            self.logFileValidationEnabled = output.logFileValidationEnabled
            self.name = output.name
            self.s3BucketName = output.s3BucketName
            self.s3KeyPrefix = output.s3KeyPrefix
            self.snsTopicARN = output.snsTopicARN
            self.snsTopicName = output.snsTopicName
            self.trailARN = output.trailARN
        } else {
            self.cloudWatchLogsLogGroupArn = nil
            self.cloudWatchLogsRoleArn = nil
            self.includeGlobalServiceEvents = nil
            self.isMultiRegionTrail = nil
            self.isOrganizationTrail = nil
            self.kmsKeyId = nil
            self.logFileValidationEnabled = nil
            self.name = nil
            self.s3BucketName = nil
            self.s3KeyPrefix = nil
            self.snsTopicARN = nil
            self.snsTopicName = nil
            self.trailARN = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct UpdateTrailOutputResponse: Swift.Equatable {
    /// Specifies the Amazon Resource Name (ARN) of the log group to which CloudTrail logs are delivered.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail exists in one region or in all regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is an organization trail.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID that encrypts the logs delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether log file integrity validation is enabled.
    public var logFileValidationEnabled: Swift.Bool?
    /// Specifies the name of the trail.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files.
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your IAM Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html).
    public var s3KeyPrefix: Swift.String?
    /// Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The following is the format of a topic ARN. arn:aws:sns:us-east-2:123456789012:MyTopic
    public var snsTopicARN: Swift.String?
    /// This field is no longer in use. Use [UpdateTrailResponse$SnsTopicARN].
    @available(*, deprecated)
    public var snsTopicName: Swift.String?
    /// Specifies the ARN of the trail that was updated. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    public var trailARN: Swift.String?

    public init (
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        logFileValidationEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicARN: Swift.String? = nil,
        snsTopicName: Swift.String? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.logFileValidationEnabled = logFileValidationEnabled
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicARN = snsTopicARN
        self.snsTopicName = snsTopicName
        self.trailARN = trailARN
    }
}

struct UpdateTrailOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let snsTopicName: Swift.String?
    let snsTopicARN: Swift.String?
    let includeGlobalServiceEvents: Swift.Bool?
    let isMultiRegionTrail: Swift.Bool?
    let trailARN: Swift.String?
    let logFileValidationEnabled: Swift.Bool?
    let cloudWatchLogsLogGroupArn: Swift.String?
    let cloudWatchLogsRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let isOrganizationTrail: Swift.Bool?
}

extension UpdateTrailOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicARN = "SnsTopicARN"
        case snsTopicName = "SnsTopicName"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}
