// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListDatasetGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDatasetGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDatasetGroupsOutputResponse`
extension ForecastClient {
    public func listDatasetGroupsPaginated(input: ListDatasetGroupsInput) -> ClientRuntime.PaginatorSequence<ListDatasetGroupsInput, ListDatasetGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDatasetGroupsInput, ListDatasetGroupsOutputResponse>(input: input, inputKey: \ListDatasetGroupsInput.nextToken, outputKey: \ListDatasetGroupsOutputResponse.nextToken, paginationFunction: self.listDatasetGroups(input:))
    }
}

extension ListDatasetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetGroupsInput {
        return ListDatasetGroupsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDatasetGroupsPaginated`
/// to access the nested member `[ForecastClientTypes.DatasetGroupSummary]`
/// - Returns: `[ForecastClientTypes.DatasetGroupSummary]`
extension PaginatorSequence where Input == ListDatasetGroupsInput, Output == ListDatasetGroupsOutputResponse {
    func datasetGroups() async throws -> [ForecastClientTypes.DatasetGroupSummary] {
        return try await self.asyncCompactMap { item in item.datasetGroups }
    }
}

/// Paginate over `[ListDatasetImportJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDatasetImportJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDatasetImportJobsOutputResponse`
extension ForecastClient {
    public func listDatasetImportJobsPaginated(input: ListDatasetImportJobsInput) -> ClientRuntime.PaginatorSequence<ListDatasetImportJobsInput, ListDatasetImportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDatasetImportJobsInput, ListDatasetImportJobsOutputResponse>(input: input, inputKey: \ListDatasetImportJobsInput.nextToken, outputKey: \ListDatasetImportJobsOutputResponse.nextToken, paginationFunction: self.listDatasetImportJobs(input:))
    }
}

extension ListDatasetImportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetImportJobsInput {
        return ListDatasetImportJobsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDatasetImportJobsPaginated`
/// to access the nested member `[ForecastClientTypes.DatasetImportJobSummary]`
/// - Returns: `[ForecastClientTypes.DatasetImportJobSummary]`
extension PaginatorSequence where Input == ListDatasetImportJobsInput, Output == ListDatasetImportJobsOutputResponse {
    func datasetImportJobs() async throws -> [ForecastClientTypes.DatasetImportJobSummary] {
        return try await self.asyncCompactMap { item in item.datasetImportJobs }
    }
}

/// Paginate over `[ListDatasetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDatasetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDatasetsOutputResponse`
extension ForecastClient {
    public func listDatasetsPaginated(input: ListDatasetsInput) -> ClientRuntime.PaginatorSequence<ListDatasetsInput, ListDatasetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDatasetsInput, ListDatasetsOutputResponse>(input: input, inputKey: \ListDatasetsInput.nextToken, outputKey: \ListDatasetsOutputResponse.nextToken, paginationFunction: self.listDatasets(input:))
    }
}

extension ListDatasetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetsInput {
        return ListDatasetsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDatasetsPaginated`
/// to access the nested member `[ForecastClientTypes.DatasetSummary]`
/// - Returns: `[ForecastClientTypes.DatasetSummary]`
extension PaginatorSequence where Input == ListDatasetsInput, Output == ListDatasetsOutputResponse {
    func datasets() async throws -> [ForecastClientTypes.DatasetSummary] {
        return try await self.asyncCompactMap { item in item.datasets }
    }
}

/// Paginate over `[ListForecastExportJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListForecastExportJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListForecastExportJobsOutputResponse`
extension ForecastClient {
    public func listForecastExportJobsPaginated(input: ListForecastExportJobsInput) -> ClientRuntime.PaginatorSequence<ListForecastExportJobsInput, ListForecastExportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListForecastExportJobsInput, ListForecastExportJobsOutputResponse>(input: input, inputKey: \ListForecastExportJobsInput.nextToken, outputKey: \ListForecastExportJobsOutputResponse.nextToken, paginationFunction: self.listForecastExportJobs(input:))
    }
}

extension ListForecastExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListForecastExportJobsInput {
        return ListForecastExportJobsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listForecastExportJobsPaginated`
/// to access the nested member `[ForecastClientTypes.ForecastExportJobSummary]`
/// - Returns: `[ForecastClientTypes.ForecastExportJobSummary]`
extension PaginatorSequence where Input == ListForecastExportJobsInput, Output == ListForecastExportJobsOutputResponse {
    func forecastExportJobs() async throws -> [ForecastClientTypes.ForecastExportJobSummary] {
        return try await self.asyncCompactMap { item in item.forecastExportJobs }
    }
}

/// Paginate over `[ListForecastsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListForecastsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListForecastsOutputResponse`
extension ForecastClient {
    public func listForecastsPaginated(input: ListForecastsInput) -> ClientRuntime.PaginatorSequence<ListForecastsInput, ListForecastsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListForecastsInput, ListForecastsOutputResponse>(input: input, inputKey: \ListForecastsInput.nextToken, outputKey: \ListForecastsOutputResponse.nextToken, paginationFunction: self.listForecasts(input:))
    }
}

extension ListForecastsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListForecastsInput {
        return ListForecastsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listForecastsPaginated`
/// to access the nested member `[ForecastClientTypes.ForecastSummary]`
/// - Returns: `[ForecastClientTypes.ForecastSummary]`
extension PaginatorSequence where Input == ListForecastsInput, Output == ListForecastsOutputResponse {
    func forecasts() async throws -> [ForecastClientTypes.ForecastSummary] {
        return try await self.asyncCompactMap { item in item.forecasts }
    }
}

/// Paginate over `[ListPredictorBacktestExportJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPredictorBacktestExportJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPredictorBacktestExportJobsOutputResponse`
extension ForecastClient {
    public func listPredictorBacktestExportJobsPaginated(input: ListPredictorBacktestExportJobsInput) -> ClientRuntime.PaginatorSequence<ListPredictorBacktestExportJobsInput, ListPredictorBacktestExportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPredictorBacktestExportJobsInput, ListPredictorBacktestExportJobsOutputResponse>(input: input, inputKey: \ListPredictorBacktestExportJobsInput.nextToken, outputKey: \ListPredictorBacktestExportJobsOutputResponse.nextToken, paginationFunction: self.listPredictorBacktestExportJobs(input:))
    }
}

extension ListPredictorBacktestExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPredictorBacktestExportJobsInput {
        return ListPredictorBacktestExportJobsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPredictorBacktestExportJobsPaginated`
/// to access the nested member `[ForecastClientTypes.PredictorBacktestExportJobSummary]`
/// - Returns: `[ForecastClientTypes.PredictorBacktestExportJobSummary]`
extension PaginatorSequence where Input == ListPredictorBacktestExportJobsInput, Output == ListPredictorBacktestExportJobsOutputResponse {
    func predictorBacktestExportJobs() async throws -> [ForecastClientTypes.PredictorBacktestExportJobSummary] {
        return try await self.asyncCompactMap { item in item.predictorBacktestExportJobs }
    }
}

/// Paginate over `[ListPredictorsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPredictorsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPredictorsOutputResponse`
extension ForecastClient {
    public func listPredictorsPaginated(input: ListPredictorsInput) -> ClientRuntime.PaginatorSequence<ListPredictorsInput, ListPredictorsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPredictorsInput, ListPredictorsOutputResponse>(input: input, inputKey: \ListPredictorsInput.nextToken, outputKey: \ListPredictorsOutputResponse.nextToken, paginationFunction: self.listPredictors(input:))
    }
}

extension ListPredictorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPredictorsInput {
        return ListPredictorsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPredictorsPaginated`
/// to access the nested member `[ForecastClientTypes.PredictorSummary]`
/// - Returns: `[ForecastClientTypes.PredictorSummary]`
extension PaginatorSequence where Input == ListPredictorsInput, Output == ListPredictorsOutputResponse {
    func predictors() async throws -> [ForecastClientTypes.PredictorSummary] {
        return try await self.asyncCompactMap { item in item.predictors }
    }
}
