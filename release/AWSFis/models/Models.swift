// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension FisClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case parameters
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, actionparametermap0) in parameters {
                try parametersContainer.encode(actionparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, actiontargetmap0) in targets {
                try targetsContainer.encode(actiontargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ActionParameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:FisClientTypes.ActionParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:FisClientTypes.ActionParameter]()
            for (key0, actionparameter0) in parametersContainer {
                if let actionparameter0 = actionparameter0 {
                    parametersDecoded0?[key0] = actionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ActionTarget?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.ActionTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.ActionTarget]()
            for (key0, actiontarget0) in targetsContainer {
                if let actiontarget0 = actiontarget0 {
                    targetsDecoded0?[key0] = actiontarget0
                }
            }
        }
        targets = targetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes {
    /// Describes an action. For more information, see [AWS FIS actions](https://docs.aws.amazon.com/fis/latest/userguide/fis-actions-reference.html) in the AWS Fault Injection Simulator User Guide.
    public struct Action: Swift.Equatable {
        /// The description for the action.
        public var description: Swift.String?
        /// The ID of the action.
        public var id: Swift.String?
        /// The action parameters, if applicable.
        public var parameters: [Swift.String:FisClientTypes.ActionParameter]?
        /// The tags for the action.
        public var tags: [Swift.String:Swift.String]?
        /// The supported targets for the action.
        public var targets: [Swift.String:FisClientTypes.ActionTarget]?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            parameters: [Swift.String:FisClientTypes.ActionParameter]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ActionTarget]? = nil
        )
        {
            self.description = description
            self.id = id
            self.parameters = parameters
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ActionParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if `required` != false {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let requiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension FisClientTypes {
    /// Describes a parameter for an action.
    public struct ActionParameter: Swift.Equatable {
        /// The parameter description.
        public var description: Swift.String?
        /// Indicates whether the parameter is required.
        public var `required`: Swift.Bool

        public init (
            description: Swift.String? = nil,
            `required`: Swift.Bool = false
        )
        {
            self.description = description
            self.`required` = `required`
        }
    }

}

extension FisClientTypes.ActionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, actiontargetmap0) in targets {
                try targetsContainer.encode(actiontargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ActionTarget?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.ActionTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.ActionTarget]()
            for (key0, actiontarget0) in targetsContainer {
                if let actiontarget0 = actiontarget0 {
                    targetsDecoded0?[key0] = actiontarget0
                }
            }
        }
        targets = targetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes {
    /// Provides a summary of an action.
    public struct ActionSummary: Swift.Equatable {
        /// The description for the action.
        public var description: Swift.String?
        /// The ID of the action.
        public var id: Swift.String?
        /// The tags for the action.
        public var tags: [Swift.String:Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:FisClientTypes.ActionTarget]?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ActionTarget]? = nil
        )
        {
            self.description = description
            self.id = id
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ActionTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension FisClientTypes {
    /// Describes a target for an action.
    public struct ActionTarget: Swift.Equatable {
        /// The resource type of the target.
        public var resourceType: Swift.String?

        public init (
            resourceType: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of a conflict.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FisClientTypes.CreateExperimentTemplateActionInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimenttemplateactionparametermap0) in parameters {
                try parametersContainer.encode(experimenttemplateactionparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimenttemplateactionstartafterlist0 in startAfter {
                try startAfterContainer.encode(experimenttemplateactionstartafterlist0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimenttemplateactiontargetmap0) in targets {
                try targetsContainer.encode(experimenttemplateactiontargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplateactionparameter0) in parametersContainer {
                if let experimenttemplateactionparameter0 = experimenttemplateactionparameter0 {
                    parametersDecoded0?[key0] = experimenttemplateactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplatetargetname0) in targetsContainer {
                if let experimenttemplatetargetname0 = experimenttemplatetargetname0 {
                    targetsDecoded0?[key0] = experimenttemplatetargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startAfter)
        var startAfterDecoded0:[Swift.String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [Swift.String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
    }
}

extension FisClientTypes {
    /// Specifies an action for an experiment template.
    public struct CreateExperimentTemplateActionInput: Swift.Equatable {
        /// The ID of the action.
        /// This member is required.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action, if applicable.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init (
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }

}

extension CreateExperimentTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case clientToken
        case description
        case roleArn
        case stopConditions
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, createexperimenttemplateactioninputmap0) in actions {
                try actionsContainer.encode(createexperimenttemplateactioninputmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for createexperimenttemplatestopconditioninputlist0 in stopConditions {
                try stopConditionsContainer.encode(createexperimenttemplatestopconditioninputlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, createexperimenttemplatetargetinputmap0) in targets {
                try targetsContainer.encode(createexperimenttemplatetargetinputmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateExperimentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/experimentTemplates"
    }
}

public struct CreateExperimentTemplateInput: Swift.Equatable {
    /// The actions for the experiment.
    /// This member is required.
    public var actions: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A description for the experiment template. Can contain up to 64 letters (A-Z and a-z).
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that grants the AWS FIS service permission to perform service actions on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The stop conditions.
    /// This member is required.
    public var stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]?
    /// The tags to apply to the experiment template.
    public var tags: [Swift.String:Swift.String]?
    /// The targets for the experiment.
    public var targets: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]?

    public init (
        actions: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targets: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]? = nil
    )
    {
        self.actions = actions
        self.clientToken = clientToken
        self.description = description
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.tags = tags
        self.targets = targets
    }
}

struct CreateExperimentTemplateInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let description: Swift.String?
    let stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]?
    let targets: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]?
    let actions: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateExperimentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case clientToken
        case description
        case roleArn
        case stopConditions
        case tags
        case targets
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stopConditionsContainer = try containerValues.decodeIfPresent([FisClientTypes.CreateExperimentTemplateStopConditionInput?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[FisClientTypes.CreateExperimentTemplateStopConditionInput]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [FisClientTypes.CreateExperimentTemplateStopConditionInput]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.CreateExperimentTemplateTargetInput?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]()
            for (key0, createexperimenttemplatetargetinput0) in targetsContainer {
                if let createexperimenttemplatetargetinput0 = createexperimenttemplatetargetinput0 {
                    targetsDecoded0?[key0] = createexperimenttemplatetargetinput0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.CreateExperimentTemplateActionInput?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]()
            for (key0, createexperimenttemplateactioninput0) in actionsContainer {
                if let createexperimenttemplateactioninput0 = createexperimenttemplateactioninput0 {
                    actionsDecoded0?[key0] = createexperimenttemplateactioninput0
                }
            }
        }
        actions = actionsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateExperimentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateExperimentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateExperimentTemplateOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateExperimentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateExperimentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct CreateExperimentTemplateOutputResponse: Swift.Equatable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init (
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct CreateExperimentTemplateOutputResponseBody: Swift.Equatable {
    let experimentTemplate: FisClientTypes.ExperimentTemplate?
}

extension CreateExperimentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

extension FisClientTypes.CreateExperimentTemplateStopConditionInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FisClientTypes {
    /// Specifies a stop condition for an experiment template.
    public struct CreateExperimentTemplateStopConditionInput: Swift.Equatable {
        /// The source for the stop condition. Specify aws:cloudwatch:alarm if the stop condition is defined by a CloudWatch alarm. Specify none if there is no stop condition.
        /// This member is required.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm. This is required if the source is a CloudWatch alarm.
        public var value: Swift.String?

        public init (
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.CreateExperimentTemplateTargetInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttemplatetargetfilterinputlist0 in filters {
                try filtersContainer.encode(experimenttemplatetargetfilterinputlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, tagmap0) in resourceTags {
                try resourceTagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateTargetInputFilter?].self, forKey: .filters)
        var filtersDecoded0:[FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FisClientTypes.ExperimentTemplateTargetInputFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
    }
}

extension FisClientTypes {
    /// Specifies a target for an experiment. You must specify at least one Amazon Resource Name (ARN) or at least one resource tag. You cannot specify both ARNs and tags.
    public struct CreateExperimentTemplateTargetInput: Swift.Equatable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]?
        /// The Amazon Resource Names (ARNs) of the resources.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The AWS resource type. The resource type must be supported for the specified action.
        /// This member is required.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count of the resources at random, or a percentage of the resources. All identified resources are included in the target.
        ///
        /// * ALL - Run the action on all identified targets. This is the default.
        ///
        /// * COUNT(n) - Run the action on the specified number of targets, chosen from the identified targets at random. For example, COUNT(1) selects one of the targets.
        ///
        /// * PERCENT(n) - Run the action on the specified percentage of targets, chosen from the identified targets at random. For example, PERCENT(25) selects 25% of the targets.
        /// This member is required.
        public var selectionMode: Swift.String?

        public init (
            filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension DeleteExperimentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/experimentTemplates/\(id.urlPercentEncoding())"
    }
}

public struct DeleteExperimentTemplateInput: Swift.Equatable {
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteExperimentTemplateInputBody: Swift.Equatable {
}

extension DeleteExperimentTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteExperimentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteExperimentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteExperimentTemplateOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExperimentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteExperimentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct DeleteExperimentTemplateOutputResponse: Swift.Equatable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init (
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct DeleteExperimentTemplateOutputResponseBody: Swift.Equatable {
    let experimentTemplate: FisClientTypes.ExperimentTemplate?
}

extension DeleteExperimentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

extension FisClientTypes.Experiment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case creationTime
        case endTime
        case experimentTemplateId
        case id
        case roleArn
        case startTime
        case state
        case stopConditions
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, experimentactionmap0) in actions {
                try actionsContainer.encode(experimentactionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let experimentTemplateId = experimentTemplateId {
            try encodeContainer.encode(experimentTemplateId, forKey: .experimentTemplateId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for experimentstopconditionlist0 in stopConditions {
                try stopConditionsContainer.encode(experimentstopconditionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimenttargetmap0) in targets {
                try targetsContainer.encode(experimenttargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let experimentTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .experimentTemplateId)
        experimentTemplateId = experimentTemplateIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentState.self, forKey: .state)
        state = stateDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ExperimentTarget?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.ExperimentTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.ExperimentTarget]()
            for (key0, experimenttarget0) in targetsContainer {
                if let experimenttarget0 = experimenttarget0 {
                    targetsDecoded0?[key0] = experimenttarget0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ExperimentAction?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:FisClientTypes.ExperimentAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:FisClientTypes.ExperimentAction]()
            for (key0, experimentaction0) in actionsContainer {
                if let experimentaction0 = experimentaction0 {
                    actionsDecoded0?[key0] = experimentaction0
                }
            }
        }
        actions = actionsDecoded0
        let stopConditionsContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentStopCondition?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[FisClientTypes.ExperimentStopCondition]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [FisClientTypes.ExperimentStopCondition]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes {
    /// Describes an experiment.
    public struct Experiment: Swift.Equatable {
        /// The actions for the experiment.
        public var actions: [Swift.String:FisClientTypes.ExperimentAction]?
        /// The time the experiment was created.
        public var creationTime: ClientRuntime.Date?
        /// The time that the experiment ended.
        public var endTime: ClientRuntime.Date?
        /// The ID of the experiment template.
        public var experimentTemplateId: Swift.String?
        /// The ID of the experiment.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role that grants the AWS FIS service permission to perform service actions on your behalf.
        public var roleArn: Swift.String?
        /// The time that the experiment was started.
        public var startTime: ClientRuntime.Date?
        /// The state of the experiment.
        public var state: FisClientTypes.ExperimentState?
        /// The stop conditions for the experiment.
        public var stopConditions: [FisClientTypes.ExperimentStopCondition]?
        /// The tags for the experiment.
        public var tags: [Swift.String:Swift.String]?
        /// The targets for the experiment.
        public var targets: [Swift.String:FisClientTypes.ExperimentTarget]?

        public init (
            actions: [Swift.String:FisClientTypes.ExperimentAction]? = nil,
            creationTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            experimentTemplateId: Swift.String? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: FisClientTypes.ExperimentState? = nil,
            stopConditions: [FisClientTypes.ExperimentStopCondition]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ExperimentTarget]? = nil
        )
        {
            self.actions = actions
            self.creationTime = creationTime
            self.endTime = endTime
            self.experimentTemplateId = experimentTemplateId
            self.id = id
            self.roleArn = roleArn
            self.startTime = startTime
            self.state = state
            self.stopConditions = stopConditions
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case state
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimentactionparametermap0) in parameters {
                try parametersContainer.encode(experimentactionparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimentactionstartafterlist0 in startAfter {
                try startAfterContainer.encode(experimentactionstartafterlist0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimentactiontargetmap0) in targets {
                try targetsContainer.encode(experimentactiontargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimentactionparameter0) in parametersContainer {
                if let experimentactionparameter0 = experimentactionparameter0 {
                    parametersDecoded0?[key0] = experimentactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttargetname0) in targetsContainer {
                if let experimenttargetname0 = experimenttargetname0 {
                    targetsDecoded0?[key0] = experimenttargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startAfter)
        var startAfterDecoded0:[Swift.String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [Swift.String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentActionState.self, forKey: .state)
        state = stateDecoded
    }
}

extension FisClientTypes {
    /// Describes the action for an experiment.
    public struct ExperimentAction: Swift.Equatable {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// The description for the action.
        public var description: Swift.String?
        /// The parameters for the action.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before this action starts.
        public var startAfter: [Swift.String]?
        /// The state of the action.
        public var state: FisClientTypes.ExperimentActionState?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init (
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            state: FisClientTypes.ExperimentActionState? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.state = state
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentActionState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentActionStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension FisClientTypes {
    /// Describes the state of an action.
    public struct ExperimentActionState: Swift.Equatable {
        /// The reason for the state.
        public var reason: Swift.String?
        /// The state of the action.
        public var status: FisClientTypes.ExperimentActionStatus?

        public init (
            reason: Swift.String? = nil,
            status: FisClientTypes.ExperimentActionStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension FisClientTypes {
    public enum ExperimentActionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case initiating
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentActionStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .initiating,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "cancelled"
            case .completed: return "completed"
            case .failed: return "failed"
            case .initiating: return "initiating"
            case .pending: return "pending"
            case .running: return "running"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentActionStatus(rawValue: rawValue) ?? ExperimentActionStatus.sdkUnknown(rawValue)
        }
    }
}

extension FisClientTypes.ExperimentState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension FisClientTypes {
    /// Describes the state of an experiment.
    public struct ExperimentState: Swift.Equatable {
        /// The reason for the state.
        public var reason: Swift.String?
        /// The state of the experiment.
        public var status: FisClientTypes.ExperimentStatus?

        public init (
            reason: Swift.String? = nil,
            status: FisClientTypes.ExperimentStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension FisClientTypes {
    public enum ExperimentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case initiating
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentStatus] {
            return [
                .completed,
                .failed,
                .initiating,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "completed"
            case .failed: return "failed"
            case .initiating: return "initiating"
            case .pending: return "pending"
            case .running: return "running"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentStatus(rawValue: rawValue) ?? ExperimentStatus.sdkUnknown(rawValue)
        }
    }
}

extension FisClientTypes.ExperimentStopCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FisClientTypes {
    /// Describes the stop condition for an experiment.
    public struct ExperimentStopCondition: Swift.Equatable {
        /// The source for the stop condition.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.
        public var value: Swift.String?

        public init (
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.ExperimentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case experimentTemplateId
        case id
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let experimentTemplateId = experimentTemplateId {
            try encodeContainer.encode(experimentTemplateId, forKey: .experimentTemplateId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let experimentTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .experimentTemplateId)
        experimentTemplateId = experimentTemplateIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentState.self, forKey: .state)
        state = stateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes {
    /// Provides a summary of an experiment.
    public struct ExperimentSummary: Swift.Equatable {
        /// The time that the experiment was created.
        public var creationTime: ClientRuntime.Date?
        /// The ID of the experiment template.
        public var experimentTemplateId: Swift.String?
        /// The ID of the experiment.
        public var id: Swift.String?
        /// The state of the experiment.
        public var state: FisClientTypes.ExperimentState?
        /// The tags for the experiment.
        public var tags: [Swift.String:Swift.String]?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            experimentTemplateId: Swift.String? = nil,
            id: Swift.String? = nil,
            state: FisClientTypes.ExperimentState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.creationTime = creationTime
            self.experimentTemplateId = experimentTemplateId
            self.id = id
            self.state = state
            self.tags = tags
        }
    }

}

extension FisClientTypes.ExperimentTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttargetfilterlist0 in filters {
                try filtersContainer.encode(experimenttargetfilterlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, tagmap0) in resourceTags {
                try resourceTagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTargetFilter?].self, forKey: .filters)
        var filtersDecoded0:[FisClientTypes.ExperimentTargetFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FisClientTypes.ExperimentTargetFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
    }
}

extension FisClientTypes {
    /// Describes a target for an experiment.
    public struct ExperimentTarget: Swift.Equatable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTargetFilter]?
        /// The Amazon Resource Names (ARNs) of the resources.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The resource type.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        public var selectionMode: Swift.String?

        public init (
            filters: [FisClientTypes.ExperimentTargetFilter]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension FisClientTypes.ExperimentTargetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for experimenttargetfiltervalues0 in values {
                try valuesContainer.encode(experimenttargetfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension FisClientTypes {
    /// Describes a filter used for the target resources in an experiment.
    public struct ExperimentTargetFilter: Swift.Equatable {
        /// The attribute path for the filter.
        public var path: Swift.String?
        /// The attribute values for the filter.
        public var values: [Swift.String]?

        public init (
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }

}

extension FisClientTypes.ExperimentTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case creationTime
        case description
        case id
        case lastUpdateTime
        case roleArn
        case stopConditions
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, experimenttemplateactionmap0) in actions {
                try actionsContainer.encode(experimenttemplateactionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for experimenttemplatestopconditionlist0 in stopConditions {
                try stopConditionsContainer.encode(experimenttemplatestopconditionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimenttemplatetargetmap0) in targets {
                try targetsContainer.encode(experimenttemplatetargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ExperimentTemplateTarget?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.ExperimentTemplateTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.ExperimentTemplateTarget]()
            for (key0, experimenttemplatetarget0) in targetsContainer {
                if let experimenttemplatetarget0 = experimenttemplatetarget0 {
                    targetsDecoded0?[key0] = experimenttemplatetarget0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ExperimentTemplateAction?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:FisClientTypes.ExperimentTemplateAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:FisClientTypes.ExperimentTemplateAction]()
            for (key0, experimenttemplateaction0) in actionsContainer {
                if let experimenttemplateaction0 = experimenttemplateaction0 {
                    actionsDecoded0?[key0] = experimenttemplateaction0
                }
            }
        }
        actions = actionsDecoded0
        let stopConditionsContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateStopCondition?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[FisClientTypes.ExperimentTemplateStopCondition]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [FisClientTypes.ExperimentTemplateStopCondition]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes {
    /// Describes an experiment template.
    public struct ExperimentTemplate: Swift.Equatable {
        /// The actions for the experiment.
        public var actions: [Swift.String:FisClientTypes.ExperimentTemplateAction]?
        /// The time the experiment template was created.
        public var creationTime: ClientRuntime.Date?
        /// The description for the experiment template.
        public var description: Swift.String?
        /// The ID of the experiment template.
        public var id: Swift.String?
        /// The time the experiment template was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of an IAM role.
        public var roleArn: Swift.String?
        /// The stop conditions for the experiment.
        public var stopConditions: [FisClientTypes.ExperimentTemplateStopCondition]?
        /// The tags for the experiment template.
        public var tags: [Swift.String:Swift.String]?
        /// The targets for the experiment.
        public var targets: [Swift.String:FisClientTypes.ExperimentTemplateTarget]?

        public init (
            actions: [Swift.String:FisClientTypes.ExperimentTemplateAction]? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            stopConditions: [FisClientTypes.ExperimentTemplateStopCondition]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ExperimentTemplateTarget]? = nil
        )
        {
            self.actions = actions
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.stopConditions = stopConditions
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentTemplateAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimenttemplateactionparametermap0) in parameters {
                try parametersContainer.encode(experimenttemplateactionparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimenttemplateactionstartafterlist0 in startAfter {
                try startAfterContainer.encode(experimenttemplateactionstartafterlist0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimenttemplateactiontargetmap0) in targets {
                try targetsContainer.encode(experimenttemplateactiontargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplateactionparameter0) in parametersContainer {
                if let experimenttemplateactionparameter0 = experimenttemplateactionparameter0 {
                    parametersDecoded0?[key0] = experimenttemplateactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplatetargetname0) in targetsContainer {
                if let experimenttemplatetargetname0 = experimenttemplatetargetname0 {
                    targetsDecoded0?[key0] = experimenttemplatetargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startAfter)
        var startAfterDecoded0:[Swift.String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [Swift.String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
    }
}

extension FisClientTypes {
    /// Describes an action for an experiment template.
    public struct ExperimentTemplateAction: Swift.Equatable {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before the current action starts.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init (
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentTemplateStopCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FisClientTypes {
    /// Describes a stop condition for an experiment template.
    public struct ExperimentTemplateStopCondition: Swift.Equatable {
        /// The source for the stop condition.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.
        public var value: Swift.String?

        public init (
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.ExperimentTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case lastUpdateTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes {
    /// Provides a summary of an experiment template.
    public struct ExperimentTemplateSummary: Swift.Equatable {
        /// The time that the experiment template was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the experiment template.
        public var description: Swift.String?
        /// The ID of the experiment template.
        public var id: Swift.String?
        /// The time that the experiment template was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The tags for the experiment template.
        public var tags: [Swift.String:Swift.String]?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.tags = tags
        }
    }

}

extension FisClientTypes.ExperimentTemplateTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttemplatetargetfilterlist0 in filters {
                try filtersContainer.encode(experimenttemplatetargetfilterlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, tagmap0) in resourceTags {
                try resourceTagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateTargetFilter?].self, forKey: .filters)
        var filtersDecoded0:[FisClientTypes.ExperimentTemplateTargetFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FisClientTypes.ExperimentTemplateTargetFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
    }
}

extension FisClientTypes {
    /// Describes a target for an experiment template.
    public struct ExperimentTemplateTarget: Swift.Equatable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetFilter]?
        /// The Amazon Resource Names (ARNs) of the targets.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The resource type.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        public var selectionMode: Swift.String?

        public init (
            filters: [FisClientTypes.ExperimentTemplateTargetFilter]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension FisClientTypes.ExperimentTemplateTargetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for experimenttemplatetargetfiltervalues0 in values {
                try valuesContainer.encode(experimenttemplatetargetfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension FisClientTypes {
    /// Describes a filter used for the target resources in an experiment template.
    public struct ExperimentTemplateTargetFilter: Swift.Equatable {
        /// The attribute path for the filter.
        public var path: Swift.String?
        /// The attribute values for the filter.
        public var values: [Swift.String]?

        public init (
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }

}

extension FisClientTypes.ExperimentTemplateTargetInputFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for experimenttemplatetargetfiltervalues0 in values {
                try valuesContainer.encode(experimenttemplatetargetfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension FisClientTypes {
    /// Describes a filter used for the target resource input in an experiment template.
    public struct ExperimentTemplateTargetInputFilter: Swift.Equatable {
        /// The attribute path for the filter.
        /// This member is required.
        public var path: Swift.String?
        /// The attribute values for the filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }

}

extension GetActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/actions/\(id.urlPercentEncoding())"
    }
}

public struct GetActionInput: Swift.Equatable {
    /// The ID of the action.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetActionInputBody: Swift.Equatable {
}

extension GetActionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetActionOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
        } else {
            self.action = nil
        }
    }
}

public struct GetActionOutputResponse: Swift.Equatable {
    /// Information about the action.
    public var action: FisClientTypes.Action?

    public init (
        action: FisClientTypes.Action? = nil
    )
    {
        self.action = action
    }
}

struct GetActionOutputResponseBody: Swift.Equatable {
    let action: FisClientTypes.Action?
}

extension GetActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(FisClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

extension GetExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/experiments/\(id.urlPercentEncoding())"
    }
}

public struct GetExperimentInput: Swift.Equatable {
    /// The ID of the experiment.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetExperimentInputBody: Swift.Equatable {
}

extension GetExperimentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetExperimentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExperimentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExperimentOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExperimentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct GetExperimentOutputResponse: Swift.Equatable {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init (
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct GetExperimentOutputResponseBody: Swift.Equatable {
    let experiment: FisClientTypes.Experiment?
}

extension GetExperimentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(FisClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

extension GetExperimentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/experimentTemplates/\(id.urlPercentEncoding())"
    }
}

public struct GetExperimentTemplateInput: Swift.Equatable {
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetExperimentTemplateInputBody: Swift.Equatable {
}

extension GetExperimentTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetExperimentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExperimentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExperimentTemplateOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExperimentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetExperimentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct GetExperimentTemplateOutputResponse: Swift.Equatable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init (
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct GetExperimentTemplateOutputResponseBody: Swift.Equatable {
    let experimentTemplate: FisClientTypes.ExperimentTemplate?
}

extension GetExperimentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

extension ListActionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListActionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/actions"
    }
}

public struct ListActionsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListActionsInputBody: Swift.Equatable {
}

extension ListActionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListActionsOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct ListActionsOutputResponse: Swift.Equatable {
    /// The actions.
    public var actions: [FisClientTypes.ActionSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        actions: [FisClientTypes.ActionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct ListActionsOutputResponseBody: Swift.Equatable {
    let actions: [FisClientTypes.ActionSummary]?
    let nextToken: Swift.String?
}

extension ListActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([FisClientTypes.ActionSummary?].self, forKey: .actions)
        var actionsDecoded0:[FisClientTypes.ActionSummary]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [FisClientTypes.ActionSummary]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExperimentTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListExperimentTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/experimentTemplates"
    }
}

public struct ListExperimentTemplatesInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExperimentTemplatesInputBody: Swift.Equatable {
}

extension ListExperimentTemplatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListExperimentTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExperimentTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExperimentTemplatesOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExperimentTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListExperimentTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplates = output.experimentTemplates
            self.nextToken = output.nextToken
        } else {
            self.experimentTemplates = nil
            self.nextToken = nil
        }
    }
}

public struct ListExperimentTemplatesOutputResponse: Swift.Equatable {
    /// The experiment templates.
    public var experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experimentTemplates = experimentTemplates
        self.nextToken = nextToken
    }
}

struct ListExperimentTemplatesOutputResponseBody: Swift.Equatable {
    let experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]?
    let nextToken: Swift.String?
}

extension ListExperimentTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplates
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplatesContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateSummary?].self, forKey: .experimentTemplates)
        var experimentTemplatesDecoded0:[FisClientTypes.ExperimentTemplateSummary]? = nil
        if let experimentTemplatesContainer = experimentTemplatesContainer {
            experimentTemplatesDecoded0 = [FisClientTypes.ExperimentTemplateSummary]()
            for structure0 in experimentTemplatesContainer {
                if let structure0 = structure0 {
                    experimentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        experimentTemplates = experimentTemplatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExperimentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListExperimentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/experiments"
    }
}

public struct ListExperimentsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExperimentsInputBody: Swift.Equatable {
}

extension ListExperimentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListExperimentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExperimentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExperimentsOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExperimentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListExperimentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiments = output.experiments
            self.nextToken = output.nextToken
        } else {
            self.experiments = nil
            self.nextToken = nil
        }
    }
}

public struct ListExperimentsOutputResponse: Swift.Equatable {
    /// The experiments.
    public var experiments: [FisClientTypes.ExperimentSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        experiments: [FisClientTypes.ExperimentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experiments = experiments
        self.nextToken = nextToken
    }
}

struct ListExperimentsOutputResponseBody: Swift.Equatable {
    let experiments: [FisClientTypes.ExperimentSummary]?
    let nextToken: Swift.String?
}

extension ListExperimentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiments
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentsContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentSummary?].self, forKey: .experiments)
        var experimentsDecoded0:[FisClientTypes.ExperimentSummary]? = nil
        if let experimentsContainer = experimentsContainer {
            experimentsDecoded0 = [FisClientTypes.ExperimentSummary]()
            for structure0 in experimentsContainer {
                if let structure0 = structure0 {
                    experimentsDecoded0?.append(structure0)
                }
            }
        }
        experiments = experimentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource cannot be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded your service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartExperimentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case experimentTemplateId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let experimentTemplateId = experimentTemplateId {
            try encodeContainer.encode(experimentTemplateId, forKey: .experimentTemplateId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/experiments"
    }
}

public struct StartExperimentInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?
    /// The tags to apply to the experiment.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        experimentTemplateId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.experimentTemplateId = experimentTemplateId
        self.tags = tags
    }
}

struct StartExperimentInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let experimentTemplateId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartExperimentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case experimentTemplateId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let experimentTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .experimentTemplateId)
        experimentTemplateId = experimentTemplateIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartExperimentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartExperimentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartExperimentOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartExperimentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct StartExperimentOutputResponse: Swift.Equatable {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init (
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct StartExperimentOutputResponseBody: Swift.Equatable {
    let experiment: FisClientTypes.Experiment?
}

extension StartExperimentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(FisClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

extension StopExperimentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/experiments/\(id.urlPercentEncoding())"
    }
}

public struct StopExperimentInput: Swift.Equatable {
    /// The ID of the experiment.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StopExperimentInputBody: Swift.Equatable {
}

extension StopExperimentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopExperimentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopExperimentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopExperimentOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopExperimentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct StopExperimentOutputResponse: Swift.Equatable {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init (
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct StopExperimentOutputResponseBody: Swift.Equatable {
    let experiment: FisClientTypes.Experiment?
}

extension StopExperimentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(FisClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension FisClientTypes.UpdateExperimentTemplateActionInputItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimenttemplateactionparametermap0) in parameters {
                try parametersContainer.encode(experimenttemplateactionparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimenttemplateactionstartafterlist0 in startAfter {
                try startAfterContainer.encode(experimenttemplateactionstartafterlist0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimenttemplateactiontargetmap0) in targets {
                try targetsContainer.encode(experimenttemplateactiontargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplateactionparameter0) in parametersContainer {
                if let experimenttemplateactionparameter0 = experimenttemplateactionparameter0 {
                    parametersDecoded0?[key0] = experimenttemplateactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplatetargetname0) in targetsContainer {
                if let experimenttemplatetargetname0 = experimenttemplatetargetname0 {
                    targetsDecoded0?[key0] = experimenttemplatetargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startAfter)
        var startAfterDecoded0:[Swift.String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [Swift.String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
    }
}

extension FisClientTypes {
    /// Specifies an action for an experiment template.
    public struct UpdateExperimentTemplateActionInputItem: Swift.Equatable {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action, if applicable.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init (
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }

}

extension UpdateExperimentTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case description
        case roleArn
        case stopConditions
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, updateexperimenttemplateactioninputmap0) in actions {
                try actionsContainer.encode(updateexperimenttemplateactioninputmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for updateexperimenttemplatestopconditioninputlist0 in stopConditions {
                try stopConditionsContainer.encode(updateexperimenttemplatestopconditioninputlist0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, updateexperimenttemplatetargetinputmap0) in targets {
                try targetsContainer.encode(updateexperimenttemplatetargetinputmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateExperimentTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/experimentTemplates/\(id.urlPercentEncoding())"
    }
}

public struct UpdateExperimentTemplateInput: Swift.Equatable {
    /// The actions for the experiment.
    public var actions: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]?
    /// A description for the template.
    public var description: Swift.String?
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that grants the AWS FIS service permission to perform service actions on your behalf.
    public var roleArn: Swift.String?
    /// The stop conditions for the experiment.
    public var stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]?
    /// The targets for the experiment.
    public var targets: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]?

    public init (
        actions: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]? = nil,
        targets: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.id = id
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.targets = targets
    }
}

struct UpdateExperimentTemplateInputBody: Swift.Equatable {
    let description: Swift.String?
    let stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]?
    let targets: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]?
    let actions: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]?
    let roleArn: Swift.String?
}

extension UpdateExperimentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case description
        case roleArn
        case stopConditions
        case targets
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stopConditionsContainer = try containerValues.decodeIfPresent([FisClientTypes.UpdateExperimentTemplateStopConditionInput?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[FisClientTypes.UpdateExperimentTemplateStopConditionInput]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [FisClientTypes.UpdateExperimentTemplateStopConditionInput]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.UpdateExperimentTemplateTargetInput?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]()
            for (key0, updateexperimenttemplatetargetinput0) in targetsContainer {
                if let updateexperimenttemplatetargetinput0 = updateexperimenttemplatetargetinput0 {
                    targetsDecoded0?[key0] = updateexperimenttemplatetargetinput0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.UpdateExperimentTemplateActionInputItem?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]()
            for (key0, updateexperimenttemplateactioninputitem0) in actionsContainer {
                if let updateexperimenttemplateactioninputitem0 = updateexperimenttemplateactioninputitem0 {
                    actionsDecoded0?[key0] = updateexperimenttemplateactioninputitem0
                }
            }
        }
        actions = actionsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateExperimentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateExperimentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateExperimentTemplateOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateExperimentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateExperimentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct UpdateExperimentTemplateOutputResponse: Swift.Equatable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init (
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct UpdateExperimentTemplateOutputResponseBody: Swift.Equatable {
    let experimentTemplate: FisClientTypes.ExperimentTemplate?
}

extension UpdateExperimentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

extension FisClientTypes.UpdateExperimentTemplateStopConditionInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FisClientTypes {
    /// Specifies a stop condition for an experiment. You can define a stop condition as a CloudWatch alarm.
    public struct UpdateExperimentTemplateStopConditionInput: Swift.Equatable {
        /// The source for the stop condition. Specify aws:cloudwatch:alarm if the stop condition is defined by a CloudWatch alarm. Specify none if there is no stop condition.
        /// This member is required.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm.
        public var value: Swift.String?

        public init (
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.UpdateExperimentTemplateTargetInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttemplatetargetfilterinputlist0 in filters {
                try filtersContainer.encode(experimenttemplatetargetfilterinputlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, tagmap0) in resourceTags {
                try resourceTagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateTargetInputFilter?].self, forKey: .filters)
        var filtersDecoded0:[FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FisClientTypes.ExperimentTemplateTargetInputFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
    }
}

extension FisClientTypes {
    /// Specifies a target for an experiment. You must specify at least one Amazon Resource Name (ARN) or at least one resource tag. You cannot specify both.
    public struct UpdateExperimentTemplateTargetInput: Swift.Equatable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]?
        /// The Amazon Resource Names (ARNs) of the targets.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The AWS resource type. The resource type must be supported for the specified action.
        /// This member is required.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        /// This member is required.
        public var selectionMode: Swift.String?

        public init (
            filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified input is not valid, or fails to satisfy the constraints for the request.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
