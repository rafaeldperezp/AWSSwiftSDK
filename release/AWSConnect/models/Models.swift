// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.AgentInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectedToAgentTimestamp = "ConnectedToAgentTimestamp"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedToAgentTimestamp = connectedToAgentTimestamp {
            try encodeContainer.encode(connectedToAgentTimestamp.timeIntervalSince1970, forKey: .connectedToAgentTimestamp)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let connectedToAgentTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .connectedToAgentTimestamp)
        connectedToAgentTimestamp = connectedToAgentTimestampDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the agent who accepted the contact.
    public struct AgentInfo: Swift.Equatable {
        /// The timestamp when the contact was connected to the agent.
        public var connectedToAgentTimestamp: ClientRuntime.Date?
        /// The identifier of the agent who accepted the contact.
        public var id: Swift.String?

        public init (
            connectedToAgentTimestamp: ClientRuntime.Date? = nil,
            id: Swift.String? = nil
        )
        {
            self.connectedToAgentTimestamp = connectedToAgentTimestamp
            self.id = id
        }
    }

}

extension ConnectClientTypes.AgentStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentStatusARN = "AgentStatusARN"
        case agentStatusId = "AgentStatusId"
        case description = "Description"
        case displayOrder = "DisplayOrder"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentStatusARN = agentStatusARN {
            try encodeContainer.encode(agentStatusARN, forKey: .agentStatusARN)
        }
        if let agentStatusId = agentStatusId {
            try encodeContainer.encode(agentStatusId, forKey: .agentStatusId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayOrder = displayOrder {
            try encodeContainer.encode(displayOrder, forKey: .displayOrder)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentStatusARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentStatusARN)
        agentStatusARN = agentStatusARNDecoded
        let agentStatusIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentStatusId)
        agentStatusId = agentStatusIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatusType.self, forKey: .type)
        type = typeDecoded
        let displayOrderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .displayOrder)
        displayOrder = displayOrderDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatusState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about an agent status.
    public struct AgentStatus: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the agent status.
        public var agentStatusARN: Swift.String?
        /// The identifier of the agent status.
        public var agentStatusId: Swift.String?
        /// The description of the agent status.
        public var description: Swift.String?
        /// The display order of the agent status.
        public var displayOrder: Swift.Int?
        /// The name of the agent status.
        public var name: Swift.String?
        /// The state of the agent status.
        public var state: ConnectClientTypes.AgentStatusState?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of agent status.
        public var type: ConnectClientTypes.AgentStatusType?

        public init (
            agentStatusARN: Swift.String? = nil,
            agentStatusId: Swift.String? = nil,
            description: Swift.String? = nil,
            displayOrder: Swift.Int? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.AgentStatusState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ConnectClientTypes.AgentStatusType? = nil
        )
        {
            self.agentStatusARN = agentStatusARN
            self.agentStatusId = agentStatusId
            self.description = description
            self.displayOrder = displayOrder
            self.name = name
            self.state = state
            self.tags = tags
            self.type = type
        }
    }

}

extension ConnectClientTypes {
    public enum AgentStatusState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatusState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentStatusState(rawValue: rawValue) ?? AgentStatusState.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.AgentStatusSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatusType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ConnectClientTypes {
    /// Summary information for an agent status.
    public struct AgentStatusSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the agent status.
        public var arn: Swift.String?
        /// The identifier for an agent status.
        public var id: Swift.String?
        /// The name of the agent status.
        public var name: Swift.String?
        /// The type of the agent status.
        public var type: ConnectClientTypes.AgentStatusType?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: ConnectClientTypes.AgentStatusType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.type = type
        }
    }

}

extension ConnectClientTypes {
    public enum AgentStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case offline
        case routable
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatusType] {
            return [
                .custom,
                .offline,
                .routable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .offline: return "OFFLINE"
            case .routable: return "ROUTABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentStatusType(rawValue: rawValue) ?? AgentStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.AnswerMachineDetectionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awaitAnswerMachinePrompt = "AwaitAnswerMachinePrompt"
        case enableAnswerMachineDetection = "EnableAnswerMachineDetection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if awaitAnswerMachinePrompt != false {
            try encodeContainer.encode(awaitAnswerMachinePrompt, forKey: .awaitAnswerMachinePrompt)
        }
        if enableAnswerMachineDetection != false {
            try encodeContainer.encode(enableAnswerMachineDetection, forKey: .enableAnswerMachineDetection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableAnswerMachineDetectionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enableAnswerMachineDetection)
        enableAnswerMachineDetection = enableAnswerMachineDetectionDecoded
        let awaitAnswerMachinePromptDecoded = try containerValues.decode(Swift.Bool.self, forKey: .awaitAnswerMachinePrompt)
        awaitAnswerMachinePrompt = awaitAnswerMachinePromptDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration of the answering machine detection.
    public struct AnswerMachineDetectionConfig: Swift.Equatable {
        /// Wait for the answering machine prompt.
        public var awaitAnswerMachinePrompt: Swift.Bool
        /// The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to true, TrafficType must be set as CAMPAIGN.
        public var enableAnswerMachineDetection: Swift.Bool

        public init (
            awaitAnswerMachinePrompt: Swift.Bool = false,
            enableAnswerMachineDetection: Swift.Bool = false
        )
        {
            self.awaitAnswerMachinePrompt = awaitAnswerMachinePrompt
            self.enableAnswerMachineDetection = enableAnswerMachineDetection
        }
    }

}

extension AssociateApprovedOriginInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origin = "Origin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let origin = origin {
            try encodeContainer.encode(origin, forKey: .origin)
        }
    }
}

extension AssociateApprovedOriginInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/approved-origin"
    }
}

public struct AssociateApprovedOriginInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The domain to add to your allow list.
    /// This member is required.
    public var origin: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        origin: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.origin = origin
    }
}

struct AssociateApprovedOriginInputBody: Swift.Equatable {
    let origin: Swift.String?
}

extension AssociateApprovedOriginInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origin = "Origin"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .origin)
        origin = originDecoded
    }
}

extension AssociateApprovedOriginOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateApprovedOriginOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateApprovedOriginOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateApprovedOriginOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateApprovedOriginOutputResponse: Swift.Equatable {

}

extension AssociateBotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
        case lexV2Bot = "LexV2Bot"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexBot = lexBot {
            try encodeContainer.encode(lexBot, forKey: .lexBot)
        }
        if let lexV2Bot = lexV2Bot {
            try encodeContainer.encode(lexV2Bot, forKey: .lexV2Bot)
        }
    }
}

extension AssociateBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/bot"
    }
}

public struct AssociateBotInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Configuration information of an Amazon Lex bot.
    public var lexBot: ConnectClientTypes.LexBot?
    /// The Amazon Lex V2 bot to associate with the instance.
    public var lexV2Bot: ConnectClientTypes.LexV2Bot?

    public init (
        instanceId: Swift.String? = nil,
        lexBot: ConnectClientTypes.LexBot? = nil,
        lexV2Bot: ConnectClientTypes.LexV2Bot? = nil
    )
    {
        self.instanceId = instanceId
        self.lexBot = lexBot
        self.lexV2Bot = lexV2Bot
    }
}

struct AssociateBotInputBody: Swift.Equatable {
    let lexBot: ConnectClientTypes.LexBot?
    let lexV2Bot: ConnectClientTypes.LexV2Bot?
}

extension AssociateBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
        case lexV2Bot = "LexV2Bot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexBot.self, forKey: .lexBot)
        lexBot = lexBotDecoded
        let lexV2BotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexV2Bot.self, forKey: .lexV2Bot)
        lexV2Bot = lexV2BotDecoded
    }
}

extension AssociateBotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateBotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateBotOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateBotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateBotOutputResponse: Swift.Equatable {

}

extension AssociateInstanceStorageConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType = "ResourceType"
        case storageConfig = "StorageConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let storageConfig = storageConfig {
            try encodeContainer.encode(storageConfig, forKey: .storageConfig)
        }
    }
}

extension AssociateInstanceStorageConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-config"
    }
}

public struct AssociateInstanceStorageConfigInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?
    /// A valid storage type.
    /// This member is required.
    public var storageConfig: ConnectClientTypes.InstanceStorageConfig?

    public init (
        instanceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil,
        storageConfig: ConnectClientTypes.InstanceStorageConfig? = nil
    )
    {
        self.instanceId = instanceId
        self.resourceType = resourceType
        self.storageConfig = storageConfig
    }
}

struct AssociateInstanceStorageConfigInputBody: Swift.Equatable {
    let resourceType: ConnectClientTypes.InstanceStorageResourceType?
    let storageConfig: ConnectClientTypes.InstanceStorageConfig?
}

extension AssociateInstanceStorageConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType = "ResourceType"
        case storageConfig = "StorageConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStorageResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let storageConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStorageConfig.self, forKey: .storageConfig)
        storageConfig = storageConfigDecoded
    }
}

extension AssociateInstanceStorageConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateInstanceStorageConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateInstanceStorageConfigOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateInstanceStorageConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateInstanceStorageConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationId = output.associationId
        } else {
            self.associationId = nil
        }
    }
}

public struct AssociateInstanceStorageConfigOutputResponse: Swift.Equatable {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    public var associationId: Swift.String?

    public init (
        associationId: Swift.String? = nil
    )
    {
        self.associationId = associationId
    }
}

struct AssociateInstanceStorageConfigOutputResponseBody: Swift.Equatable {
    let associationId: Swift.String?
}

extension AssociateInstanceStorageConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

extension AssociateLambdaFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn = "FunctionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
    }
}

extension AssociateLambdaFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lambda-function"
    }
}

public struct AssociateLambdaFunctionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the Lambda function being associated. Maximum number of characters allowed is 140.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        functionArn: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.functionArn = functionArn
        self.instanceId = instanceId
    }
}

struct AssociateLambdaFunctionInputBody: Swift.Equatable {
    let functionArn: Swift.String?
}

extension AssociateLambdaFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn = "FunctionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
    }
}

extension AssociateLambdaFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateLambdaFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateLambdaFunctionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateLambdaFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateLambdaFunctionOutputResponse: Swift.Equatable {

}

extension AssociateLexBotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexBot = lexBot {
            try encodeContainer.encode(lexBot, forKey: .lexBot)
        }
    }
}

extension AssociateLexBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lex-bot"
    }
}

public struct AssociateLexBotInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The Amazon Lex bot to associate with the instance.
    /// This member is required.
    public var lexBot: ConnectClientTypes.LexBot?

    public init (
        instanceId: Swift.String? = nil,
        lexBot: ConnectClientTypes.LexBot? = nil
    )
    {
        self.instanceId = instanceId
        self.lexBot = lexBot
    }
}

struct AssociateLexBotInputBody: Swift.Equatable {
    let lexBot: ConnectClientTypes.LexBot?
}

extension AssociateLexBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexBot.self, forKey: .lexBot)
        lexBot = lexBotDecoded
    }
}

extension AssociateLexBotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateLexBotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateLexBotOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateLexBotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateLexBotOutputResponse: Swift.Equatable {

}

extension AssociateQueueQuickConnectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectIds = "QuickConnectIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quickConnectIds = quickConnectIds {
            var quickConnectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .quickConnectIds)
            for quickconnectslist0 in quickConnectIds {
                try quickConnectIdsContainer.encode(quickconnectslist0)
            }
        }
    }
}

extension AssociateQueueQuickConnectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/associate-quick-connects"
    }
}

public struct AssociateQueueQuickConnectsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?
    /// The quick connects to associate with this queue.
    /// This member is required.
    public var quickConnectIds: [Swift.String]?

    public init (
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        quickConnectIds: [Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
        self.quickConnectIds = quickConnectIds
    }
}

struct AssociateQueueQuickConnectsInputBody: Swift.Equatable {
    let quickConnectIds: [Swift.String]?
}

extension AssociateQueueQuickConnectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectIds = "QuickConnectIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .quickConnectIds)
        var quickConnectIdsDecoded0:[Swift.String]? = nil
        if let quickConnectIdsContainer = quickConnectIdsContainer {
            quickConnectIdsDecoded0 = [Swift.String]()
            for string0 in quickConnectIdsContainer {
                if let string0 = string0 {
                    quickConnectIdsDecoded0?.append(string0)
                }
            }
        }
        quickConnectIds = quickConnectIdsDecoded0
    }
}

extension AssociateQueueQuickConnectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateQueueQuickConnectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateQueueQuickConnectsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateQueueQuickConnectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateQueueQuickConnectsOutputResponse: Swift.Equatable {

}

extension AssociateRoutingProfileQueuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueConfigs = "QueueConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queueConfigs = queueConfigs {
            var queueConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueConfigs)
            for routingprofilequeueconfiglist0 in queueConfigs {
                try queueConfigsContainer.encode(routingprofilequeueconfiglist0)
            }
        }
    }
}

extension AssociateRoutingProfileQueuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/associate-queues"
    }
}

public struct AssociateRoutingProfileQueuesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The queues to associate with this routing profile.
    /// This member is required.
    public var queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueConfigs = queueConfigs
        self.routingProfileId = routingProfileId
    }
}

struct AssociateRoutingProfileQueuesInputBody: Swift.Equatable {
    let queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
}

extension AssociateRoutingProfileQueuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueConfigs = "QueueConfigs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueConfigsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileQueueConfig?].self, forKey: .queueConfigs)
        var queueConfigsDecoded0:[ConnectClientTypes.RoutingProfileQueueConfig]? = nil
        if let queueConfigsContainer = queueConfigsContainer {
            queueConfigsDecoded0 = [ConnectClientTypes.RoutingProfileQueueConfig]()
            for structure0 in queueConfigsContainer {
                if let structure0 = structure0 {
                    queueConfigsDecoded0?.append(structure0)
                }
            }
        }
        queueConfigs = queueConfigsDecoded0
    }
}

extension AssociateRoutingProfileQueuesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateRoutingProfileQueuesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateRoutingProfileQueuesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateRoutingProfileQueuesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateRoutingProfileQueuesOutputResponse: Swift.Equatable {

}

extension AssociateSecurityKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }
}

extension AssociateSecurityKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/security-key"
    }
}

public struct AssociateSecurityKeyInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid security key in PEM format.
    /// This member is required.
    public var key: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        key: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.key = key
    }
}

struct AssociateSecurityKeyInputBody: Swift.Equatable {
    let key: Swift.String?
}

extension AssociateSecurityKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension AssociateSecurityKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateSecurityKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateSecurityKeyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateSecurityKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateSecurityKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associationId = output.associationId
        } else {
            self.associationId = nil
        }
    }
}

public struct AssociateSecurityKeyOutputResponse: Swift.Equatable {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    public var associationId: Swift.String?

    public init (
        associationId: Swift.String? = nil
    )
    {
        self.associationId = associationId
    }
}

struct AssociateSecurityKeyOutputResponseBody: Swift.Equatable {
    let associationId: Swift.String?
}

extension AssociateSecurityKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

extension ConnectClientTypes.AttachmentReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case status = "Status"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ReferenceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the attachment reference if the referenceType is ATTACHMENT. Otherwise, null.
    public struct AttachmentReference: Swift.Equatable {
        /// Identifier of the attachment reference.
        public var name: Swift.String?
        /// Status of an attachment reference type.
        public var status: ConnectClientTypes.ReferenceStatus?
        /// Contains the location path of the attachment reference.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            status: ConnectClientTypes.ReferenceStatus? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.status = status
            self.value = value
        }
    }

}

extension ConnectClientTypes.Attribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeType = "AttributeType"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeType = attributeType {
            try encodeContainer.encode(attributeType.rawValue, forKey: .attributeType)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceAttributeType.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// A toggle for an individual feature at the instance level.
    public struct Attribute: Swift.Equatable {
        /// The type of attribute.
        public var attributeType: ConnectClientTypes.InstanceAttributeType?
        /// The value of the attribute.
        public var value: Swift.String?

        public init (
            attributeType: ConnectClientTypes.InstanceAttributeType? = nil,
            value: Swift.String? = nil
        )
        {
            self.attributeType = attributeType
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    public enum Channel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chat
        case task
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [Channel] {
            return [
                .chat,
                .task,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chat: return "CHAT"
            case .task: return "TASK"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Channel(rawValue: rawValue) ?? Channel.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ChatMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension ConnectClientTypes {
    /// A chat message.
    public struct ChatMessage: Swift.Equatable {
        /// The content of the chat message.
        /// This member is required.
        public var content: Swift.String?
        /// The type of the content. Supported types are text and plain.
        /// This member is required.
        public var contentType: Swift.String?

        public init (
            content: Swift.String? = nil,
            contentType: Swift.String? = nil
        )
        {
            self.content = content
            self.contentType = contentType
        }
    }

}

extension ConnectClientTypes.ChatStreamingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingEndpointArn = "StreamingEndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamingEndpointArn = streamingEndpointArn {
            try encodeContainer.encode(streamingEndpointArn, forKey: .streamingEndpointArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingEndpointArn)
        streamingEndpointArn = streamingEndpointArnDecoded
    }
}

extension ConnectClientTypes {
    /// The streaming configuration, such as the Amazon SNS streaming endpoint.
    public struct ChatStreamingConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.
        /// This member is required.
        public var streamingEndpointArn: Swift.String?

        public init (
            streamingEndpointArn: Swift.String? = nil
        )
        {
            self.streamingEndpointArn = streamingEndpointArn
        }
    }

}

extension ConnectClientTypes {
    public enum Comparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lt
        case sdkUnknown(Swift.String)

        public static var allCases: [Comparison] {
            return [
                .lt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lt: return "LT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Comparison(rawValue: rawValue) ?? Comparison.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.Contact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentInfo = "AgentInfo"
        case arn = "Arn"
        case channel = "Channel"
        case description = "Description"
        case disconnectTimestamp = "DisconnectTimestamp"
        case id = "Id"
        case initialContactId = "InitialContactId"
        case initiationMethod = "InitiationMethod"
        case initiationTimestamp = "InitiationTimestamp"
        case lastUpdateTimestamp = "LastUpdateTimestamp"
        case name = "Name"
        case previousContactId = "PreviousContactId"
        case queueInfo = "QueueInfo"
        case scheduledTimestamp = "ScheduledTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentInfo = agentInfo {
            try encodeContainer.encode(agentInfo, forKey: .agentInfo)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channel = channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimestamp = disconnectTimestamp {
            try encodeContainer.encode(disconnectTimestamp.timeIntervalSince1970, forKey: .disconnectTimestamp)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let initialContactId = initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let initiationMethod = initiationMethod {
            try encodeContainer.encode(initiationMethod.rawValue, forKey: .initiationMethod)
        }
        if let initiationTimestamp = initiationTimestamp {
            try encodeContainer.encode(initiationTimestamp.timeIntervalSince1970, forKey: .initiationTimestamp)
        }
        if let lastUpdateTimestamp = lastUpdateTimestamp {
            try encodeContainer.encode(lastUpdateTimestamp.timeIntervalSince1970, forKey: .lastUpdateTimestamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let previousContactId = previousContactId {
            try encodeContainer.encode(previousContactId, forKey: .previousContactId)
        }
        if let queueInfo = queueInfo {
            try encodeContainer.encode(queueInfo, forKey: .queueInfo)
        }
        if let scheduledTimestamp = scheduledTimestamp {
            try encodeContainer.encode(scheduledTimestamp.timeIntervalSince1970, forKey: .scheduledTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let previousContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previousContactId)
        previousContactId = previousContactIdDecoded
        let initiationMethodDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactInitiationMethod.self, forKey: .initiationMethod)
        initiationMethod = initiationMethodDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let channelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
        let queueInfoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueInfo.self, forKey: .queueInfo)
        queueInfo = queueInfoDecoded
        let agentInfoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentInfo.self, forKey: .agentInfo)
        agentInfo = agentInfoDecoded
        let initiationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .initiationTimestamp)
        initiationTimestamp = initiationTimestampDecoded
        let disconnectTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .disconnectTimestamp)
        disconnectTimestamp = disconnectTimestampDecoded
        let lastUpdateTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTimestamp)
        lastUpdateTimestamp = lastUpdateTimestampDecoded
        let scheduledTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledTimestamp)
        scheduledTimestamp = scheduledTimestampDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a contact.
    public struct Contact: Swift.Equatable {
        /// Information about the agent who accepted the contact.
        public var agentInfo: ConnectClientTypes.AgentInfo?
        /// The Amazon Resource Name (ARN) for the contact.
        public var arn: Swift.String?
        /// How the contact reached your contact center.
        public var channel: ConnectClientTypes.Channel?
        /// The description of the contact.
        public var description: Swift.String?
        /// The timestamp when the customer endpoint disconnected from Amazon Connect.
        public var disconnectTimestamp: ClientRuntime.Date?
        /// The identifier for the contact.
        public var id: Swift.String?
        /// If this contact is related to other contacts, this is the ID of the initial contact.
        public var initialContactId: Swift.String?
        /// Indicates how the contact was initiated.
        public var initiationMethod: ConnectClientTypes.ContactInitiationMethod?
        /// The date and time this contact was initiated, in UTC time. For INBOUND, this is when the contact arrived. For OUTBOUND, this is when the agent began dialing. For CALLBACK, this is when the callback contact was created. For TRANSFER and QUEUE_TRANSFER, this is when the transfer was initiated. For API, this is when the request arrived.
        public var initiationTimestamp: ClientRuntime.Date?
        /// The timestamp when contact was last updated.
        public var lastUpdateTimestamp: ClientRuntime.Date?
        /// The name of the contact.
        public var name: Swift.String?
        /// If this contact is not the first contact, this is the ID of the previous contact.
        public var previousContactId: Swift.String?
        /// If this contact was queued, this contains information about the queue.
        public var queueInfo: ConnectClientTypes.QueueInfo?
        /// The timestamp, in Unix epoch time format, at which to start running the inbound flow.
        public var scheduledTimestamp: ClientRuntime.Date?

        public init (
            agentInfo: ConnectClientTypes.AgentInfo? = nil,
            arn: Swift.String? = nil,
            channel: ConnectClientTypes.Channel? = nil,
            description: Swift.String? = nil,
            disconnectTimestamp: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            initialContactId: Swift.String? = nil,
            initiationMethod: ConnectClientTypes.ContactInitiationMethod? = nil,
            initiationTimestamp: ClientRuntime.Date? = nil,
            lastUpdateTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            previousContactId: Swift.String? = nil,
            queueInfo: ConnectClientTypes.QueueInfo? = nil,
            scheduledTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.agentInfo = agentInfo
            self.arn = arn
            self.channel = channel
            self.description = description
            self.disconnectTimestamp = disconnectTimestamp
            self.id = id
            self.initialContactId = initialContactId
            self.initiationMethod = initiationMethod
            self.initiationTimestamp = initiationTimestamp
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.name = name
            self.previousContactId = previousContactId
            self.queueInfo = queueInfo
            self.scheduledTimestamp = scheduledTimestamp
        }
    }

}

extension ConnectClientTypes.ContactFlow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case content = "Content"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowType.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a contact flow.
    public struct ContactFlow: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the contact flow.
        public var arn: Swift.String?
        /// The content of the contact flow.
        public var content: Swift.String?
        /// The description of the contact flow.
        public var description: Swift.String?
        /// The identifier of the contact flow.
        public var id: Swift.String?
        /// The name of the contact flow.
        public var name: Swift.String?
        /// The type of contact flow.
        public var state: ConnectClientTypes.ContactFlowState?
        /// One or more tags.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the contact flow. For descriptions of the available types, see [Choose a Contact Flow Type](https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types) in the Amazon Connect Administrator Guide.
        public var type: ConnectClientTypes.ContactFlowType?

        public init (
            arn: Swift.String? = nil,
            content: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.ContactFlowState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ConnectClientTypes.ContactFlowType? = nil
        )
        {
            self.arn = arn
            self.content = content
            self.description = description
            self.id = id
            self.name = name
            self.state = state
            self.tags = tags
            self.type = type
        }
    }

}

extension ConnectClientTypes.ContactFlowModule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case content = "Content"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowModuleState.self, forKey: .state)
        state = stateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowModuleStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a contact flow module.
    public struct ContactFlowModule: Swift.Equatable {
        /// The Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The content of the contact flow module.
        public var content: Swift.String?
        /// The description of the contact flow module.
        public var description: Swift.String?
        /// The identifier of the contact flow module.
        public var id: Swift.String?
        /// The name of the contact flow module.
        public var name: Swift.String?
        /// The type of contact flow module.
        public var state: ConnectClientTypes.ContactFlowModuleState?
        /// The status of the contact flow module.
        public var status: ConnectClientTypes.ContactFlowModuleStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            content: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.ContactFlowModuleState? = nil,
            status: ConnectClientTypes.ContactFlowModuleStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.content = content
            self.description = description
            self.id = id
            self.name = name
            self.state = state
            self.status = status
            self.tags = tags
        }
    }

}

extension ConnectClientTypes {
    public enum ContactFlowModuleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowModuleState] {
            return [
                .active,
                .archived,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactFlowModuleState(rawValue: rawValue) ?? ContactFlowModuleState.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum ContactFlowModuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case published
        case saved
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowModuleStatus] {
            return [
                .published,
                .saved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .published: return "PUBLISHED"
            case .saved: return "SAVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactFlowModuleStatus(rawValue: rawValue) ?? ContactFlowModuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ContactFlowModuleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowModuleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a contact flow.
    public struct ContactFlowModuleSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the contact flow module.
        public var arn: Swift.String?
        /// The identifier of the contact flow module.
        public var id: Swift.String?
        /// The name of the contact flow module.
        public var name: Swift.String?
        /// The type of contact flow module.
        public var state: ConnectClientTypes.ContactFlowModuleState?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: ConnectClientTypes.ContactFlowModuleState? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.state = state
        }
    }

}

extension ContactFlowNotPublishedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ContactFlowNotPublishedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The contact flow has not been published.
public struct ContactFlowNotPublishedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ContactFlowNotPublishedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ContactFlowNotPublishedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    public enum ContactFlowState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowState] {
            return [
                .active,
                .archived,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactFlowState(rawValue: rawValue) ?? ContactFlowState.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ContactFlowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case contactFlowState = "ContactFlowState"
        case contactFlowType = "ContactFlowType"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let contactFlowState = contactFlowState {
            try encodeContainer.encode(contactFlowState.rawValue, forKey: .contactFlowState)
        }
        if let contactFlowType = contactFlowType {
            try encodeContainer.encode(contactFlowType.rawValue, forKey: .contactFlowType)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactFlowTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowType.self, forKey: .contactFlowType)
        contactFlowType = contactFlowTypeDecoded
        let contactFlowStateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowState.self, forKey: .contactFlowState)
        contactFlowState = contactFlowStateDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a contact flow. You can also create and update contact flows using the [Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/adminguide/flow-language.html).
    public struct ContactFlowSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the contact flow.
        public var arn: Swift.String?
        /// The type of contact flow.
        public var contactFlowState: ConnectClientTypes.ContactFlowState?
        /// The type of contact flow.
        public var contactFlowType: ConnectClientTypes.ContactFlowType?
        /// The identifier of the contact flow.
        public var id: Swift.String?
        /// The name of the contact flow.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            contactFlowState: ConnectClientTypes.ContactFlowState? = nil,
            contactFlowType: ConnectClientTypes.ContactFlowType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.contactFlowState = contactFlowState
            self.contactFlowType = contactFlowType
            self.id = id
            self.name = name
        }
    }

}

extension ConnectClientTypes {
    public enum ContactFlowType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentHold
        case agentTransfer
        case agentWhisper
        case contactFlow
        case customerHold
        case customerQueue
        case customerWhisper
        case outboundWhisper
        case queueTransfer
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactFlowType] {
            return [
                .agentHold,
                .agentTransfer,
                .agentWhisper,
                .contactFlow,
                .customerHold,
                .customerQueue,
                .customerWhisper,
                .outboundWhisper,
                .queueTransfer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentHold: return "AGENT_HOLD"
            case .agentTransfer: return "AGENT_TRANSFER"
            case .agentWhisper: return "AGENT_WHISPER"
            case .contactFlow: return "CONTACT_FLOW"
            case .customerHold: return "CUSTOMER_HOLD"
            case .customerQueue: return "CUSTOMER_QUEUE"
            case .customerWhisper: return "CUSTOMER_WHISPER"
            case .outboundWhisper: return "OUTBOUND_WHISPER"
            case .queueTransfer: return "QUEUE_TRANSFER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactFlowType(rawValue: rawValue) ?? ContactFlowType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum ContactInitiationMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case api
        case callback
        case inbound
        case outbound
        case queueTransfer
        case transfer
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactInitiationMethod] {
            return [
                .api,
                .callback,
                .inbound,
                .outbound,
                .queueTransfer,
                .transfer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .callback: return "CALLBACK"
            case .inbound: return "INBOUND"
            case .outbound: return "OUTBOUND"
            case .queueTransfer: return "QUEUE_TRANSFER"
            case .transfer: return "TRANSFER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactInitiationMethod(rawValue: rawValue) ?? ContactInitiationMethod.sdkUnknown(rawValue)
        }
    }
}

extension ContactNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ContactNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The contact with the specified ID is not active or does not exist.
public struct ContactNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ContactNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ContactNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAgentStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayOrder = "DisplayOrder"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayOrder = displayOrder {
            try encodeContainer.encode(displayOrder, forKey: .displayOrder)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAgentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/agent-status/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateAgentStatusInput: Swift.Equatable {
    /// The description of the status.
    public var description: Swift.String?
    /// The display order of the status.
    public var displayOrder: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the status.
    /// This member is required.
    public var name: Swift.String?
    /// The state of the status.
    /// This member is required.
    public var state: ConnectClientTypes.AgentStatusState?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        displayOrder: Swift.Int? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        state: ConnectClientTypes.AgentStatusState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.displayOrder = displayOrder
        self.instanceId = instanceId
        self.name = name
        self.state = state
        self.tags = tags
    }
}

struct CreateAgentStatusInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let state: ConnectClientTypes.AgentStatusState?
    let displayOrder: Swift.Int?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAgentStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayOrder = "DisplayOrder"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatusState.self, forKey: .state)
        state = stateDecoded
        let displayOrderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .displayOrder)
        displayOrder = displayOrderDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAgentStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAgentStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAgentStatusOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAgentStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAgentStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentStatusARN = output.agentStatusARN
            self.agentStatusId = output.agentStatusId
        } else {
            self.agentStatusARN = nil
            self.agentStatusId = nil
        }
    }
}

public struct CreateAgentStatusOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the agent status.
    public var agentStatusARN: Swift.String?
    /// The identifier of the agent status.
    public var agentStatusId: Swift.String?

    public init (
        agentStatusARN: Swift.String? = nil,
        agentStatusId: Swift.String? = nil
    )
    {
        self.agentStatusARN = agentStatusARN
        self.agentStatusId = agentStatusId
    }
}

struct CreateAgentStatusOutputResponseBody: Swift.Equatable {
    let agentStatusARN: Swift.String?
    let agentStatusId: Swift.String?
}

extension CreateAgentStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentStatusARN = "AgentStatusARN"
        case agentStatusId = "AgentStatusId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentStatusARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentStatusARN)
        agentStatusARN = agentStatusARNDecoded
        let agentStatusIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentStatusId)
        agentStatusId = agentStatusIdDecoded
    }
}

extension CreateContactFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateContactFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateContactFlowInput: Swift.Equatable {
    /// The content of the contact flow.
    /// This member is required.
    public var content: Swift.String?
    /// The description of the contact flow.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the contact flow.
    /// This member is required.
    public var name: Swift.String?
    /// One or more tags.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the contact flow. For descriptions of the available types, see [Choose a Contact Flow Type](https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types) in the Amazon Connect Administrator Guide.
    /// This member is required.
    public var type: ConnectClientTypes.ContactFlowType?

    public init (
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: ConnectClientTypes.ContactFlowType? = nil
    )
    {
        self.content = content
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateContactFlowInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: ConnectClientTypes.ContactFlowType?
    let description: Swift.String?
    let content: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateContactFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContactFlowModuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateContactFlowModuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateContactFlowModuleInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The content of the contact flow module.
    /// This member is required.
    public var content: Swift.String?
    /// The description of the contact flow module.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the contact flow module.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        content: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.content = content
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.tags = tags
    }
}

struct CreateContactFlowModuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let content: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateContactFlowModuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateContactFlowModuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactFlowModuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyException" : self = .idempotencyException(try IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContactFlowModuleException" : self = .invalidContactFlowModuleException(try InvalidContactFlowModuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactFlowModuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case duplicateResourceException(DuplicateResourceException)
    case idempotencyException(IdempotencyException)
    case internalServiceException(InternalServiceException)
    case invalidContactFlowModuleException(InvalidContactFlowModuleException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactFlowModuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateContactFlowModuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateContactFlowModuleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact flow module.
    public var arn: Swift.String?
    /// The identifier of the contact flow module.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateContactFlowModuleOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension CreateContactFlowModuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateContactFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContactFlowException" : self = .invalidContactFlowException(try InvalidContactFlowException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactFlowOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidContactFlowException(InvalidContactFlowException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateContactFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactFlowArn = output.contactFlowArn
            self.contactFlowId = output.contactFlowId
        } else {
            self.contactFlowArn = nil
            self.contactFlowId = nil
        }
    }
}

public struct CreateContactFlowOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact flow.
    public var contactFlowArn: Swift.String?
    /// The identifier of the contact flow.
    public var contactFlowId: Swift.String?

    public init (
        contactFlowArn: Swift.String? = nil,
        contactFlowId: Swift.String? = nil
    )
    {
        self.contactFlowArn = contactFlowArn
        self.contactFlowId = contactFlowId
    }
}

struct CreateContactFlowOutputResponseBody: Swift.Equatable {
    let contactFlowId: Swift.String?
    let contactFlowArn: Swift.String?
}

extension CreateContactFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowArn = "ContactFlowArn"
        case contactFlowId = "ContactFlowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let contactFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowArn)
        contactFlowArn = contactFlowArnDecoded
    }
}

extension CreateHoursOfOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case timeZone = "TimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            var configContainer = encodeContainer.nestedUnkeyedContainer(forKey: .config)
            for hoursofoperationconfiglist0 in config {
                try configContainer.encode(hoursofoperationconfiglist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeZone = timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
    }
}

extension CreateHoursOfOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/hours-of-operations/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateHoursOfOperationInput: Swift.Equatable {
    /// Configuration information for the hours of operation: day, start time, and end time.
    /// This member is required.
    public var config: [ConnectClientTypes.HoursOfOperationConfig]?
    /// The description of the hours of operation.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the hours of operation.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The time zone of the hours of operation.
    /// This member is required.
    public var timeZone: Swift.String?

    public init (
        config: [ConnectClientTypes.HoursOfOperationConfig]? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeZone: Swift.String? = nil
    )
    {
        self.config = config
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.tags = tags
        self.timeZone = timeZone
    }
}

struct CreateHoursOfOperationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let timeZone: Swift.String?
    let config: [ConnectClientTypes.HoursOfOperationConfig]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateHoursOfOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case timeZone = "TimeZone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let configContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HoursOfOperationConfig?].self, forKey: .config)
        var configDecoded0:[ConnectClientTypes.HoursOfOperationConfig]? = nil
        if let configContainer = configContainer {
            configDecoded0 = [ConnectClientTypes.HoursOfOperationConfig]()
            for structure0 in configContainer {
                if let structure0 = structure0 {
                    configDecoded0?.append(structure0)
                }
            }
        }
        config = configDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateHoursOfOperationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHoursOfOperationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHoursOfOperationOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHoursOfOperationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHoursOfOperationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hoursOfOperationArn = output.hoursOfOperationArn
            self.hoursOfOperationId = output.hoursOfOperationId
        } else {
            self.hoursOfOperationArn = nil
            self.hoursOfOperationId = nil
        }
    }
}

public struct CreateHoursOfOperationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the hours of operation.
    public var hoursOfOperationArn: Swift.String?
    /// The identifier for the hours of operation.
    public var hoursOfOperationId: Swift.String?

    public init (
        hoursOfOperationArn: Swift.String? = nil,
        hoursOfOperationId: Swift.String? = nil
    )
    {
        self.hoursOfOperationArn = hoursOfOperationArn
        self.hoursOfOperationId = hoursOfOperationId
    }
}

struct CreateHoursOfOperationOutputResponseBody: Swift.Equatable {
    let hoursOfOperationId: Swift.String?
    let hoursOfOperationArn: Swift.String?
}

extension CreateHoursOfOperationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hoursOfOperationArn = "HoursOfOperationArn"
        case hoursOfOperationId = "HoursOfOperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
        let hoursOfOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationArn)
        hoursOfOperationArn = hoursOfOperationArnDecoded
    }
}

extension CreateInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case identityManagementType = "IdentityManagementType"
        case inboundCallsEnabled = "InboundCallsEnabled"
        case instanceAlias = "InstanceAlias"
        case outboundCallsEnabled = "OutboundCallsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let identityManagementType = identityManagementType {
            try encodeContainer.encode(identityManagementType.rawValue, forKey: .identityManagementType)
        }
        if let inboundCallsEnabled = inboundCallsEnabled {
            try encodeContainer.encode(inboundCallsEnabled, forKey: .inboundCallsEnabled)
        }
        if let instanceAlias = instanceAlias {
            try encodeContainer.encode(instanceAlias, forKey: .instanceAlias)
        }
        if let outboundCallsEnabled = outboundCallsEnabled {
            try encodeContainer.encode(outboundCallsEnabled, forKey: .outboundCallsEnabled)
        }
    }
}

extension CreateInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/instance"
    }
}

public struct CreateInstanceInput: Swift.Equatable {
    /// The idempotency token.
    public var clientToken: Swift.String?
    /// The identifier for the directory.
    public var directoryId: Swift.String?
    /// The type of identity management for your Amazon Connect users.
    /// This member is required.
    public var identityManagementType: ConnectClientTypes.DirectoryType?
    /// Your contact center handles incoming contacts.
    /// This member is required.
    public var inboundCallsEnabled: Swift.Bool?
    /// The name for your instance.
    public var instanceAlias: Swift.String?
    /// Your contact center allows outbound calls.
    /// This member is required.
    public var outboundCallsEnabled: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        identityManagementType: ConnectClientTypes.DirectoryType? = nil,
        inboundCallsEnabled: Swift.Bool? = nil,
        instanceAlias: Swift.String? = nil,
        outboundCallsEnabled: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.directoryId = directoryId
        self.identityManagementType = identityManagementType
        self.inboundCallsEnabled = inboundCallsEnabled
        self.instanceAlias = instanceAlias
        self.outboundCallsEnabled = outboundCallsEnabled
    }
}

struct CreateInstanceInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let identityManagementType: ConnectClientTypes.DirectoryType?
    let instanceAlias: Swift.String?
    let directoryId: Swift.String?
    let inboundCallsEnabled: Swift.Bool?
    let outboundCallsEnabled: Swift.Bool?
}

extension CreateInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case identityManagementType = "IdentityManagementType"
        case inboundCallsEnabled = "InboundCallsEnabled"
        case instanceAlias = "InstanceAlias"
        case outboundCallsEnabled = "OutboundCallsEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let identityManagementTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.DirectoryType.self, forKey: .identityManagementType)
        identityManagementType = identityManagementTypeDecoded
        let instanceAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceAlias)
        instanceAlias = instanceAliasDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let inboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCallsEnabled)
        inboundCallsEnabled = inboundCallsEnabledDecoded
        let outboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCallsEnabled)
        outboundCallsEnabled = outboundCallsEnabledDecoded
    }
}

extension CreateInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInstanceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateInstanceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the instance.
    public var arn: Swift.String?
    /// The identifier for the instance.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateInstanceOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension CreateInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateIntegrationAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integrationArn = "IntegrationArn"
        case integrationType = "IntegrationType"
        case sourceApplicationName = "SourceApplicationName"
        case sourceApplicationUrl = "SourceApplicationUrl"
        case sourceType = "SourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let integrationArn = integrationArn {
            try encodeContainer.encode(integrationArn, forKey: .integrationArn)
        }
        if let integrationType = integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let sourceApplicationName = sourceApplicationName {
            try encodeContainer.encode(sourceApplicationName, forKey: .sourceApplicationName)
        }
        if let sourceApplicationUrl = sourceApplicationUrl {
            try encodeContainer.encode(sourceApplicationUrl, forKey: .sourceApplicationUrl)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateIntegrationAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations"
    }
}

public struct CreateIntegrationAssociationInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The Amazon Resource Name (ARN) of the integration.
    /// This member is required.
    public var integrationArn: Swift.String?
    /// The type of information to be ingested.
    /// This member is required.
    public var integrationType: ConnectClientTypes.IntegrationType?
    /// The name of the external application. This field is only required for the EVENT integration type.
    public var sourceApplicationName: Swift.String?
    /// The URL for the external application. This field is only required for the EVENT integration type.
    public var sourceApplicationUrl: Swift.String?
    /// The type of the data source. This field is only required for the EVENT integration type.
    public var sourceType: ConnectClientTypes.SourceType?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        instanceId: Swift.String? = nil,
        integrationArn: Swift.String? = nil,
        integrationType: ConnectClientTypes.IntegrationType? = nil,
        sourceApplicationName: Swift.String? = nil,
        sourceApplicationUrl: Swift.String? = nil,
        sourceType: ConnectClientTypes.SourceType? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationArn = integrationArn
        self.integrationType = integrationType
        self.sourceApplicationName = sourceApplicationName
        self.sourceApplicationUrl = sourceApplicationUrl
        self.sourceType = sourceType
        self.tags = tags
    }
}

struct CreateIntegrationAssociationInputBody: Swift.Equatable {
    let integrationType: ConnectClientTypes.IntegrationType?
    let integrationArn: Swift.String?
    let sourceApplicationUrl: Swift.String?
    let sourceApplicationName: Swift.String?
    let sourceType: ConnectClientTypes.SourceType?
    let tags: [Swift.String:Swift.String]?
}

extension CreateIntegrationAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integrationArn = "IntegrationArn"
        case integrationType = "IntegrationType"
        case sourceApplicationName = "SourceApplicationName"
        case sourceApplicationUrl = "SourceApplicationUrl"
        case sourceType = "SourceType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationArn)
        integrationArn = integrationArnDecoded
        let sourceApplicationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApplicationUrl)
        sourceApplicationUrl = sourceApplicationUrlDecoded
        let sourceApplicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApplicationName)
        sourceApplicationName = sourceApplicationNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIntegrationAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIntegrationAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIntegrationAssociationOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIntegrationAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIntegrationAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.integrationAssociationArn = output.integrationAssociationArn
            self.integrationAssociationId = output.integrationAssociationId
        } else {
            self.integrationAssociationArn = nil
            self.integrationAssociationId = nil
        }
    }
}

public struct CreateIntegrationAssociationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the association.
    public var integrationAssociationArn: Swift.String?
    /// The identifier for the integration association.
    public var integrationAssociationId: Swift.String?

    public init (
        integrationAssociationArn: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil
    )
    {
        self.integrationAssociationArn = integrationAssociationArn
        self.integrationAssociationId = integrationAssociationId
    }
}

struct CreateIntegrationAssociationOutputResponseBody: Swift.Equatable {
    let integrationAssociationId: Swift.String?
    let integrationAssociationArn: Swift.String?
}

extension CreateIntegrationAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integrationAssociationArn = "IntegrationAssociationArn"
        case integrationAssociationId = "IntegrationAssociationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationAssociationId)
        integrationAssociationId = integrationAssociationIdDecoded
        let integrationAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationAssociationArn)
        integrationAssociationArn = integrationAssociationArnDecoded
    }
}

extension CreateQueueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hoursOfOperationId = "HoursOfOperationId"
        case maxContacts = "MaxContacts"
        case name = "Name"
        case outboundCallerConfig = "OutboundCallerConfig"
        case quickConnectIds = "QuickConnectIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hoursOfOperationId = hoursOfOperationId {
            try encodeContainer.encode(hoursOfOperationId, forKey: .hoursOfOperationId)
        }
        if maxContacts != 0 {
            try encodeContainer.encode(maxContacts, forKey: .maxContacts)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundCallerConfig = outboundCallerConfig {
            try encodeContainer.encode(outboundCallerConfig, forKey: .outboundCallerConfig)
        }
        if let quickConnectIds = quickConnectIds {
            var quickConnectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .quickConnectIds)
            for quickconnectslist0 in quickConnectIds {
                try quickConnectIdsContainer.encode(quickconnectslist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateQueueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateQueueInput: Swift.Equatable {
    /// The description of the queue.
    public var description: Swift.String?
    /// The identifier for the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of contacts that can be in the queue before it is considered full.
    public var maxContacts: Swift.Int
    /// The name of the queue.
    /// This member is required.
    public var name: Swift.String?
    /// The outbound caller ID name, number, and outbound whisper flow.
    public var outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
    /// The quick connects available to agents who are working the queue.
    public var quickConnectIds: [Swift.String]?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        maxContacts: Swift.Int = 0,
        name: Swift.String? = nil,
        outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig? = nil,
        quickConnectIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
        self.maxContacts = maxContacts
        self.name = name
        self.outboundCallerConfig = outboundCallerConfig
        self.quickConnectIds = quickConnectIds
        self.tags = tags
    }
}

struct CreateQueueInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
    let hoursOfOperationId: Swift.String?
    let maxContacts: Swift.Int
    let quickConnectIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateQueueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hoursOfOperationId = "HoursOfOperationId"
        case maxContacts = "MaxContacts"
        case name = "Name"
        case outboundCallerConfig = "OutboundCallerConfig"
        case quickConnectIds = "QuickConnectIds"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let outboundCallerConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.OutboundCallerConfig.self, forKey: .outboundCallerConfig)
        outboundCallerConfig = outboundCallerConfigDecoded
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
        let maxContactsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxContacts)
        maxContacts = maxContactsDecoded
        let quickConnectIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .quickConnectIds)
        var quickConnectIdsDecoded0:[Swift.String]? = nil
        if let quickConnectIdsContainer = quickConnectIdsContainer {
            quickConnectIdsDecoded0 = [Swift.String]()
            for string0 in quickConnectIdsContainer {
                if let string0 = string0 {
                    quickConnectIdsDecoded0?.append(string0)
                }
            }
        }
        quickConnectIds = quickConnectIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateQueueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateQueueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateQueueOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateQueueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateQueueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queueArn = output.queueArn
            self.queueId = output.queueId
        } else {
            self.queueArn = nil
            self.queueId = nil
        }
    }
}

public struct CreateQueueOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the queue.
    public var queueArn: Swift.String?
    /// The identifier for the queue.
    public var queueId: Swift.String?

    public init (
        queueArn: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.queueArn = queueArn
        self.queueId = queueId
    }
}

struct CreateQueueOutputResponseBody: Swift.Equatable {
    let queueArn: Swift.String?
    let queueId: Swift.String?
}

extension CreateQueueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueArn = "QueueArn"
        case queueId = "QueueId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
    }
}

extension CreateQuickConnectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case quickConnectConfig = "QuickConnectConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quickConnectConfig = quickConnectConfig {
            try encodeContainer.encode(quickConnectConfig, forKey: .quickConnectConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateQuickConnectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateQuickConnectInput: Swift.Equatable {
    /// The description of the quick connect.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the quick connect.
    /// This member is required.
    public var name: Swift.String?
    /// Configuration settings for the quick connect.
    /// This member is required.
    public var quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        quickConnectConfig: ConnectClientTypes.QuickConnectConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.quickConnectConfig = quickConnectConfig
        self.tags = tags
    }
}

struct CreateQuickConnectInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
    let tags: [Swift.String:Swift.String]?
}

extension CreateQuickConnectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case quickConnectConfig = "QuickConnectConfig"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let quickConnectConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnectConfig.self, forKey: .quickConnectConfig)
        quickConnectConfig = quickConnectConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateQuickConnectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateQuickConnectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateQuickConnectOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateQuickConnectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateQuickConnectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.quickConnectARN = output.quickConnectARN
            self.quickConnectId = output.quickConnectId
        } else {
            self.quickConnectARN = nil
            self.quickConnectId = nil
        }
    }
}

public struct CreateQuickConnectOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the quick connect.
    public var quickConnectARN: Swift.String?
    /// The identifier for the quick connect.
    public var quickConnectId: Swift.String?

    public init (
        quickConnectARN: Swift.String? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.quickConnectARN = quickConnectARN
        self.quickConnectId = quickConnectId
    }
}

struct CreateQuickConnectOutputResponseBody: Swift.Equatable {
    let quickConnectARN: Swift.String?
    let quickConnectId: Swift.String?
}

extension CreateQuickConnectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectARN = "QuickConnectARN"
        case quickConnectId = "QuickConnectId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickConnectARN)
        quickConnectARN = quickConnectARNDecoded
        let quickConnectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickConnectId)
        quickConnectId = quickConnectIdDecoded
    }
}

extension CreateRoutingProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
        case description = "Description"
        case mediaConcurrencies = "MediaConcurrencies"
        case name = "Name"
        case queueConfigs = "QueueConfigs"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultOutboundQueueId = defaultOutboundQueueId {
            try encodeContainer.encode(defaultOutboundQueueId, forKey: .defaultOutboundQueueId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mediaConcurrencies = mediaConcurrencies {
            var mediaConcurrenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaConcurrencies)
            for mediaconcurrencies0 in mediaConcurrencies {
                try mediaConcurrenciesContainer.encode(mediaconcurrencies0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queueConfigs = queueConfigs {
            var queueConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueConfigs)
            for routingprofilequeueconfiglist0 in queueConfigs {
                try queueConfigsContainer.encode(routingprofilequeueconfiglist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRoutingProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateRoutingProfileInput: Swift.Equatable {
    /// The default outbound queue for the routing profile.
    /// This member is required.
    public var defaultOutboundQueueId: Swift.String?
    /// Description of the routing profile. Must not be more than 250 characters.
    /// This member is required.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The channels that agents can handle in the Contact Control Panel (CCP) for this routing profile.
    /// This member is required.
    public var mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
    /// The name of the routing profile. Must not be more than 127 characters.
    /// This member is required.
    public var name: Swift.String?
    /// The inbound queues associated with the routing profile. If no queue is added, the agent can make only outbound calls.
    public var queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
    /// One or more tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        defaultOutboundQueueId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]? = nil,
        name: Swift.String? = nil,
        queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.defaultOutboundQueueId = defaultOutboundQueueId
        self.description = description
        self.instanceId = instanceId
        self.mediaConcurrencies = mediaConcurrencies
        self.name = name
        self.queueConfigs = queueConfigs
        self.tags = tags
    }
}

struct CreateRoutingProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let defaultOutboundQueueId: Swift.String?
    let queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
    let mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRoutingProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
        case description = "Description"
        case mediaConcurrencies = "MediaConcurrencies"
        case name = "Name"
        case queueConfigs = "QueueConfigs"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultOutboundQueueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOutboundQueueId)
        defaultOutboundQueueId = defaultOutboundQueueIdDecoded
        let queueConfigsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileQueueConfig?].self, forKey: .queueConfigs)
        var queueConfigsDecoded0:[ConnectClientTypes.RoutingProfileQueueConfig]? = nil
        if let queueConfigsContainer = queueConfigsContainer {
            queueConfigsDecoded0 = [ConnectClientTypes.RoutingProfileQueueConfig]()
            for structure0 in queueConfigsContainer {
                if let structure0 = structure0 {
                    queueConfigsDecoded0?.append(structure0)
                }
            }
        }
        queueConfigs = queueConfigsDecoded0
        let mediaConcurrenciesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.MediaConcurrency?].self, forKey: .mediaConcurrencies)
        var mediaConcurrenciesDecoded0:[ConnectClientTypes.MediaConcurrency]? = nil
        if let mediaConcurrenciesContainer = mediaConcurrenciesContainer {
            mediaConcurrenciesDecoded0 = [ConnectClientTypes.MediaConcurrency]()
            for structure0 in mediaConcurrenciesContainer {
                if let structure0 = structure0 {
                    mediaConcurrenciesDecoded0?.append(structure0)
                }
            }
        }
        mediaConcurrencies = mediaConcurrenciesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRoutingProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRoutingProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRoutingProfileOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRoutingProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRoutingProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.routingProfileArn = output.routingProfileArn
            self.routingProfileId = output.routingProfileId
        } else {
            self.routingProfileArn = nil
            self.routingProfileId = nil
        }
    }
}

public struct CreateRoutingProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the routing profile.
    public var routingProfileArn: Swift.String?
    /// The identifier of the routing profile.
    public var routingProfileId: Swift.String?

    public init (
        routingProfileArn: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.routingProfileArn = routingProfileArn
        self.routingProfileId = routingProfileId
    }
}

struct CreateRoutingProfileOutputResponseBody: Swift.Equatable {
    let routingProfileArn: Swift.String?
    let routingProfileId: Swift.String?
}

extension CreateRoutingProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingProfileArn = "RoutingProfileArn"
        case routingProfileId = "RoutingProfileId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileArn)
        routingProfileArn = routingProfileArnDecoded
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
    }
}

extension CreateSecurityProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case permissions = "Permissions"
        case securityProfileName = "SecurityProfileName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permissionslist0 in permissions {
                try permissionsContainer.encode(permissionslist0)
            }
        }
        if let securityProfileName = securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/security-profiles/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateSecurityProfileInput: Swift.Equatable {
    /// The description of the security profile.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Permissions assigned to the security profile.
    public var permissions: [Swift.String]?
    /// The name of the security profile.
    /// This member is required.
    public var securityProfileName: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        permissions: [Swift.String]? = nil,
        securityProfileName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.permissions = permissions
        self.securityProfileName = securityProfileName
        self.tags = tags
    }
}

struct CreateSecurityProfileInputBody: Swift.Equatable {
    let securityProfileName: Swift.String?
    let description: Swift.String?
    let permissions: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSecurityProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case permissions = "Permissions"
        case securityProfileName = "SecurityProfileName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissions)
        var permissionsDecoded0:[Swift.String]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Swift.String]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSecurityProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSecurityProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSecurityProfileOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSecurityProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSecurityProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityProfileArn = output.securityProfileArn
            self.securityProfileId = output.securityProfileId
        } else {
            self.securityProfileArn = nil
            self.securityProfileId = nil
        }
    }
}

public struct CreateSecurityProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the security profile.
    public var securityProfileArn: Swift.String?
    /// The identifier for the security profle.
    public var securityProfileId: Swift.String?

    public init (
        securityProfileArn: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.securityProfileArn = securityProfileArn
        self.securityProfileId = securityProfileId
    }
}

struct CreateSecurityProfileOutputResponseBody: Swift.Equatable {
    let securityProfileId: Swift.String?
    let securityProfileArn: Swift.String?
}

extension CreateSecurityProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityProfileArn = "SecurityProfileArn"
        case securityProfileId = "SecurityProfileId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileId)
        securityProfileId = securityProfileIdDecoded
        let securityProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileArn)
        securityProfileArn = securityProfileArnDecoded
    }
}

extension CreateUseCaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case useCaseType = "UseCaseType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useCaseType = useCaseType {
            try encodeContainer.encode(useCaseType.rawValue, forKey: .useCaseType)
        }
    }
}

extension CreateUseCaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let integrationAssociationId = integrationAssociationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations/\(integrationAssociationId.urlPercentEncoding())/use-cases"
    }
}

public struct CreateUseCaseInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the integration association.
    /// This member is required.
    public var integrationAssociationId: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of use case to associate to the integration association. Each integration association can have only one of each use case type.
    /// This member is required.
    public var useCaseType: ConnectClientTypes.UseCaseType?

    public init (
        instanceId: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useCaseType: ConnectClientTypes.UseCaseType? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
        self.tags = tags
        self.useCaseType = useCaseType
    }
}

struct CreateUseCaseInputBody: Swift.Equatable {
    let useCaseType: ConnectClientTypes.UseCaseType?
    let tags: [Swift.String:Swift.String]?
}

extension CreateUseCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
        case useCaseType = "UseCaseType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let useCaseTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UseCaseType.self, forKey: .useCaseType)
        useCaseType = useCaseTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUseCaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUseCaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUseCaseOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUseCaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUseCaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.useCaseArn = output.useCaseArn
            self.useCaseId = output.useCaseId
        } else {
            self.useCaseArn = nil
            self.useCaseId = nil
        }
    }
}

public struct CreateUseCaseOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the use case.
    public var useCaseArn: Swift.String?
    /// The identifier of the use case.
    public var useCaseId: Swift.String?

    public init (
        useCaseArn: Swift.String? = nil,
        useCaseId: Swift.String? = nil
    )
    {
        self.useCaseArn = useCaseArn
        self.useCaseId = useCaseId
    }
}

struct CreateUseCaseOutputResponseBody: Swift.Equatable {
    let useCaseId: Swift.String?
    let useCaseArn: Swift.String?
}

extension CreateUseCaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case useCaseArn = "UseCaseArn"
        case useCaseId = "UseCaseId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let useCaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .useCaseId)
        useCaseId = useCaseIdDecoded
        let useCaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .useCaseArn)
        useCaseArn = useCaseArnDecoded
    }
}

extension CreateUserHierarchyGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentGroupId = "ParentGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentGroupId = parentGroupId {
            try encodeContainer.encode(parentGroupId, forKey: .parentGroupId)
        }
    }
}

extension CreateUserHierarchyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/user-hierarchy-groups/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateUserHierarchyGroupInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the user hierarchy group. Must not be more than 100 characters.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier for the parent hierarchy group. The user hierarchy is created at level one if the parent group ID is null.
    public var parentGroupId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentGroupId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.name = name
        self.parentGroupId = parentGroupId
    }
}

struct CreateUserHierarchyGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let parentGroupId: Swift.String?
}

extension CreateUserHierarchyGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentGroupId = "ParentGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parentGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentGroupId)
        parentGroupId = parentGroupIdDecoded
    }
}

extension CreateUserHierarchyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserHierarchyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserHierarchyGroupOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserHierarchyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUserHierarchyGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hierarchyGroupArn = output.hierarchyGroupArn
            self.hierarchyGroupId = output.hierarchyGroupId
        } else {
            self.hierarchyGroupArn = nil
            self.hierarchyGroupId = nil
        }
    }
}

public struct CreateUserHierarchyGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the hierarchy group.
    public var hierarchyGroupArn: Swift.String?
    /// The identifier of the hierarchy group.
    public var hierarchyGroupId: Swift.String?

    public init (
        hierarchyGroupArn: Swift.String? = nil,
        hierarchyGroupId: Swift.String? = nil
    )
    {
        self.hierarchyGroupArn = hierarchyGroupArn
        self.hierarchyGroupId = hierarchyGroupId
    }
}

struct CreateUserHierarchyGroupOutputResponseBody: Swift.Equatable {
    let hierarchyGroupId: Swift.String?
    let hierarchyGroupArn: Swift.String?
}

extension CreateUserHierarchyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyGroupArn = "HierarchyGroupArn"
        case hierarchyGroupId = "HierarchyGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
        let hierarchyGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyGroupArn)
        hierarchyGroupArn = hierarchyGroupArnDecoded
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryUserId = "DirectoryUserId"
        case hierarchyGroupId = "HierarchyGroupId"
        case identityInfo = "IdentityInfo"
        case password = "Password"
        case phoneConfig = "PhoneConfig"
        case routingProfileId = "RoutingProfileId"
        case securityProfileIds = "SecurityProfileIds"
        case tags = "Tags"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryUserId = directoryUserId {
            try encodeContainer.encode(directoryUserId, forKey: .directoryUserId)
        }
        if let hierarchyGroupId = hierarchyGroupId {
            try encodeContainer.encode(hierarchyGroupId, forKey: .hierarchyGroupId)
        }
        if let identityInfo = identityInfo {
            try encodeContainer.encode(identityInfo, forKey: .identityInfo)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let phoneConfig = phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
        if let routingProfileId = routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
        if let securityProfileIds = securityProfileIds {
            var securityProfileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityProfileIds)
            for securityprofileids0 in securityProfileIds {
                try securityProfileIdsContainer.encode(securityprofileids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The identifier of the user account in the directory used for identity management. If Amazon Connect cannot access the directory, you can specify this identifier to authenticate users. If you include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity information is used to authenticate users from your directory. This parameter is required if you are using an existing directory for identity management in Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for identity management and include this parameter, an error is returned.
    public var directoryUserId: Swift.String?
    /// The identifier of the hierarchy group for the user.
    public var hierarchyGroupId: Swift.String?
    /// The information about the identity of the user.
    public var identityInfo: ConnectClientTypes.UserIdentityInfo?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.
    public var password: Swift.String?
    /// The phone settings for the user.
    /// This member is required.
    public var phoneConfig: ConnectClientTypes.UserPhoneConfig?
    /// The identifier of the routing profile for the user.
    /// This member is required.
    public var routingProfileId: Swift.String?
    /// The identifier of the security profile for the user.
    /// This member is required.
    public var securityProfileIds: [Swift.String]?
    /// One or more tags.
    public var tags: [Swift.String:Swift.String]?
    /// The user name for the account. For instances not using SAML for identity management, the user name can include up to 20 characters. If you are using SAML for identity management, the user name can include up to 64 characters from [a-zA-Z0-9_-.\@]+.
    /// This member is required.
    public var username: Swift.String?

    public init (
        directoryUserId: Swift.String? = nil,
        hierarchyGroupId: Swift.String? = nil,
        identityInfo: ConnectClientTypes.UserIdentityInfo? = nil,
        instanceId: Swift.String? = nil,
        password: Swift.String? = nil,
        phoneConfig: ConnectClientTypes.UserPhoneConfig? = nil,
        routingProfileId: Swift.String? = nil,
        securityProfileIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        username: Swift.String? = nil
    )
    {
        self.directoryUserId = directoryUserId
        self.hierarchyGroupId = hierarchyGroupId
        self.identityInfo = identityInfo
        self.instanceId = instanceId
        self.password = password
        self.phoneConfig = phoneConfig
        self.routingProfileId = routingProfileId
        self.securityProfileIds = securityProfileIds
        self.tags = tags
        self.username = username
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let username: Swift.String?
    let password: Swift.String?
    let identityInfo: ConnectClientTypes.UserIdentityInfo?
    let phoneConfig: ConnectClientTypes.UserPhoneConfig?
    let directoryUserId: Swift.String?
    let securityProfileIds: [Swift.String]?
    let routingProfileId: Swift.String?
    let hierarchyGroupId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryUserId = "DirectoryUserId"
        case hierarchyGroupId = "HierarchyGroupId"
        case identityInfo = "IdentityInfo"
        case password = "Password"
        case phoneConfig = "PhoneConfig"
        case routingProfileId = "RoutingProfileId"
        case securityProfileIds = "SecurityProfileIds"
        case tags = "Tags"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let identityInfoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserIdentityInfo.self, forKey: .identityInfo)
        identityInfo = identityInfoDecoded
        let phoneConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserPhoneConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
        let directoryUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryUserId)
        directoryUserId = directoryUserIdDecoded
        let securityProfileIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityProfileIds)
        var securityProfileIdsDecoded0:[Swift.String]? = nil
        if let securityProfileIdsContainer = securityProfileIdsContainer {
            securityProfileIdsDecoded0 = [Swift.String]()
            for string0 in securityProfileIdsContainer {
                if let string0 = string0 {
                    securityProfileIdsDecoded0?.append(string0)
                }
            }
        }
        securityProfileIds = securityProfileIdsDecoded0
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userArn = output.userArn
            self.userId = output.userId
        } else {
            self.userArn = nil
            self.userId = nil
        }
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user account.
    public var userArn: Swift.String?
    /// The identifier of the user account.
    public var userId: Swift.String?

    public init (
        userArn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.userArn = userArn
        self.userId = userId
    }
}

struct CreateUserOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
    let userArn: Swift.String?
}

extension CreateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn = "UserArn"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension ConnectClientTypes.Credentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken = "AccessToken"
        case accessTokenExpiration = "AccessTokenExpiration"
        case refreshToken = "RefreshToken"
        case refreshTokenExpiration = "RefreshTokenExpiration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let accessTokenExpiration = accessTokenExpiration {
            try encodeContainer.encode(accessTokenExpiration.timeIntervalSince1970, forKey: .accessTokenExpiration)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
        if let refreshTokenExpiration = refreshTokenExpiration {
            try encodeContainer.encode(refreshTokenExpiration.timeIntervalSince1970, forKey: .refreshTokenExpiration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let accessTokenExpirationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .accessTokenExpiration)
        accessTokenExpiration = accessTokenExpirationDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let refreshTokenExpirationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .refreshTokenExpiration)
        refreshTokenExpiration = refreshTokenExpirationDecoded
    }
}

extension ConnectClientTypes {
    /// Contains credentials to use for federation.
    public struct Credentials: Swift.Equatable {
        /// An access token generated for a federated user to access Amazon Connect.
        public var accessToken: Swift.String?
        /// A token generated with an expiration time for the session a user is logged in to Amazon Connect.
        public var accessTokenExpiration: ClientRuntime.Date?
        /// Renews a token generated for a user to access the Amazon Connect instance.
        public var refreshToken: Swift.String?
        /// Renews the expiration timer for a generated token.
        public var refreshTokenExpiration: ClientRuntime.Date?

        public init (
            accessToken: Swift.String? = nil,
            accessTokenExpiration: ClientRuntime.Date? = nil,
            refreshToken: Swift.String? = nil,
            refreshTokenExpiration: ClientRuntime.Date? = nil
        )
        {
            self.accessToken = accessToken
            self.accessTokenExpiration = accessTokenExpiration
            self.refreshToken = refreshToken
            self.refreshTokenExpiration = refreshTokenExpiration
        }
    }

}

extension ConnectClientTypes.CurrentMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.CurrentMetricName.self, forKey: .name)
        name = nameDecoded
        let unitDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Unit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a real-time metric. For a description of each metric, see [Real-time Metrics Definitions](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html) in the Amazon Connect Administrator Guide.
    public struct CurrentMetric: Swift.Equatable {
        /// The name of the metric.
        public var name: ConnectClientTypes.CurrentMetricName?
        /// The unit for the metric.
        public var unit: ConnectClientTypes.Unit?

        public init (
            name: ConnectClientTypes.CurrentMetricName? = nil,
            unit: ConnectClientTypes.Unit? = nil
        )
        {
            self.name = name
            self.unit = unit
        }
    }

}

extension ConnectClientTypes.CurrentMetricData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metric = "Metric"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.CurrentMetric.self, forKey: .metric)
        metric = metricDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// Contains the data for a real-time metric.
    public struct CurrentMetricData: Swift.Equatable {
        /// Information about the metric.
        public var metric: ConnectClientTypes.CurrentMetric?
        /// The value of the metric.
        public var value: Swift.Double?

        public init (
            metric: ConnectClientTypes.CurrentMetric? = nil,
            value: Swift.Double? = nil
        )
        {
            self.metric = metric
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// The current metric names.
    public enum CurrentMetricName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentsAfterContactWork
        case agentsAvailable
        case agentsError
        case agentsNonProductive
        case agentsOnline
        case agentsOnCall
        case agentsOnContact
        case agentsStaffed
        case contactsInQueue
        case contactsScheduled
        case oldestContactAge
        case slotsActive
        case slotsAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrentMetricName] {
            return [
                .agentsAfterContactWork,
                .agentsAvailable,
                .agentsError,
                .agentsNonProductive,
                .agentsOnline,
                .agentsOnCall,
                .agentsOnContact,
                .agentsStaffed,
                .contactsInQueue,
                .contactsScheduled,
                .oldestContactAge,
                .slotsActive,
                .slotsAvailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentsAfterContactWork: return "AGENTS_AFTER_CONTACT_WORK"
            case .agentsAvailable: return "AGENTS_AVAILABLE"
            case .agentsError: return "AGENTS_ERROR"
            case .agentsNonProductive: return "AGENTS_NON_PRODUCTIVE"
            case .agentsOnline: return "AGENTS_ONLINE"
            case .agentsOnCall: return "AGENTS_ON_CALL"
            case .agentsOnContact: return "AGENTS_ON_CONTACT"
            case .agentsStaffed: return "AGENTS_STAFFED"
            case .contactsInQueue: return "CONTACTS_IN_QUEUE"
            case .contactsScheduled: return "CONTACTS_SCHEDULED"
            case .oldestContactAge: return "OLDEST_CONTACT_AGE"
            case .slotsActive: return "SLOTS_ACTIVE"
            case .slotsAvailable: return "SLOTS_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CurrentMetricName(rawValue: rawValue) ?? CurrentMetricName.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.CurrentMetricResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collections = "Collections"
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collections = collections {
            var collectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .collections)
            for currentmetricdatacollections0 in collections {
                try collectionsContainer.encode(currentmetricdatacollections0)
            }
        }
        if let dimensions = dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Dimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let collectionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.CurrentMetricData?].self, forKey: .collections)
        var collectionsDecoded0:[ConnectClientTypes.CurrentMetricData]? = nil
        if let collectionsContainer = collectionsContainer {
            collectionsDecoded0 = [ConnectClientTypes.CurrentMetricData]()
            for structure0 in collectionsContainer {
                if let structure0 = structure0 {
                    collectionsDecoded0?.append(structure0)
                }
            }
        }
        collections = collectionsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a set of real-time metrics.
    public struct CurrentMetricResult: Swift.Equatable {
        /// The set of metrics.
        public var collections: [ConnectClientTypes.CurrentMetricData]?
        /// The dimensions for the metrics.
        public var dimensions: ConnectClientTypes.Dimensions?

        public init (
            collections: [ConnectClientTypes.CurrentMetricData]? = nil,
            dimensions: ConnectClientTypes.Dimensions? = nil
        )
        {
            self.collections = collections
            self.dimensions = dimensions
        }
    }

}

extension DeleteContactFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowId = contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())"
    }
}

public struct DeleteContactFlowInput: Swift.Equatable {
    /// The identifier of the contact flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        contactFlowId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.instanceId = instanceId
    }
}

struct DeleteContactFlowInputBody: Swift.Equatable {
}

extension DeleteContactFlowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContactFlowModuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowModuleId = contactFlowModuleId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())/\(contactFlowModuleId.urlPercentEncoding())"
    }
}

public struct DeleteContactFlowModuleInput: Swift.Equatable {
    /// The identifier of the contact flow module.
    /// This member is required.
    public var contactFlowModuleId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        contactFlowModuleId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowModuleId = contactFlowModuleId
        self.instanceId = instanceId
    }
}

struct DeleteContactFlowModuleInputBody: Swift.Equatable {
}

extension DeleteContactFlowModuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContactFlowModuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContactFlowModuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContactFlowModuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContactFlowModuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContactFlowModuleOutputResponse: Swift.Equatable {

}

extension DeleteContactFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContactFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContactFlowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContactFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContactFlowOutputResponse: Swift.Equatable {

}

extension DeleteHoursOfOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let hoursOfOperationId = hoursOfOperationId else {
            return nil
        }
        return "/hours-of-operations/\(instanceId.urlPercentEncoding())/\(hoursOfOperationId.urlPercentEncoding())"
    }
}

public struct DeleteHoursOfOperationInput: Swift.Equatable {
    /// The identifier for the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
    }
}

struct DeleteHoursOfOperationInputBody: Swift.Equatable {
}

extension DeleteHoursOfOperationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteHoursOfOperationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHoursOfOperationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHoursOfOperationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHoursOfOperationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHoursOfOperationOutputResponse: Swift.Equatable {

}

extension DeleteInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())"
    }
}

public struct DeleteInstanceInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DeleteInstanceInputBody: Swift.Equatable {
}

extension DeleteInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInstanceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInstanceOutputResponse: Swift.Equatable {

}

extension DeleteIntegrationAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let integrationAssociationId = integrationAssociationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations/\(integrationAssociationId.urlPercentEncoding())"
    }
}

public struct DeleteIntegrationAssociationInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the integration association.
    /// This member is required.
    public var integrationAssociationId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
    }
}

struct DeleteIntegrationAssociationInputBody: Swift.Equatable {
}

extension DeleteIntegrationAssociationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIntegrationAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIntegrationAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIntegrationAssociationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIntegrationAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIntegrationAssociationOutputResponse: Swift.Equatable {

}

extension DeleteQuickConnectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let quickConnectId = quickConnectId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())/\(quickConnectId.urlPercentEncoding())"
    }
}

public struct DeleteQuickConnectInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the quick connect.
    /// This member is required.
    public var quickConnectId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.quickConnectId = quickConnectId
    }
}

struct DeleteQuickConnectInputBody: Swift.Equatable {
}

extension DeleteQuickConnectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteQuickConnectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteQuickConnectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteQuickConnectOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteQuickConnectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteQuickConnectOutputResponse: Swift.Equatable {

}

extension DeleteSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let securityProfileId = securityProfileId else {
            return nil
        }
        return "/security-profiles/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

public struct DeleteSecurityProfileInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.securityProfileId = securityProfileId
    }
}

struct DeleteSecurityProfileInputBody: Swift.Equatable {
}

extension DeleteSecurityProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSecurityProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSecurityProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSecurityProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSecurityProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSecurityProfileOutputResponse: Swift.Equatable {

}

extension DeleteUseCaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let integrationAssociationId = integrationAssociationId else {
            return nil
        }
        guard let useCaseId = useCaseId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations/\(integrationAssociationId.urlPercentEncoding())/use-cases/\(useCaseId.urlPercentEncoding())"
    }
}

public struct DeleteUseCaseInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the integration association.
    /// This member is required.
    public var integrationAssociationId: Swift.String?
    /// The identifier for the use case.
    /// This member is required.
    public var useCaseId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil,
        useCaseId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
        self.useCaseId = useCaseId
    }
}

struct DeleteUseCaseInputBody: Swift.Equatable {
}

extension DeleteUseCaseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUseCaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUseCaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUseCaseOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUseCaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUseCaseOutputResponse: Swift.Equatable {

}

extension DeleteUserHierarchyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let hierarchyGroupId = hierarchyGroupId else {
            return nil
        }
        return "/user-hierarchy-groups/\(instanceId.urlPercentEncoding())/\(hierarchyGroupId.urlPercentEncoding())"
    }
}

public struct DeleteUserHierarchyGroupInput: Swift.Equatable {
    /// The identifier of the hierarchy group.
    /// This member is required.
    public var hierarchyGroupId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        hierarchyGroupId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
    }
}

struct DeleteUserHierarchyGroupInputBody: Swift.Equatable {
}

extension DeleteUserHierarchyGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserHierarchyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserHierarchyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserHierarchyGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserHierarchyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserHierarchyGroupOutputResponse: Swift.Equatable {

}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct DeleteUserInputBody: Swift.Equatable {
}

extension DeleteUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

}

extension DescribeAgentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let agentStatusId = agentStatusId else {
            return nil
        }
        return "/agent-status/\(instanceId.urlPercentEncoding())/\(agentStatusId.urlPercentEncoding())"
    }
}

public struct DescribeAgentStatusInput: Swift.Equatable {
    /// The identifier for the agent status.
    /// This member is required.
    public var agentStatusId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        agentStatusId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.agentStatusId = agentStatusId
        self.instanceId = instanceId
    }
}

struct DescribeAgentStatusInputBody: Swift.Equatable {
}

extension DescribeAgentStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAgentStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAgentStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAgentStatusOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAgentStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAgentStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentStatus = output.agentStatus
        } else {
            self.agentStatus = nil
        }
    }
}

public struct DescribeAgentStatusOutputResponse: Swift.Equatable {
    /// The agent status.
    public var agentStatus: ConnectClientTypes.AgentStatus?

    public init (
        agentStatus: ConnectClientTypes.AgentStatus? = nil
    )
    {
        self.agentStatus = agentStatus
    }
}

struct DescribeAgentStatusOutputResponseBody: Swift.Equatable {
    let agentStatus: ConnectClientTypes.AgentStatus?
}

extension DescribeAgentStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentStatus = "AgentStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentStatusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
    }
}

extension DescribeContactFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowId = contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())"
    }
}

public struct DescribeContactFlowInput: Swift.Equatable {
    /// The identifier of the contact flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        contactFlowId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.instanceId = instanceId
    }
}

struct DescribeContactFlowInputBody: Swift.Equatable {
}

extension DescribeContactFlowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeContactFlowModuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowModuleId = contactFlowModuleId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())/\(contactFlowModuleId.urlPercentEncoding())"
    }
}

public struct DescribeContactFlowModuleInput: Swift.Equatable {
    /// The identifier of the contact flow module.
    /// This member is required.
    public var contactFlowModuleId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        contactFlowModuleId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowModuleId = contactFlowModuleId
        self.instanceId = instanceId
    }
}

struct DescribeContactFlowModuleInputBody: Swift.Equatable {
}

extension DescribeContactFlowModuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeContactFlowModuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeContactFlowModuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeContactFlowModuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeContactFlowModuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeContactFlowModuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactFlowModule = output.contactFlowModule
        } else {
            self.contactFlowModule = nil
        }
    }
}

public struct DescribeContactFlowModuleOutputResponse: Swift.Equatable {
    /// Information about the contact flow module.
    public var contactFlowModule: ConnectClientTypes.ContactFlowModule?

    public init (
        contactFlowModule: ConnectClientTypes.ContactFlowModule? = nil
    )
    {
        self.contactFlowModule = contactFlowModule
    }
}

struct DescribeContactFlowModuleOutputResponseBody: Swift.Equatable {
    let contactFlowModule: ConnectClientTypes.ContactFlowModule?
}

extension DescribeContactFlowModuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowModule = "ContactFlowModule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowModuleDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowModule.self, forKey: .contactFlowModule)
        contactFlowModule = contactFlowModuleDecoded
    }
}

extension DescribeContactFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeContactFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContactFlowNotPublishedException" : self = .contactFlowNotPublishedException(try ContactFlowNotPublishedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeContactFlowOutputError: Swift.Error, Swift.Equatable {
    case contactFlowNotPublishedException(ContactFlowNotPublishedException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeContactFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeContactFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactFlow = output.contactFlow
        } else {
            self.contactFlow = nil
        }
    }
}

public struct DescribeContactFlowOutputResponse: Swift.Equatable {
    /// Information about the contact flow.
    public var contactFlow: ConnectClientTypes.ContactFlow?

    public init (
        contactFlow: ConnectClientTypes.ContactFlow? = nil
    )
    {
        self.contactFlow = contactFlow
    }
}

struct DescribeContactFlowOutputResponseBody: Swift.Equatable {
    let contactFlow: ConnectClientTypes.ContactFlow?
}

extension DescribeContactFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlow = "ContactFlow"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlow.self, forKey: .contactFlow)
        contactFlow = contactFlowDecoded
    }
}

extension DescribeContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactId = contactId else {
            return nil
        }
        return "/contacts/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

public struct DescribeContactInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

struct DescribeContactInputBody: Swift.Equatable {
}

extension DescribeContactInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeContactOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contact = output.contact
        } else {
            self.contact = nil
        }
    }
}

public struct DescribeContactOutputResponse: Swift.Equatable {
    /// Information about the contact.
    public var contact: ConnectClientTypes.Contact?

    public init (
        contact: ConnectClientTypes.Contact? = nil
    )
    {
        self.contact = contact
    }
}

struct DescribeContactOutputResponseBody: Swift.Equatable {
    let contact: ConnectClientTypes.Contact?
}

extension DescribeContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contact = "Contact"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Contact.self, forKey: .contact)
        contact = contactDecoded
    }
}

extension DescribeHoursOfOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let hoursOfOperationId = hoursOfOperationId else {
            return nil
        }
        return "/hours-of-operations/\(instanceId.urlPercentEncoding())/\(hoursOfOperationId.urlPercentEncoding())"
    }
}

public struct DescribeHoursOfOperationInput: Swift.Equatable {
    /// The identifier for the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
    }
}

struct DescribeHoursOfOperationInputBody: Swift.Equatable {
}

extension DescribeHoursOfOperationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeHoursOfOperationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHoursOfOperationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHoursOfOperationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHoursOfOperationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeHoursOfOperationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hoursOfOperation = output.hoursOfOperation
        } else {
            self.hoursOfOperation = nil
        }
    }
}

public struct DescribeHoursOfOperationOutputResponse: Swift.Equatable {
    /// The hours of operation.
    public var hoursOfOperation: ConnectClientTypes.HoursOfOperation?

    public init (
        hoursOfOperation: ConnectClientTypes.HoursOfOperation? = nil
    )
    {
        self.hoursOfOperation = hoursOfOperation
    }
}

struct DescribeHoursOfOperationOutputResponseBody: Swift.Equatable {
    let hoursOfOperation: ConnectClientTypes.HoursOfOperation?
}

extension DescribeHoursOfOperationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hoursOfOperation = "HoursOfOperation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HoursOfOperation.self, forKey: .hoursOfOperation)
        hoursOfOperation = hoursOfOperationDecoded
    }
}

extension DescribeInstanceAttributeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let attributeType = attributeType else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/attribute/\(attributeType.rawValue.urlPercentEncoding())"
    }
}

public struct DescribeInstanceAttributeInput: Swift.Equatable {
    /// The type of attribute.
    /// This member is required.
    public var attributeType: ConnectClientTypes.InstanceAttributeType?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        attributeType: ConnectClientTypes.InstanceAttributeType? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.attributeType = attributeType
        self.instanceId = instanceId
    }
}

struct DescribeInstanceAttributeInputBody: Swift.Equatable {
}

extension DescribeInstanceAttributeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeInstanceAttributeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceAttributeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceAttributeOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceAttributeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstanceAttributeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attribute = output.attribute
        } else {
            self.attribute = nil
        }
    }
}

public struct DescribeInstanceAttributeOutputResponse: Swift.Equatable {
    /// The type of attribute.
    public var attribute: ConnectClientTypes.Attribute?

    public init (
        attribute: ConnectClientTypes.Attribute? = nil
    )
    {
        self.attribute = attribute
    }
}

struct DescribeInstanceAttributeOutputResponseBody: Swift.Equatable {
    let attribute: ConnectClientTypes.Attribute?
}

extension DescribeInstanceAttributeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute = "Attribute"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Attribute.self, forKey: .attribute)
        attribute = attributeDecoded
    }
}

extension DescribeInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())"
    }
}

public struct DescribeInstanceInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DescribeInstanceInputBody: Swift.Equatable {
}

extension DescribeInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instance = output.instance
        } else {
            self.instance = nil
        }
    }
}

public struct DescribeInstanceOutputResponse: Swift.Equatable {
    /// The name of the instance.
    public var instance: ConnectClientTypes.Instance?

    public init (
        instance: ConnectClientTypes.Instance? = nil
    )
    {
        self.instance = instance
    }
}

struct DescribeInstanceOutputResponseBody: Swift.Equatable {
    let instance: ConnectClientTypes.Instance?
}

extension DescribeInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instance = "Instance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Instance.self, forKey: .instance)
        instance = instanceDecoded
    }
}

extension DescribeInstanceStorageConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceType = resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension DescribeInstanceStorageConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-config/\(associationId.urlPercentEncoding())"
    }
}

public struct DescribeInstanceStorageConfigInput: Swift.Equatable {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?

    public init (
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.resourceType = resourceType
    }
}

struct DescribeInstanceStorageConfigInputBody: Swift.Equatable {
}

extension DescribeInstanceStorageConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeInstanceStorageConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceStorageConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceStorageConfigOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceStorageConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstanceStorageConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.storageConfig = output.storageConfig
        } else {
            self.storageConfig = nil
        }
    }
}

public struct DescribeInstanceStorageConfigOutputResponse: Swift.Equatable {
    /// A valid storage type.
    public var storageConfig: ConnectClientTypes.InstanceStorageConfig?

    public init (
        storageConfig: ConnectClientTypes.InstanceStorageConfig? = nil
    )
    {
        self.storageConfig = storageConfig
    }
}

struct DescribeInstanceStorageConfigOutputResponseBody: Swift.Equatable {
    let storageConfig: ConnectClientTypes.InstanceStorageConfig?
}

extension DescribeInstanceStorageConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageConfig = "StorageConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStorageConfig.self, forKey: .storageConfig)
        storageConfig = storageConfigDecoded
    }
}

extension DescribeQueueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())"
    }
}

public struct DescribeQueueInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
    }
}

struct DescribeQueueInputBody: Swift.Equatable {
}

extension DescribeQueueInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeQueueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeQueueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeQueueOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeQueueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeQueueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queue = output.queue
        } else {
            self.queue = nil
        }
    }
}

public struct DescribeQueueOutputResponse: Swift.Equatable {
    /// The name of the queue.
    public var queue: ConnectClientTypes.Queue?

    public init (
        queue: ConnectClientTypes.Queue? = nil
    )
    {
        self.queue = queue
    }
}

struct DescribeQueueOutputResponseBody: Swift.Equatable {
    let queue: ConnectClientTypes.Queue?
}

extension DescribeQueueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queue = "Queue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Queue.self, forKey: .queue)
        queue = queueDecoded
    }
}

extension DescribeQuickConnectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let quickConnectId = quickConnectId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())/\(quickConnectId.urlPercentEncoding())"
    }
}

public struct DescribeQuickConnectInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the quick connect.
    /// This member is required.
    public var quickConnectId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.quickConnectId = quickConnectId
    }
}

struct DescribeQuickConnectInputBody: Swift.Equatable {
}

extension DescribeQuickConnectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeQuickConnectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeQuickConnectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeQuickConnectOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeQuickConnectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeQuickConnectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.quickConnect = output.quickConnect
        } else {
            self.quickConnect = nil
        }
    }
}

public struct DescribeQuickConnectOutputResponse: Swift.Equatable {
    /// Information about the quick connect.
    public var quickConnect: ConnectClientTypes.QuickConnect?

    public init (
        quickConnect: ConnectClientTypes.QuickConnect? = nil
    )
    {
        self.quickConnect = quickConnect
    }
}

struct DescribeQuickConnectOutputResponseBody: Swift.Equatable {
    let quickConnect: ConnectClientTypes.QuickConnect?
}

extension DescribeQuickConnectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnect = "QuickConnect"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnect.self, forKey: .quickConnect)
        quickConnect = quickConnectDecoded
    }
}

extension DescribeRoutingProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())"
    }
}

public struct DescribeRoutingProfileInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
    }
}

struct DescribeRoutingProfileInputBody: Swift.Equatable {
}

extension DescribeRoutingProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRoutingProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRoutingProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRoutingProfileOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRoutingProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRoutingProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.routingProfile = output.routingProfile
        } else {
            self.routingProfile = nil
        }
    }
}

public struct DescribeRoutingProfileOutputResponse: Swift.Equatable {
    /// The routing profile.
    public var routingProfile: ConnectClientTypes.RoutingProfile?

    public init (
        routingProfile: ConnectClientTypes.RoutingProfile? = nil
    )
    {
        self.routingProfile = routingProfile
    }
}

struct DescribeRoutingProfileOutputResponseBody: Swift.Equatable {
    let routingProfile: ConnectClientTypes.RoutingProfile?
}

extension DescribeRoutingProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingProfile = "RoutingProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfileDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RoutingProfile.self, forKey: .routingProfile)
        routingProfile = routingProfileDecoded
    }
}

extension DescribeSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let securityProfileId = securityProfileId else {
            return nil
        }
        return "/security-profiles/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

public struct DescribeSecurityProfileInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.securityProfileId = securityProfileId
    }
}

struct DescribeSecurityProfileInputBody: Swift.Equatable {
}

extension DescribeSecurityProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSecurityProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSecurityProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSecurityProfileOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSecurityProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSecurityProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityProfile = output.securityProfile
        } else {
            self.securityProfile = nil
        }
    }
}

public struct DescribeSecurityProfileOutputResponse: Swift.Equatable {
    /// The security profile.
    public var securityProfile: ConnectClientTypes.SecurityProfile?

    public init (
        securityProfile: ConnectClientTypes.SecurityProfile? = nil
    )
    {
        self.securityProfile = securityProfile
    }
}

struct DescribeSecurityProfileOutputResponseBody: Swift.Equatable {
    let securityProfile: ConnectClientTypes.SecurityProfile?
}

extension DescribeSecurityProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityProfile = "SecurityProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SecurityProfile.self, forKey: .securityProfile)
        securityProfile = securityProfileDecoded
    }
}

extension DescribeUserHierarchyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let hierarchyGroupId = hierarchyGroupId else {
            return nil
        }
        return "/user-hierarchy-groups/\(instanceId.urlPercentEncoding())/\(hierarchyGroupId.urlPercentEncoding())"
    }
}

public struct DescribeUserHierarchyGroupInput: Swift.Equatable {
    /// The identifier of the hierarchy group.
    /// This member is required.
    public var hierarchyGroupId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        hierarchyGroupId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
    }
}

struct DescribeUserHierarchyGroupInputBody: Swift.Equatable {
}

extension DescribeUserHierarchyGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUserHierarchyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserHierarchyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserHierarchyGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserHierarchyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserHierarchyGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hierarchyGroup = output.hierarchyGroup
        } else {
            self.hierarchyGroup = nil
        }
    }
}

public struct DescribeUserHierarchyGroupOutputResponse: Swift.Equatable {
    /// Information about the hierarchy group.
    public var hierarchyGroup: ConnectClientTypes.HierarchyGroup?

    public init (
        hierarchyGroup: ConnectClientTypes.HierarchyGroup? = nil
    )
    {
        self.hierarchyGroup = hierarchyGroup
    }
}

struct DescribeUserHierarchyGroupOutputResponseBody: Swift.Equatable {
    let hierarchyGroup: ConnectClientTypes.HierarchyGroup?
}

extension DescribeUserHierarchyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyGroup = "HierarchyGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyGroupDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroup.self, forKey: .hierarchyGroup)
        hierarchyGroup = hierarchyGroupDecoded
    }
}

extension DescribeUserHierarchyStructureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/user-hierarchy-structure/\(instanceId.urlPercentEncoding())"
    }
}

public struct DescribeUserHierarchyStructureInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DescribeUserHierarchyStructureInputBody: Swift.Equatable {
}

extension DescribeUserHierarchyStructureInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUserHierarchyStructureOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserHierarchyStructureOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserHierarchyStructureOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserHierarchyStructureOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserHierarchyStructureOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hierarchyStructure = output.hierarchyStructure
        } else {
            self.hierarchyStructure = nil
        }
    }
}

public struct DescribeUserHierarchyStructureOutputResponse: Swift.Equatable {
    /// Information about the hierarchy structure.
    public var hierarchyStructure: ConnectClientTypes.HierarchyStructure?

    public init (
        hierarchyStructure: ConnectClientTypes.HierarchyStructure? = nil
    )
    {
        self.hierarchyStructure = hierarchyStructure
    }
}

struct DescribeUserHierarchyStructureOutputResponseBody: Swift.Equatable {
    let hierarchyStructure: ConnectClientTypes.HierarchyStructure?
}

extension DescribeUserHierarchyStructureOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyStructure = "HierarchyStructure"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyStructureDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyStructure.self, forKey: .hierarchyStructure)
        hierarchyStructure = hierarchyStructureDecoded
    }
}

extension DescribeUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct DescribeUserInputBody: Swift.Equatable {
}

extension DescribeUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct DescribeUserOutputResponse: Swift.Equatable {
    /// Information about the user account and configuration settings.
    public var user: ConnectClientTypes.User?

    public init (
        user: ConnectClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct DescribeUserOutputResponseBody: Swift.Equatable {
    let user: ConnectClientTypes.User?
}

extension DescribeUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

extension DestinationNotAllowedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DestinationNotAllowedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Outbound calls to the destination number are not allowed.
public struct DestinationNotAllowedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message about the outbound calls.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DestinationNotAllowedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DestinationNotAllowedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.Dimensions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
        case queue = "Queue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let queue = queue {
            try encodeContainer.encode(queue, forKey: .queue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueReference.self, forKey: .queue)
        queue = queueDecoded
        let channelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the dimensions for a set of metrics.
    public struct Dimensions: Swift.Equatable {
        /// The channel used for grouping and filters.
        public var channel: ConnectClientTypes.Channel?
        /// Information about the queue for which metrics are returned.
        public var queue: ConnectClientTypes.QueueReference?

        public init (
            channel: ConnectClientTypes.Channel? = nil,
            queue: ConnectClientTypes.QueueReference? = nil
        )
        {
            self.channel = channel
            self.queue = queue
        }
    }

}

extension ConnectClientTypes {
    public enum DirectoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectManaged
        case existingDirectory
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectoryType] {
            return [
                .connectManaged,
                .existingDirectory,
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectManaged: return "CONNECT_MANAGED"
            case .existingDirectory: return "EXISTING_DIRECTORY"
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectoryType(rawValue: rawValue) ?? DirectoryType.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateApprovedOriginInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let origin = origin {
            let originQueryItem = ClientRuntime.URLQueryItem(name: "origin".urlPercentEncoding(), value: Swift.String(origin).urlPercentEncoding())
            items.append(originQueryItem)
        }
        return items
    }
}

extension DisassociateApprovedOriginInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/approved-origin"
    }
}

public struct DisassociateApprovedOriginInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The domain URL of the integrated application.
    /// This member is required.
    public var origin: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        origin: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.origin = origin
    }
}

struct DisassociateApprovedOriginInputBody: Swift.Equatable {
}

extension DisassociateApprovedOriginInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateApprovedOriginOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateApprovedOriginOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateApprovedOriginOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateApprovedOriginOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateApprovedOriginOutputResponse: Swift.Equatable {

}

extension DisassociateBotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
        case lexV2Bot = "LexV2Bot"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexBot = lexBot {
            try encodeContainer.encode(lexBot, forKey: .lexBot)
        }
        if let lexV2Bot = lexV2Bot {
            try encodeContainer.encode(lexV2Bot, forKey: .lexV2Bot)
        }
    }
}

extension DisassociateBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/bot"
    }
}

public struct DisassociateBotInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Configuration information of an Amazon Lex bot.
    public var lexBot: ConnectClientTypes.LexBot?
    /// The Amazon Lex V2 bot to disassociate from the instance.
    public var lexV2Bot: ConnectClientTypes.LexV2Bot?

    public init (
        instanceId: Swift.String? = nil,
        lexBot: ConnectClientTypes.LexBot? = nil,
        lexV2Bot: ConnectClientTypes.LexV2Bot? = nil
    )
    {
        self.instanceId = instanceId
        self.lexBot = lexBot
        self.lexV2Bot = lexV2Bot
    }
}

struct DisassociateBotInputBody: Swift.Equatable {
    let lexBot: ConnectClientTypes.LexBot?
    let lexV2Bot: ConnectClientTypes.LexV2Bot?
}

extension DisassociateBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
        case lexV2Bot = "LexV2Bot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexBot.self, forKey: .lexBot)
        lexBot = lexBotDecoded
        let lexV2BotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexV2Bot.self, forKey: .lexV2Bot)
        lexV2Bot = lexV2BotDecoded
    }
}

extension DisassociateBotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateBotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateBotOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateBotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateBotOutputResponse: Swift.Equatable {

}

extension DisassociateInstanceStorageConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceType = resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension DisassociateInstanceStorageConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-config/\(associationId.urlPercentEncoding())"
    }
}

public struct DisassociateInstanceStorageConfigInput: Swift.Equatable {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?

    public init (
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.resourceType = resourceType
    }
}

struct DisassociateInstanceStorageConfigInputBody: Swift.Equatable {
}

extension DisassociateInstanceStorageConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateInstanceStorageConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateInstanceStorageConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateInstanceStorageConfigOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateInstanceStorageConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateInstanceStorageConfigOutputResponse: Swift.Equatable {

}

extension DisassociateLambdaFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let functionArn = functionArn {
            let functionArnQueryItem = ClientRuntime.URLQueryItem(name: "functionArn".urlPercentEncoding(), value: Swift.String(functionArn).urlPercentEncoding())
            items.append(functionArnQueryItem)
        }
        return items
    }
}

extension DisassociateLambdaFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lambda-function"
    }
}

public struct DisassociateLambdaFunctionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Lambda function being disassociated.
    /// This member is required.
    public var functionArn: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance..
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        functionArn: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.functionArn = functionArn
        self.instanceId = instanceId
    }
}

struct DisassociateLambdaFunctionInputBody: Swift.Equatable {
}

extension DisassociateLambdaFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateLambdaFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateLambdaFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateLambdaFunctionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateLambdaFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateLambdaFunctionOutputResponse: Swift.Equatable {

}

extension DisassociateLexBotInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let lexRegion = lexRegion {
            let lexRegionQueryItem = ClientRuntime.URLQueryItem(name: "lexRegion".urlPercentEncoding(), value: Swift.String(lexRegion).urlPercentEncoding())
            items.append(lexRegionQueryItem)
        }
        if let botName = botName {
            let botNameQueryItem = ClientRuntime.URLQueryItem(name: "botName".urlPercentEncoding(), value: Swift.String(botName).urlPercentEncoding())
            items.append(botNameQueryItem)
        }
        return items
    }
}

extension DisassociateLexBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lex-bot"
    }
}

public struct DisassociateLexBotInput: Swift.Equatable {
    /// The name of the Amazon Lex bot. Maximum character limit of 50.
    /// This member is required.
    public var botName: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The Region in which the Amazon Lex bot has been created.
    /// This member is required.
    public var lexRegion: Swift.String?

    public init (
        botName: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        lexRegion: Swift.String? = nil
    )
    {
        self.botName = botName
        self.instanceId = instanceId
        self.lexRegion = lexRegion
    }
}

struct DisassociateLexBotInputBody: Swift.Equatable {
}

extension DisassociateLexBotInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateLexBotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateLexBotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateLexBotOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateLexBotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateLexBotOutputResponse: Swift.Equatable {

}

extension DisassociateQueueQuickConnectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectIds = "QuickConnectIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quickConnectIds = quickConnectIds {
            var quickConnectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .quickConnectIds)
            for quickconnectslist0 in quickConnectIds {
                try quickConnectIdsContainer.encode(quickconnectslist0)
            }
        }
    }
}

extension DisassociateQueueQuickConnectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/disassociate-quick-connects"
    }
}

public struct DisassociateQueueQuickConnectsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?
    /// The quick connects to disassociate from the queue.
    /// This member is required.
    public var quickConnectIds: [Swift.String]?

    public init (
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        quickConnectIds: [Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
        self.quickConnectIds = quickConnectIds
    }
}

struct DisassociateQueueQuickConnectsInputBody: Swift.Equatable {
    let quickConnectIds: [Swift.String]?
}

extension DisassociateQueueQuickConnectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectIds = "QuickConnectIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .quickConnectIds)
        var quickConnectIdsDecoded0:[Swift.String]? = nil
        if let quickConnectIdsContainer = quickConnectIdsContainer {
            quickConnectIdsDecoded0 = [Swift.String]()
            for string0 in quickConnectIdsContainer {
                if let string0 = string0 {
                    quickConnectIdsDecoded0?.append(string0)
                }
            }
        }
        quickConnectIds = quickConnectIdsDecoded0
    }
}

extension DisassociateQueueQuickConnectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateQueueQuickConnectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateQueueQuickConnectsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateQueueQuickConnectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateQueueQuickConnectsOutputResponse: Swift.Equatable {

}

extension DisassociateRoutingProfileQueuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueReferences = "QueueReferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queueReferences = queueReferences {
            var queueReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueReferences)
            for routingprofilequeuereferencelist0 in queueReferences {
                try queueReferencesContainer.encode(routingprofilequeuereferencelist0)
            }
        }
    }
}

extension DisassociateRoutingProfileQueuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/disassociate-queues"
    }
}

public struct DisassociateRoutingProfileQueuesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The queues to disassociate from this routing profile.
    /// This member is required.
    public var queueReferences: [ConnectClientTypes.RoutingProfileQueueReference]?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        queueReferences: [ConnectClientTypes.RoutingProfileQueueReference]? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueReferences = queueReferences
        self.routingProfileId = routingProfileId
    }
}

struct DisassociateRoutingProfileQueuesInputBody: Swift.Equatable {
    let queueReferences: [ConnectClientTypes.RoutingProfileQueueReference]?
}

extension DisassociateRoutingProfileQueuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueReferences = "QueueReferences"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueReferencesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileQueueReference?].self, forKey: .queueReferences)
        var queueReferencesDecoded0:[ConnectClientTypes.RoutingProfileQueueReference]? = nil
        if let queueReferencesContainer = queueReferencesContainer {
            queueReferencesDecoded0 = [ConnectClientTypes.RoutingProfileQueueReference]()
            for structure0 in queueReferencesContainer {
                if let structure0 = structure0 {
                    queueReferencesDecoded0?.append(structure0)
                }
            }
        }
        queueReferences = queueReferencesDecoded0
    }
}

extension DisassociateRoutingProfileQueuesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateRoutingProfileQueuesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateRoutingProfileQueuesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateRoutingProfileQueuesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateRoutingProfileQueuesOutputResponse: Swift.Equatable {

}

extension DisassociateSecurityKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/security-key/\(associationId.urlPercentEncoding())"
    }
}

public struct DisassociateSecurityKeyInput: Swift.Equatable {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
    }
}

struct DisassociateSecurityKeyInputBody: Swift.Equatable {
}

extension DisassociateSecurityKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateSecurityKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateSecurityKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateSecurityKeyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateSecurityKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateSecurityKeyOutputResponse: Swift.Equatable {

}

extension DuplicateResourceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource with the specified name already exists.
public struct DuplicateResourceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.EncryptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case keyId = "KeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension ConnectClientTypes {
    /// The encryption configuration.
    public struct EncryptionConfig: Swift.Equatable {
        /// The type of encryption.
        /// This member is required.
        public var encryptionType: ConnectClientTypes.EncryptionType?
        /// The full ARN of the encryption key. Be sure to provide the full ARN of the encryption key, not just the ID.
        /// This member is required.
        public var keyId: Swift.String?

        public init (
            encryptionType: ConnectClientTypes.EncryptionType? = nil,
            keyId: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.keyId = keyId
        }
    }

}

extension ConnectClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.Filters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case queues = "Queues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channels0 in channels {
                try channelsContainer.encode(channels0.rawValue)
            }
        }
        if let queues = queues {
            var queuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queues)
            for queues0 in queues {
                try queuesContainer.encode(queues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let channelsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Channel?].self, forKey: .channels)
        var channelsDecoded0:[ConnectClientTypes.Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ConnectClientTypes.Channel]()
            for string0 in channelsContainer {
                if let string0 = string0 {
                    channelsDecoded0?.append(string0)
                }
            }
        }
        channels = channelsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains the filter to apply when retrieving metrics.
    public struct Filters: Swift.Equatable {
        /// The channel to use to filter the metrics.
        public var channels: [ConnectClientTypes.Channel]?
        /// The queues to use to filter the metrics. You can specify up to 100 queues per request.
        public var queues: [Swift.String]?

        public init (
            channels: [ConnectClientTypes.Channel]? = nil,
            queues: [Swift.String]? = nil
        )
        {
            self.channels = channels
            self.queues = queues
        }
    }

}

extension GetContactAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let initialContactId = initialContactId else {
            return nil
        }
        return "/contact/attributes/\(instanceId.urlPercentEncoding())/\(initialContactId.urlPercentEncoding())"
    }
}

public struct GetContactAttributesInput: Swift.Equatable {
    /// The identifier of the initial contact.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct GetContactAttributesInputBody: Swift.Equatable {
}

extension GetContactAttributesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetContactAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactAttributesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContactAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct GetContactAttributesOutputResponse: Swift.Equatable {
    /// Information about the attributes.
    public var attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetContactAttributesOutputResponseBody: Swift.Equatable {
    let attributes: [Swift.String:Swift.String]?
}

extension GetContactAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension GetCurrentMetricDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentMetrics = "CurrentMetrics"
        case filters = "Filters"
        case groupings = "Groupings"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentMetrics = currentMetrics {
            var currentMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .currentMetrics)
            for currentmetrics0 in currentMetrics {
                try currentMetricsContainer.encode(currentmetrics0)
            }
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupings = groupings {
            var groupingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupings)
            for groupings0 in groupings {
                try groupingsContainer.encode(groupings0.rawValue)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetCurrentMetricDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/metrics/current/\(instanceId.urlPercentEncoding())"
    }
}

public struct GetCurrentMetricDataInput: Swift.Equatable {
    /// The metrics to retrieve. Specify the name and unit for each metric. The following metrics are available. For a description of all the metrics, see [Real-time Metrics Definitions](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html) in the Amazon Connect Administrator Guide. AGENTS_AFTER_CONTACT_WORK Unit: COUNT Name in real-time metrics report: [ACW](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#aftercallwork-real-time) AGENTS_AVAILABLE Unit: COUNT Name in real-time metrics report: [Available](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#available-real-time) AGENTS_ERROR Unit: COUNT Name in real-time metrics report: [Error](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#error-real-time) AGENTS_NON_PRODUCTIVE Unit: COUNT Name in real-time metrics report: [NPT (Non-Productive Time)](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#non-productive-time-real-time) AGENTS_ON_CALL Unit: COUNT Name in real-time metrics report: [On contact](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time) AGENTS_ON_CONTACT Unit: COUNT Name in real-time metrics report: [On contact](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time) AGENTS_ONLINE Unit: COUNT Name in real-time metrics report: [Online](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#online-real-time) AGENTS_STAFFED Unit: COUNT Name in real-time metrics report: [Staffed](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#staffed-real-time) CONTACTS_IN_QUEUE Unit: COUNT Name in real-time metrics report: [In queue](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#in-queue-real-time) CONTACTS_SCHEDULED Unit: COUNT Name in real-time metrics report: [Scheduled](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#scheduled-real-time) OLDEST_CONTACT_AGE Unit: SECONDS When you use groupings, Unit says SECONDS and the Value is returned in SECONDS. When you do not use groupings, Unit says SECONDS but the Value is returned in MILLISECONDS. For example, if you get a response like this: { "Metric": { "Name": "OLDEST_CONTACT_AGE", "Unit": "SECONDS" }, "Value": 24113.0 } The actual OLDEST_CONTACT_AGE is 24 seconds. Name in real-time metrics report: [Oldest](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#oldest-real-time) SLOTS_ACTIVE Unit: COUNT Name in real-time metrics report: [Active](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#active-real-time) SLOTS_AVAILABLE Unit: COUNT Name in real-time metrics report: [Availability](https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#availability-real-time)
    /// This member is required.
    public var currentMetrics: [ConnectClientTypes.CurrentMetric]?
    /// The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is retrieved only for the resources associated with the queues or channels included in the filter. You can include both queue IDs and queue ARNs in the same request. VOICE, CHAT, and TASK channels are supported.
    /// This member is required.
    public var filters: ConnectClientTypes.Filters?
    /// The grouping applied to the metrics returned. For example, when grouped by QUEUE, the metrics returned apply to each queue rather than aggregated for all queues. If you group by CHANNEL, you should include a Channels filter. VOICE, CHAT, and TASK channels are supported. If no Grouping is included in the request, a summary of metrics is returned.
    public var groupings: [ConnectClientTypes.Grouping]?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
    public var nextToken: Swift.String?

    public init (
        currentMetrics: [ConnectClientTypes.CurrentMetric]? = nil,
        filters: ConnectClientTypes.Filters? = nil,
        groupings: [ConnectClientTypes.Grouping]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.currentMetrics = currentMetrics
        self.filters = filters
        self.groupings = groupings
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetCurrentMetricDataInputBody: Swift.Equatable {
    let filters: ConnectClientTypes.Filters?
    let groupings: [ConnectClientTypes.Grouping]?
    let currentMetrics: [ConnectClientTypes.CurrentMetric]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension GetCurrentMetricDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentMetrics = "CurrentMetrics"
        case filters = "Filters"
        case groupings = "Groupings"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Filters.self, forKey: .filters)
        filters = filtersDecoded
        let groupingsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Grouping?].self, forKey: .groupings)
        var groupingsDecoded0:[ConnectClientTypes.Grouping]? = nil
        if let groupingsContainer = groupingsContainer {
            groupingsDecoded0 = [ConnectClientTypes.Grouping]()
            for string0 in groupingsContainer {
                if let string0 = string0 {
                    groupingsDecoded0?.append(string0)
                }
            }
        }
        groupings = groupingsDecoded0
        let currentMetricsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.CurrentMetric?].self, forKey: .currentMetrics)
        var currentMetricsDecoded0:[ConnectClientTypes.CurrentMetric]? = nil
        if let currentMetricsContainer = currentMetricsContainer {
            currentMetricsDecoded0 = [ConnectClientTypes.CurrentMetric]()
            for structure0 in currentMetricsContainer {
                if let structure0 = structure0 {
                    currentMetricsDecoded0?.append(structure0)
                }
            }
        }
        currentMetrics = currentMetricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCurrentMetricDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCurrentMetricDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCurrentMetricDataOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCurrentMetricDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCurrentMetricDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSnapshotTime = output.dataSnapshotTime
            self.metricResults = output.metricResults
            self.nextToken = output.nextToken
        } else {
            self.dataSnapshotTime = nil
            self.metricResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetCurrentMetricDataOutputResponse: Swift.Equatable {
    /// The time at which the metrics were retrieved and cached for pagination.
    public var dataSnapshotTime: ClientRuntime.Date?
    /// Information about the real-time metrics.
    public var metricResults: [ConnectClientTypes.CurrentMetricResult]?
    /// If there are additional results, this is the token for the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
    public var nextToken: Swift.String?

    public init (
        dataSnapshotTime: ClientRuntime.Date? = nil,
        metricResults: [ConnectClientTypes.CurrentMetricResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSnapshotTime = dataSnapshotTime
        self.metricResults = metricResults
        self.nextToken = nextToken
    }
}

struct GetCurrentMetricDataOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let metricResults: [ConnectClientTypes.CurrentMetricResult]?
    let dataSnapshotTime: ClientRuntime.Date?
}

extension GetCurrentMetricDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSnapshotTime = "DataSnapshotTime"
        case metricResults = "MetricResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let metricResultsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.CurrentMetricResult?].self, forKey: .metricResults)
        var metricResultsDecoded0:[ConnectClientTypes.CurrentMetricResult]? = nil
        if let metricResultsContainer = metricResultsContainer {
            metricResultsDecoded0 = [ConnectClientTypes.CurrentMetricResult]()
            for structure0 in metricResultsContainer {
                if let structure0 = structure0 {
                    metricResultsDecoded0?.append(structure0)
                }
            }
        }
        metricResults = metricResultsDecoded0
        let dataSnapshotTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dataSnapshotTime)
        dataSnapshotTime = dataSnapshotTimeDecoded
    }
}

extension GetFederationTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/user/federate/\(instanceId.urlPercentEncoding())"
    }
}

public struct GetFederationTokenInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct GetFederationTokenInputBody: Swift.Equatable {
}

extension GetFederationTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFederationTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFederationTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFederationTokenOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFederationTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFederationTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
        } else {
            self.credentials = nil
        }
    }
}

public struct GetFederationTokenOutputResponse: Swift.Equatable {
    /// The credentials to use for federation.
    public var credentials: ConnectClientTypes.Credentials?

    public init (
        credentials: ConnectClientTypes.Credentials? = nil
    )
    {
        self.credentials = credentials
    }
}

struct GetFederationTokenOutputResponseBody: Swift.Equatable {
    let credentials: ConnectClientTypes.Credentials?
}

extension GetFederationTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

extension GetMetricDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case filters = "Filters"
        case groupings = "Groupings"
        case historicalMetrics = "HistoricalMetrics"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupings = groupings {
            var groupingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupings)
            for groupings0 in groupings {
                try groupingsContainer.encode(groupings0.rawValue)
            }
        }
        if let historicalMetrics = historicalMetrics {
            var historicalMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .historicalMetrics)
            for historicalmetrics0 in historicalMetrics {
                try historicalMetricsContainer.encode(historicalmetrics0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

extension GetMetricDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/metrics/historical/\(instanceId.urlPercentEncoding())"
    }
}

public struct GetMetricDataInput: Swift.Equatable {
    /// The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be specified using an interval of 5 minutes, such as 11:00, 11:05, 11:10, and must be later than the start time timestamp. The time range between the start and end time must be less than 24 hours.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is retrieved only for the resources associated with the queues or channels included in the filter. You can include both queue IDs and queue ARNs in the same request. VOICE, CHAT, and TASK channels are supported. To filter by Queues, enter the queue ID/ARN, not the name of the queue.
    /// This member is required.
    public var filters: ConnectClientTypes.Filters?
    /// The grouping applied to the metrics returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values returned apply to the metrics for each queue rather than aggregated for all queues. If no grouping is specified, a summary of metrics for all queues is returned.
    public var groupings: [ConnectClientTypes.Grouping]?
    /// The metrics to retrieve. Specify the name, unit, and statistic for each metric. The following historical metrics are available. For a description of each metric, see [Historical Metrics Definitions](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html) in the Amazon Connect Administrator Guide. This API does not support a contacts incoming metric (there's no CONTACTS_INCOMING metric missing from the documented list). ABANDON_TIME Unit: SECONDS Statistic: AVG AFTER_CONTACT_WORK_TIME Unit: SECONDS Statistic: AVG API_CONTACTS_HANDLED Unit: COUNT Statistic: SUM CALLBACK_CONTACTS_HANDLED Unit: COUNT Statistic: SUM CONTACTS_ABANDONED Unit: COUNT Statistic: SUM CONTACTS_AGENT_HUNG_UP_FIRST Unit: COUNT Statistic: SUM CONTACTS_CONSULTED Unit: COUNT Statistic: SUM CONTACTS_HANDLED Unit: COUNT Statistic: SUM CONTACTS_HANDLED_INCOMING Unit: COUNT Statistic: SUM CONTACTS_HANDLED_OUTBOUND Unit: COUNT Statistic: SUM CONTACTS_HOLD_ABANDONS Unit: COUNT Statistic: SUM CONTACTS_MISSED Unit: COUNT Statistic: SUM CONTACTS_QUEUED Unit: COUNT Statistic: SUM CONTACTS_TRANSFERRED_IN Unit: COUNT Statistic: SUM CONTACTS_TRANSFERRED_IN_FROM_QUEUE Unit: COUNT Statistic: SUM CONTACTS_TRANSFERRED_OUT Unit: COUNT Statistic: SUM CONTACTS_TRANSFERRED_OUT_FROM_QUEUE Unit: COUNT Statistic: SUM HANDLE_TIME Unit: SECONDS Statistic: AVG HOLD_TIME Unit: SECONDS Statistic: AVG INTERACTION_AND_HOLD_TIME Unit: SECONDS Statistic: AVG INTERACTION_TIME Unit: SECONDS Statistic: AVG OCCUPANCY Unit: PERCENT Statistic: AVG QUEUE_ANSWER_TIME Unit: SECONDS Statistic: AVG QUEUED_TIME Unit: SECONDS Statistic: MAX SERVICE_LEVEL You can include up to 20 SERVICE_LEVEL metrics in a request. Unit: PERCENT Statistic: AVG Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than").
    /// This member is required.
    public var historicalMetrics: [ConnectClientTypes.HistoricalMetric]?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be specified using a multiple of 5 minutes, such as 10:05, 10:10, 10:15. The start time cannot be earlier than 24 hours before the time of the request. Historical metrics are available only for 24 hours.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        filters: ConnectClientTypes.Filters? = nil,
        groupings: [ConnectClientTypes.Grouping]? = nil,
        historicalMetrics: [ConnectClientTypes.HistoricalMetric]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.filters = filters
        self.groupings = groupings
        self.historicalMetrics = historicalMetrics
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct GetMetricDataInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let filters: ConnectClientTypes.Filters?
    let groupings: [ConnectClientTypes.Grouping]?
    let historicalMetrics: [ConnectClientTypes.HistoricalMetric]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension GetMetricDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case filters = "Filters"
        case groupings = "Groupings"
        case historicalMetrics = "HistoricalMetrics"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Filters.self, forKey: .filters)
        filters = filtersDecoded
        let groupingsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Grouping?].self, forKey: .groupings)
        var groupingsDecoded0:[ConnectClientTypes.Grouping]? = nil
        if let groupingsContainer = groupingsContainer {
            groupingsDecoded0 = [ConnectClientTypes.Grouping]()
            for string0 in groupingsContainer {
                if let string0 = string0 {
                    groupingsDecoded0?.append(string0)
                }
            }
        }
        groupings = groupingsDecoded0
        let historicalMetricsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HistoricalMetric?].self, forKey: .historicalMetrics)
        var historicalMetricsDecoded0:[ConnectClientTypes.HistoricalMetric]? = nil
        if let historicalMetricsContainer = historicalMetricsContainer {
            historicalMetricsDecoded0 = [ConnectClientTypes.HistoricalMetric]()
            for structure0 in historicalMetricsContainer {
                if let structure0 = structure0 {
                    historicalMetricsDecoded0?.append(structure0)
                }
            }
        }
        historicalMetrics = historicalMetricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetMetricDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMetricDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMetricDataOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMetricDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMetricDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricResults = output.metricResults
            self.nextToken = output.nextToken
        } else {
            self.metricResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetMetricDataOutputResponse: Swift.Equatable {
    /// Information about the historical metrics. If no grouping is specified, a summary of metric data is returned.
    public var metricResults: [ConnectClientTypes.HistoricalMetricResult]?
    /// If there are additional results, this is the token for the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
    public var nextToken: Swift.String?

    public init (
        metricResults: [ConnectClientTypes.HistoricalMetricResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricResults = metricResults
        self.nextToken = nextToken
    }
}

struct GetMetricDataOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let metricResults: [ConnectClientTypes.HistoricalMetricResult]?
}

extension GetMetricDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricResults = "MetricResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let metricResultsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HistoricalMetricResult?].self, forKey: .metricResults)
        var metricResultsDecoded0:[ConnectClientTypes.HistoricalMetricResult]? = nil
        if let metricResultsContainer = metricResultsContainer {
            metricResultsDecoded0 = [ConnectClientTypes.HistoricalMetricResult]()
            for structure0 in metricResultsContainer {
                if let structure0 = structure0 {
                    metricResultsDecoded0?.append(structure0)
                }
            }
        }
        metricResults = metricResultsDecoded0
    }
}

extension ConnectClientTypes {
    public enum Grouping: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case channel
        case queue
        case sdkUnknown(Swift.String)

        public static var allCases: [Grouping] {
            return [
                .channel,
                .queue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .channel: return "CHANNEL"
            case .queue: return "QUEUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Grouping(rawValue: rawValue) ?? Grouping.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.HierarchyGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case hierarchyPath = "HierarchyPath"
        case id = "Id"
        case levelId = "LevelId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let hierarchyPath = hierarchyPath {
            try encodeContainer.encode(hierarchyPath, forKey: .hierarchyPath)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let levelId = levelId {
            try encodeContainer.encode(levelId, forKey: .levelId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let levelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .levelId)
        levelId = levelIdDecoded
        let hierarchyPathDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyPath.self, forKey: .hierarchyPath)
        hierarchyPath = hierarchyPathDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a hierarchy group.
    public struct HierarchyGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public var arn: Swift.String?
        /// Information about the levels in the hierarchy group.
        public var hierarchyPath: ConnectClientTypes.HierarchyPath?
        /// The identifier of the hierarchy group.
        public var id: Swift.String?
        /// The identifier of the level in the hierarchy group.
        public var levelId: Swift.String?
        /// The name of the hierarchy group.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            hierarchyPath: ConnectClientTypes.HierarchyPath? = nil,
            id: Swift.String? = nil,
            levelId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.hierarchyPath = hierarchyPath
            self.id = id
            self.levelId = levelId
            self.name = name
        }
    }

}

extension ConnectClientTypes.HierarchyGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a hierarchy group.
    public struct HierarchyGroupSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public var arn: Swift.String?
        /// The identifier of the hierarchy group.
        public var id: Swift.String?
        /// The name of the hierarchy group.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension ConnectClientTypes.HierarchyLevel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a hierarchy level.
    public struct HierarchyLevel: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the hierarchy level.
        public var arn: Swift.String?
        /// The identifier of the hierarchy level.
        public var id: Swift.String?
        /// The name of the hierarchy level.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension ConnectClientTypes.HierarchyLevelUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the hierarchy level to update.
    public struct HierarchyLevelUpdate: Swift.Equatable {
        /// The name of the user hierarchy level. Must not be more than 50 characters.
        /// This member is required.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ConnectClientTypes.HierarchyPath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case levelFive = "LevelFive"
        case levelFour = "LevelFour"
        case levelOne = "LevelOne"
        case levelThree = "LevelThree"
        case levelTwo = "LevelTwo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let levelFive = levelFive {
            try encodeContainer.encode(levelFive, forKey: .levelFive)
        }
        if let levelFour = levelFour {
            try encodeContainer.encode(levelFour, forKey: .levelFour)
        }
        if let levelOne = levelOne {
            try encodeContainer.encode(levelOne, forKey: .levelOne)
        }
        if let levelThree = levelThree {
            try encodeContainer.encode(levelThree, forKey: .levelThree)
        }
        if let levelTwo = levelTwo {
            try encodeContainer.encode(levelTwo, forKey: .levelTwo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelOneDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummary.self, forKey: .levelOne)
        levelOne = levelOneDecoded
        let levelTwoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummary.self, forKey: .levelTwo)
        levelTwo = levelTwoDecoded
        let levelThreeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummary.self, forKey: .levelThree)
        levelThree = levelThreeDecoded
        let levelFourDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummary.self, forKey: .levelFour)
        levelFour = levelFourDecoded
        let levelFiveDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyGroupSummary.self, forKey: .levelFive)
        levelFive = levelFiveDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the levels of a hierarchy group.
    public struct HierarchyPath: Swift.Equatable {
        /// Information about level five.
        public var levelFive: ConnectClientTypes.HierarchyGroupSummary?
        /// Information about level four.
        public var levelFour: ConnectClientTypes.HierarchyGroupSummary?
        /// Information about level one.
        public var levelOne: ConnectClientTypes.HierarchyGroupSummary?
        /// Information about level three.
        public var levelThree: ConnectClientTypes.HierarchyGroupSummary?
        /// Information about level two.
        public var levelTwo: ConnectClientTypes.HierarchyGroupSummary?

        public init (
            levelFive: ConnectClientTypes.HierarchyGroupSummary? = nil,
            levelFour: ConnectClientTypes.HierarchyGroupSummary? = nil,
            levelOne: ConnectClientTypes.HierarchyGroupSummary? = nil,
            levelThree: ConnectClientTypes.HierarchyGroupSummary? = nil,
            levelTwo: ConnectClientTypes.HierarchyGroupSummary? = nil
        )
        {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }
    }

}

extension ConnectClientTypes.HierarchyStructure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case levelFive = "LevelFive"
        case levelFour = "LevelFour"
        case levelOne = "LevelOne"
        case levelThree = "LevelThree"
        case levelTwo = "LevelTwo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let levelFive = levelFive {
            try encodeContainer.encode(levelFive, forKey: .levelFive)
        }
        if let levelFour = levelFour {
            try encodeContainer.encode(levelFour, forKey: .levelFour)
        }
        if let levelOne = levelOne {
            try encodeContainer.encode(levelOne, forKey: .levelOne)
        }
        if let levelThree = levelThree {
            try encodeContainer.encode(levelThree, forKey: .levelThree)
        }
        if let levelTwo = levelTwo {
            try encodeContainer.encode(levelTwo, forKey: .levelTwo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelOneDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevel.self, forKey: .levelOne)
        levelOne = levelOneDecoded
        let levelTwoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevel.self, forKey: .levelTwo)
        levelTwo = levelTwoDecoded
        let levelThreeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevel.self, forKey: .levelThree)
        levelThree = levelThreeDecoded
        let levelFourDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevel.self, forKey: .levelFour)
        levelFour = levelFourDecoded
        let levelFiveDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevel.self, forKey: .levelFive)
        levelFive = levelFiveDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a hierarchy structure.
    public struct HierarchyStructure: Swift.Equatable {
        /// Information about level five.
        public var levelFive: ConnectClientTypes.HierarchyLevel?
        /// Information about level four.
        public var levelFour: ConnectClientTypes.HierarchyLevel?
        /// Information about level one.
        public var levelOne: ConnectClientTypes.HierarchyLevel?
        /// Information about level three.
        public var levelThree: ConnectClientTypes.HierarchyLevel?
        /// Information about level two.
        public var levelTwo: ConnectClientTypes.HierarchyLevel?

        public init (
            levelFive: ConnectClientTypes.HierarchyLevel? = nil,
            levelFour: ConnectClientTypes.HierarchyLevel? = nil,
            levelOne: ConnectClientTypes.HierarchyLevel? = nil,
            levelThree: ConnectClientTypes.HierarchyLevel? = nil,
            levelTwo: ConnectClientTypes.HierarchyLevel? = nil
        )
        {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }
    }

}

extension ConnectClientTypes.HierarchyStructureUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case levelFive = "LevelFive"
        case levelFour = "LevelFour"
        case levelOne = "LevelOne"
        case levelThree = "LevelThree"
        case levelTwo = "LevelTwo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let levelFive = levelFive {
            try encodeContainer.encode(levelFive, forKey: .levelFive)
        }
        if let levelFour = levelFour {
            try encodeContainer.encode(levelFour, forKey: .levelFour)
        }
        if let levelOne = levelOne {
            try encodeContainer.encode(levelOne, forKey: .levelOne)
        }
        if let levelThree = levelThree {
            try encodeContainer.encode(levelThree, forKey: .levelThree)
        }
        if let levelTwo = levelTwo {
            try encodeContainer.encode(levelTwo, forKey: .levelTwo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelOneDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevelUpdate.self, forKey: .levelOne)
        levelOne = levelOneDecoded
        let levelTwoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevelUpdate.self, forKey: .levelTwo)
        levelTwo = levelTwoDecoded
        let levelThreeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevelUpdate.self, forKey: .levelThree)
        levelThree = levelThreeDecoded
        let levelFourDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevelUpdate.self, forKey: .levelFour)
        levelFour = levelFourDecoded
        let levelFiveDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyLevelUpdate.self, forKey: .levelFive)
        levelFive = levelFiveDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the level hierarchy to update.
    public struct HierarchyStructureUpdate: Swift.Equatable {
        /// The update for level five.
        public var levelFive: ConnectClientTypes.HierarchyLevelUpdate?
        /// The update for level four.
        public var levelFour: ConnectClientTypes.HierarchyLevelUpdate?
        /// The update for level one.
        public var levelOne: ConnectClientTypes.HierarchyLevelUpdate?
        /// The update for level three.
        public var levelThree: ConnectClientTypes.HierarchyLevelUpdate?
        /// The update for level two.
        public var levelTwo: ConnectClientTypes.HierarchyLevelUpdate?

        public init (
            levelFive: ConnectClientTypes.HierarchyLevelUpdate? = nil,
            levelFour: ConnectClientTypes.HierarchyLevelUpdate? = nil,
            levelOne: ConnectClientTypes.HierarchyLevelUpdate? = nil,
            levelThree: ConnectClientTypes.HierarchyLevelUpdate? = nil,
            levelTwo: ConnectClientTypes.HierarchyLevelUpdate? = nil
        )
        {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }
    }

}

extension ConnectClientTypes.HistoricalMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case statistic = "Statistic"
        case threshold = "Threshold"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let statistic = statistic {
            try encodeContainer.encode(statistic.rawValue, forKey: .statistic)
        }
        if let threshold = threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HistoricalMetricName.self, forKey: .name)
        name = nameDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Threshold.self, forKey: .threshold)
        threshold = thresholdDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Statistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let unitDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Unit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a historical metric. For a description of each metric, see [Historical Metrics Definitions](https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html) in the Amazon Connect Administrator Guide.
    public struct HistoricalMetric: Swift.Equatable {
        /// The name of the metric.
        public var name: ConnectClientTypes.HistoricalMetricName?
        /// The statistic for the metric.
        public var statistic: ConnectClientTypes.Statistic?
        /// The threshold for the metric, used with service level metrics.
        public var threshold: ConnectClientTypes.Threshold?
        /// The unit for the metric.
        public var unit: ConnectClientTypes.Unit?

        public init (
            name: ConnectClientTypes.HistoricalMetricName? = nil,
            statistic: ConnectClientTypes.Statistic? = nil,
            threshold: ConnectClientTypes.Threshold? = nil,
            unit: ConnectClientTypes.Unit? = nil
        )
        {
            self.name = name
            self.statistic = statistic
            self.threshold = threshold
            self.unit = unit
        }
    }

}

extension ConnectClientTypes.HistoricalMetricData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metric = "Metric"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HistoricalMetric.self, forKey: .metric)
        metric = metricDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// Contains the data for a historical metric.
    public struct HistoricalMetricData: Swift.Equatable {
        /// Information about the metric.
        public var metric: ConnectClientTypes.HistoricalMetric?
        /// The value of the metric.
        public var value: Swift.Double?

        public init (
            metric: ConnectClientTypes.HistoricalMetric? = nil,
            value: Swift.Double? = nil
        )
        {
            self.metric = metric
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    /// The historical metric names.
    public enum HistoricalMetricName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case abandonTime
        case afterContactWorkTime
        case apiContactsHandled
        case callbackContactsHandled
        case contactsAbandoned
        case contactsAgentHungUpFirst
        case contactsConsulted
        case contactsHandled
        case contactsHandledIncoming
        case contactsHandledOutbound
        case contactsHoldAbandons
        case contactsMissed
        case contactsQueued
        case contactsTransferredIn
        case contactsTransferredInFromQueue
        case contactsTransferredOut
        case contactsTransferredOutFromQueue
        case handleTime
        case holdTime
        case interactionAndHoldTime
        case interactionTime
        case occupancy
        case queuedTime
        case queueAnswerTime
        case serviceLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [HistoricalMetricName] {
            return [
                .abandonTime,
                .afterContactWorkTime,
                .apiContactsHandled,
                .callbackContactsHandled,
                .contactsAbandoned,
                .contactsAgentHungUpFirst,
                .contactsConsulted,
                .contactsHandled,
                .contactsHandledIncoming,
                .contactsHandledOutbound,
                .contactsHoldAbandons,
                .contactsMissed,
                .contactsQueued,
                .contactsTransferredIn,
                .contactsTransferredInFromQueue,
                .contactsTransferredOut,
                .contactsTransferredOutFromQueue,
                .handleTime,
                .holdTime,
                .interactionAndHoldTime,
                .interactionTime,
                .occupancy,
                .queuedTime,
                .queueAnswerTime,
                .serviceLevel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .abandonTime: return "ABANDON_TIME"
            case .afterContactWorkTime: return "AFTER_CONTACT_WORK_TIME"
            case .apiContactsHandled: return "API_CONTACTS_HANDLED"
            case .callbackContactsHandled: return "CALLBACK_CONTACTS_HANDLED"
            case .contactsAbandoned: return "CONTACTS_ABANDONED"
            case .contactsAgentHungUpFirst: return "CONTACTS_AGENT_HUNG_UP_FIRST"
            case .contactsConsulted: return "CONTACTS_CONSULTED"
            case .contactsHandled: return "CONTACTS_HANDLED"
            case .contactsHandledIncoming: return "CONTACTS_HANDLED_INCOMING"
            case .contactsHandledOutbound: return "CONTACTS_HANDLED_OUTBOUND"
            case .contactsHoldAbandons: return "CONTACTS_HOLD_ABANDONS"
            case .contactsMissed: return "CONTACTS_MISSED"
            case .contactsQueued: return "CONTACTS_QUEUED"
            case .contactsTransferredIn: return "CONTACTS_TRANSFERRED_IN"
            case .contactsTransferredInFromQueue: return "CONTACTS_TRANSFERRED_IN_FROM_QUEUE"
            case .contactsTransferredOut: return "CONTACTS_TRANSFERRED_OUT"
            case .contactsTransferredOutFromQueue: return "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE"
            case .handleTime: return "HANDLE_TIME"
            case .holdTime: return "HOLD_TIME"
            case .interactionAndHoldTime: return "INTERACTION_AND_HOLD_TIME"
            case .interactionTime: return "INTERACTION_TIME"
            case .occupancy: return "OCCUPANCY"
            case .queuedTime: return "QUEUED_TIME"
            case .queueAnswerTime: return "QUEUE_ANSWER_TIME"
            case .serviceLevel: return "SERVICE_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HistoricalMetricName(rawValue: rawValue) ?? HistoricalMetricName.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.HistoricalMetricResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collections = "Collections"
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collections = collections {
            var collectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .collections)
            for historicalmetricdatacollections0 in collections {
                try collectionsContainer.encode(historicalmetricdatacollections0)
            }
        }
        if let dimensions = dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Dimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let collectionsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HistoricalMetricData?].self, forKey: .collections)
        var collectionsDecoded0:[ConnectClientTypes.HistoricalMetricData]? = nil
        if let collectionsContainer = collectionsContainer {
            collectionsDecoded0 = [ConnectClientTypes.HistoricalMetricData]()
            for structure0 in collectionsContainer {
                if let structure0 = structure0 {
                    collectionsDecoded0?.append(structure0)
                }
            }
        }
        collections = collectionsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about the historical metrics retrieved.
    public struct HistoricalMetricResult: Swift.Equatable {
        /// The set of metrics.
        public var collections: [ConnectClientTypes.HistoricalMetricData]?
        /// The dimension for the metrics.
        public var dimensions: ConnectClientTypes.Dimensions?

        public init (
            collections: [ConnectClientTypes.HistoricalMetricData]? = nil,
            dimensions: ConnectClientTypes.Dimensions? = nil
        )
        {
            self.collections = collections
            self.dimensions = dimensions
        }
    }

}

extension ConnectClientTypes.HoursOfOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case description = "Description"
        case hoursOfOperationArn = "HoursOfOperationArn"
        case hoursOfOperationId = "HoursOfOperationId"
        case name = "Name"
        case tags = "Tags"
        case timeZone = "TimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            var configContainer = encodeContainer.nestedUnkeyedContainer(forKey: .config)
            for hoursofoperationconfiglist0 in config {
                try configContainer.encode(hoursofoperationconfiglist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hoursOfOperationArn = hoursOfOperationArn {
            try encodeContainer.encode(hoursOfOperationArn, forKey: .hoursOfOperationArn)
        }
        if let hoursOfOperationId = hoursOfOperationId {
            try encodeContainer.encode(hoursOfOperationId, forKey: .hoursOfOperationId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeZone = timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
        let hoursOfOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationArn)
        hoursOfOperationArn = hoursOfOperationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let configContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HoursOfOperationConfig?].self, forKey: .config)
        var configDecoded0:[ConnectClientTypes.HoursOfOperationConfig]? = nil
        if let configContainer = configContainer {
            configDecoded0 = [ConnectClientTypes.HoursOfOperationConfig]()
            for structure0 in configContainer {
                if let structure0 = structure0 {
                    configDecoded0?.append(structure0)
                }
            }
        }
        config = configDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Information about of the hours of operation.
    public struct HoursOfOperation: Swift.Equatable {
        /// Configuration information for the hours of operation.
        public var config: [ConnectClientTypes.HoursOfOperationConfig]?
        /// The description for the hours of operation.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) for the hours of operation.
        public var hoursOfOperationArn: Swift.String?
        /// The identifier for the hours of operation.
        public var hoursOfOperationId: Swift.String?
        /// The name for the hours of operation.
        public var name: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The time zone for the hours of operation.
        public var timeZone: Swift.String?

        public init (
            config: [ConnectClientTypes.HoursOfOperationConfig]? = nil,
            description: Swift.String? = nil,
            hoursOfOperationArn: Swift.String? = nil,
            hoursOfOperationId: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            timeZone: Swift.String? = nil
        )
        {
            self.config = config
            self.description = description
            self.hoursOfOperationArn = hoursOfOperationArn
            self.hoursOfOperationId = hoursOfOperationId
            self.name = name
            self.tags = tags
            self.timeZone = timeZone
        }
    }

}

extension ConnectClientTypes.HoursOfOperationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case day = "Day"
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let day = day {
            try encodeContainer.encode(day.rawValue, forKey: .day)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HoursOfOperationDays.self, forKey: .day)
        day = dayDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HoursOfOperationTimeSlice.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HoursOfOperationTimeSlice.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the hours of operation.
    public struct HoursOfOperationConfig: Swift.Equatable {
        /// The day that the hours of operation applies to.
        /// This member is required.
        public var day: ConnectClientTypes.HoursOfOperationDays?
        /// The end time that your contact center closes.
        /// This member is required.
        public var endTime: ConnectClientTypes.HoursOfOperationTimeSlice?
        /// The start time that your contact center opens.
        /// This member is required.
        public var startTime: ConnectClientTypes.HoursOfOperationTimeSlice?

        public init (
            day: ConnectClientTypes.HoursOfOperationDays? = nil,
            endTime: ConnectClientTypes.HoursOfOperationTimeSlice? = nil,
            startTime: ConnectClientTypes.HoursOfOperationTimeSlice? = nil
        )
        {
            self.day = day
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension ConnectClientTypes {
    public enum HoursOfOperationDays: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [HoursOfOperationDays] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HoursOfOperationDays(rawValue: rawValue) ?? HoursOfOperationDays.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.HoursOfOperationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about hours of operation for a contact center.
    public struct HoursOfOperationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the hours of operation.
        public var arn: Swift.String?
        /// The identifier of the hours of operation.
        public var id: Swift.String?
        /// The name of the hours of operation.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension ConnectClientTypes.HoursOfOperationTimeSlice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hours = "Hours"
        case minutes = "Minutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if hours != 0 {
            try encodeContainer.encode(hours, forKey: .hours)
        }
        if minutes != 0 {
            try encodeContainer.encode(minutes, forKey: .minutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursDecoded = try containerValues.decode(Swift.Int.self, forKey: .hours)
        hours = hoursDecoded
        let minutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .minutes)
        minutes = minutesDecoded
    }
}

extension ConnectClientTypes {
    /// The start time or end time for an hours of operation.
    public struct HoursOfOperationTimeSlice: Swift.Equatable {
        /// The hours.
        /// This member is required.
        public var hours: Swift.Int
        /// The minutes.
        /// This member is required.
        public var minutes: Swift.Int

        public init (
            hours: Swift.Int = 0,
            minutes: Swift.Int = 0
        )
        {
            self.hours = hours
            self.minutes = minutes
        }
    }

}

extension IdempotencyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IdempotencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An entity with the same name already exists.
public struct IdempotencyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.Instance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case identityManagementType = "IdentityManagementType"
        case inboundCallsEnabled = "InboundCallsEnabled"
        case instanceAlias = "InstanceAlias"
        case instanceStatus = "InstanceStatus"
        case outboundCallsEnabled = "OutboundCallsEnabled"
        case serviceRole = "ServiceRole"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identityManagementType = identityManagementType {
            try encodeContainer.encode(identityManagementType.rawValue, forKey: .identityManagementType)
        }
        if let inboundCallsEnabled = inboundCallsEnabled {
            try encodeContainer.encode(inboundCallsEnabled, forKey: .inboundCallsEnabled)
        }
        if let instanceAlias = instanceAlias {
            try encodeContainer.encode(instanceAlias, forKey: .instanceAlias)
        }
        if let instanceStatus = instanceStatus {
            try encodeContainer.encode(instanceStatus.rawValue, forKey: .instanceStatus)
        }
        if let outboundCallsEnabled = outboundCallsEnabled {
            try encodeContainer.encode(outboundCallsEnabled, forKey: .outboundCallsEnabled)
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let identityManagementTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.DirectoryType.self, forKey: .identityManagementType)
        identityManagementType = identityManagementTypeDecoded
        let instanceAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceAlias)
        instanceAlias = instanceAliasDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let instanceStatusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStatus.self, forKey: .instanceStatus)
        instanceStatus = instanceStatusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let inboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCallsEnabled)
        inboundCallsEnabled = inboundCallsEnabledDecoded
        let outboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCallsEnabled)
        outboundCallsEnabled = outboundCallsEnabledDecoded
    }
}

extension ConnectClientTypes {
    /// The Amazon Connect instance.
    public struct Instance: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the instance.
        public var arn: Swift.String?
        /// When the instance was created.
        public var createdTime: ClientRuntime.Date?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public var id: Swift.String?
        /// The identity management type.
        public var identityManagementType: ConnectClientTypes.DirectoryType?
        /// Whether inbound calls are enabled.
        public var inboundCallsEnabled: Swift.Bool?
        /// The alias of instance.
        public var instanceAlias: Swift.String?
        /// The state of the instance.
        public var instanceStatus: ConnectClientTypes.InstanceStatus?
        /// Whether outbound calls are enabled.
        public var outboundCallsEnabled: Swift.Bool?
        /// The service role of the instance.
        public var serviceRole: Swift.String?
        /// Relevant details why the instance was not successfully created.
        public var statusReason: ConnectClientTypes.InstanceStatusReason?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            identityManagementType: ConnectClientTypes.DirectoryType? = nil,
            inboundCallsEnabled: Swift.Bool? = nil,
            instanceAlias: Swift.String? = nil,
            instanceStatus: ConnectClientTypes.InstanceStatus? = nil,
            outboundCallsEnabled: Swift.Bool? = nil,
            serviceRole: Swift.String? = nil,
            statusReason: ConnectClientTypes.InstanceStatusReason? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.identityManagementType = identityManagementType
            self.inboundCallsEnabled = inboundCallsEnabled
            self.instanceAlias = instanceAlias
            self.instanceStatus = instanceStatus
            self.outboundCallsEnabled = outboundCallsEnabled
            self.serviceRole = serviceRole
            self.statusReason = statusReason
        }
    }

}

extension ConnectClientTypes {
    public enum InstanceAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case autoResolveBestVoices
        case contactflowLogs
        case contactLens
        case earlyMedia
        case inboundCalls
        case outboundCalls
        case useCustomTtsVoices
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceAttributeType] {
            return [
                .autoResolveBestVoices,
                .contactflowLogs,
                .contactLens,
                .earlyMedia,
                .inboundCalls,
                .outboundCalls,
                .useCustomTtsVoices,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .autoResolveBestVoices: return "AUTO_RESOLVE_BEST_VOICES"
            case .contactflowLogs: return "CONTACTFLOW_LOGS"
            case .contactLens: return "CONTACT_LENS"
            case .earlyMedia: return "EARLY_MEDIA"
            case .inboundCalls: return "INBOUND_CALLS"
            case .outboundCalls: return "OUTBOUND_CALLS"
            case .useCustomTtsVoices: return "USE_CUSTOM_TTS_VOICES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceAttributeType(rawValue: rawValue) ?? InstanceAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum InstanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creationFailed
        case creationInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStatus] {
            return [
                .active,
                .creationFailed,
                .creationInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceStatus(rawValue: rawValue) ?? InstanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.InstanceStatusReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    /// Relevant details why the instance was not successfully created.
    public struct InstanceStatusReason: Swift.Equatable {
        /// The message.
        public var message: Swift.String?

        public init (
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension ConnectClientTypes.InstanceStorageConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case kinesisFirehoseConfig = "KinesisFirehoseConfig"
        case kinesisStreamConfig = "KinesisStreamConfig"
        case kinesisVideoStreamConfig = "KinesisVideoStreamConfig"
        case s3Config = "S3Config"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let kinesisFirehoseConfig = kinesisFirehoseConfig {
            try encodeContainer.encode(kinesisFirehoseConfig, forKey: .kinesisFirehoseConfig)
        }
        if let kinesisStreamConfig = kinesisStreamConfig {
            try encodeContainer.encode(kinesisStreamConfig, forKey: .kinesisStreamConfig)
        }
        if let kinesisVideoStreamConfig = kinesisVideoStreamConfig {
            try encodeContainer.encode(kinesisVideoStreamConfig, forKey: .kinesisVideoStreamConfig)
        }
        if let s3Config = s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let s3ConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
        let kinesisVideoStreamConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.KinesisVideoStreamConfig.self, forKey: .kinesisVideoStreamConfig)
        kinesisVideoStreamConfig = kinesisVideoStreamConfigDecoded
        let kinesisStreamConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.KinesisStreamConfig.self, forKey: .kinesisStreamConfig)
        kinesisStreamConfig = kinesisStreamConfigDecoded
        let kinesisFirehoseConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.KinesisFirehoseConfig.self, forKey: .kinesisFirehoseConfig)
        kinesisFirehoseConfig = kinesisFirehoseConfigDecoded
    }
}

extension ConnectClientTypes {
    /// The storage configuration for the instance.
    public struct InstanceStorageConfig: Swift.Equatable {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public var associationId: Swift.String?
        /// The configuration of the Kinesis Firehose delivery stream.
        public var kinesisFirehoseConfig: ConnectClientTypes.KinesisFirehoseConfig?
        /// The configuration of the Kinesis data stream.
        public var kinesisStreamConfig: ConnectClientTypes.KinesisStreamConfig?
        /// The configuration of the Kinesis video stream.
        public var kinesisVideoStreamConfig: ConnectClientTypes.KinesisVideoStreamConfig?
        /// The S3 bucket configuration.
        public var s3Config: ConnectClientTypes.S3Config?
        /// A valid storage type.
        /// This member is required.
        public var storageType: ConnectClientTypes.StorageType?

        public init (
            associationId: Swift.String? = nil,
            kinesisFirehoseConfig: ConnectClientTypes.KinesisFirehoseConfig? = nil,
            kinesisStreamConfig: ConnectClientTypes.KinesisStreamConfig? = nil,
            kinesisVideoStreamConfig: ConnectClientTypes.KinesisVideoStreamConfig? = nil,
            s3Config: ConnectClientTypes.S3Config? = nil,
            storageType: ConnectClientTypes.StorageType? = nil
        )
        {
            self.associationId = associationId
            self.kinesisFirehoseConfig = kinesisFirehoseConfig
            self.kinesisStreamConfig = kinesisStreamConfig
            self.kinesisVideoStreamConfig = kinesisVideoStreamConfig
            self.s3Config = s3Config
            self.storageType = storageType
        }
    }

}

extension ConnectClientTypes {
    public enum InstanceStorageResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentEvents
        case callRecordings
        case chatTranscripts
        case contactTraceRecords
        case mediaStreams
        case scheduledReports
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStorageResourceType] {
            return [
                .agentEvents,
                .callRecordings,
                .chatTranscripts,
                .contactTraceRecords,
                .mediaStreams,
                .scheduledReports,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentEvents: return "AGENT_EVENTS"
            case .callRecordings: return "CALL_RECORDINGS"
            case .chatTranscripts: return "CHAT_TRANSCRIPTS"
            case .contactTraceRecords: return "CONTACT_TRACE_RECORDS"
            case .mediaStreams: return "MEDIA_STREAMS"
            case .scheduledReports: return "SCHEDULED_REPORTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceStorageResourceType(rawValue: rawValue) ?? InstanceStorageResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.InstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case identityManagementType = "IdentityManagementType"
        case inboundCallsEnabled = "InboundCallsEnabled"
        case instanceAlias = "InstanceAlias"
        case instanceStatus = "InstanceStatus"
        case outboundCallsEnabled = "OutboundCallsEnabled"
        case serviceRole = "ServiceRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identityManagementType = identityManagementType {
            try encodeContainer.encode(identityManagementType.rawValue, forKey: .identityManagementType)
        }
        if let inboundCallsEnabled = inboundCallsEnabled {
            try encodeContainer.encode(inboundCallsEnabled, forKey: .inboundCallsEnabled)
        }
        if let instanceAlias = instanceAlias {
            try encodeContainer.encode(instanceAlias, forKey: .instanceAlias)
        }
        if let instanceStatus = instanceStatus {
            try encodeContainer.encode(instanceStatus.rawValue, forKey: .instanceStatus)
        }
        if let outboundCallsEnabled = outboundCallsEnabled {
            try encodeContainer.encode(outboundCallsEnabled, forKey: .outboundCallsEnabled)
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let identityManagementTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.DirectoryType.self, forKey: .identityManagementType)
        identityManagementType = identityManagementTypeDecoded
        let instanceAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceAlias)
        instanceAlias = instanceAliasDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let instanceStatusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStatus.self, forKey: .instanceStatus)
        instanceStatus = instanceStatusDecoded
        let inboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCallsEnabled)
        inboundCallsEnabled = inboundCallsEnabledDecoded
        let outboundCallsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCallsEnabled)
        outboundCallsEnabled = outboundCallsEnabledDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the instance.
    public struct InstanceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the instance.
        public var arn: Swift.String?
        /// When the instance was created.
        public var createdTime: ClientRuntime.Date?
        /// The identifier of the instance.
        public var id: Swift.String?
        /// The identity management type of the instance.
        public var identityManagementType: ConnectClientTypes.DirectoryType?
        /// Whether inbound calls are enabled.
        public var inboundCallsEnabled: Swift.Bool?
        /// The alias of the instance.
        public var instanceAlias: Swift.String?
        /// The state of the instance.
        public var instanceStatus: ConnectClientTypes.InstanceStatus?
        /// Whether outbound calls are enabled.
        public var outboundCallsEnabled: Swift.Bool?
        /// The service role of the instance.
        public var serviceRole: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            identityManagementType: ConnectClientTypes.DirectoryType? = nil,
            inboundCallsEnabled: Swift.Bool? = nil,
            instanceAlias: Swift.String? = nil,
            instanceStatus: ConnectClientTypes.InstanceStatus? = nil,
            outboundCallsEnabled: Swift.Bool? = nil,
            serviceRole: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.identityManagementType = identityManagementType
            self.inboundCallsEnabled = inboundCallsEnabled
            self.instanceAlias = instanceAlias
            self.instanceStatus = instanceStatus
            self.outboundCallsEnabled = outboundCallsEnabled
            self.serviceRole = serviceRole
        }
    }

}

extension ConnectClientTypes.IntegrationAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case integrationArn = "IntegrationArn"
        case integrationAssociationArn = "IntegrationAssociationArn"
        case integrationAssociationId = "IntegrationAssociationId"
        case integrationType = "IntegrationType"
        case sourceApplicationName = "SourceApplicationName"
        case sourceApplicationUrl = "SourceApplicationUrl"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let integrationArn = integrationArn {
            try encodeContainer.encode(integrationArn, forKey: .integrationArn)
        }
        if let integrationAssociationArn = integrationAssociationArn {
            try encodeContainer.encode(integrationAssociationArn, forKey: .integrationAssociationArn)
        }
        if let integrationAssociationId = integrationAssociationId {
            try encodeContainer.encode(integrationAssociationId, forKey: .integrationAssociationId)
        }
        if let integrationType = integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let sourceApplicationName = sourceApplicationName {
            try encodeContainer.encode(sourceApplicationName, forKey: .sourceApplicationName)
        }
        if let sourceApplicationUrl = sourceApplicationUrl {
            try encodeContainer.encode(sourceApplicationUrl, forKey: .sourceApplicationUrl)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationAssociationId)
        integrationAssociationId = integrationAssociationIdDecoded
        let integrationAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationAssociationArn)
        integrationAssociationArn = integrationAssociationArnDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationArn)
        integrationArn = integrationArnDecoded
        let sourceApplicationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApplicationUrl)
        sourceApplicationUrl = sourceApplicationUrlDecoded
        let sourceApplicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceApplicationName)
        sourceApplicationName = sourceApplicationNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about the associated AppIntegrations.
    public struct IntegrationAssociationSummary: Swift.Equatable {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public var instanceId: Swift.String?
        /// The Amazon Resource Name (ARN) for the AppIntegration.
        public var integrationArn: Swift.String?
        /// The Amazon Resource Name (ARN) for the AppIntegration association.
        public var integrationAssociationArn: Swift.String?
        /// The identifier for the AppIntegration association.
        public var integrationAssociationId: Swift.String?
        /// The integration type.
        public var integrationType: ConnectClientTypes.IntegrationType?
        /// The user-provided, friendly name for the external application.
        public var sourceApplicationName: Swift.String?
        /// The URL for the external application.
        public var sourceApplicationUrl: Swift.String?
        /// The name of the source.
        public var sourceType: ConnectClientTypes.SourceType?

        public init (
            instanceId: Swift.String? = nil,
            integrationArn: Swift.String? = nil,
            integrationAssociationArn: Swift.String? = nil,
            integrationAssociationId: Swift.String? = nil,
            integrationType: ConnectClientTypes.IntegrationType? = nil,
            sourceApplicationName: Swift.String? = nil,
            sourceApplicationUrl: Swift.String? = nil,
            sourceType: ConnectClientTypes.SourceType? = nil
        )
        {
            self.instanceId = instanceId
            self.integrationArn = integrationArn
            self.integrationAssociationArn = integrationAssociationArn
            self.integrationAssociationId = integrationAssociationId
            self.integrationType = integrationType
            self.sourceApplicationName = sourceApplicationName
            self.sourceApplicationUrl = sourceApplicationUrl
            self.sourceType = sourceType
        }
    }

}

extension ConnectClientTypes {
    public enum IntegrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case event
        case pinpointApp
        case voiceId
        case wisdomAssistant
        case wisdomKnowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationType] {
            return [
                .event,
                .pinpointApp,
                .voiceId,
                .wisdomAssistant,
                .wisdomKnowledgeBase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .event: return "EVENT"
            case .pinpointApp: return "PINPOINT_APP"
            case .voiceId: return "VOICE_ID"
            case .wisdomAssistant: return "WISDOM_ASSISTANT"
            case .wisdomKnowledgeBase: return "WISDOM_KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntegrationType(rawValue: rawValue) ?? IntegrationType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request processing failed because of an error or failure with the service.
public struct InternalServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidContactFlowException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidContactFlowExceptionBody = try responseDecoder.decode(responseBody: data)
            self.problems = output.problems
        } else {
            self.problems = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The contact flow is not valid.
public struct InvalidContactFlowException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The problems with the contact flow. Please fix before trying again.
    public var problems: [ConnectClientTypes.ProblemDetail]?

    public init (
        problems: [ConnectClientTypes.ProblemDetail]? = nil
    )
    {
        self.problems = problems
    }
}

struct InvalidContactFlowExceptionBody: Swift.Equatable {
    let problems: [ConnectClientTypes.ProblemDetail]?
}

extension InvalidContactFlowExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problems
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ProblemDetail?].self, forKey: .problems)
        var problemsDecoded0:[ConnectClientTypes.ProblemDetail]? = nil
        if let problemsContainer = problemsContainer {
            problemsDecoded0 = [ConnectClientTypes.ProblemDetail]()
            for structure0 in problemsContainer {
                if let structure0 = structure0 {
                    problemsDecoded0?.append(structure0)
                }
            }
        }
        problems = problemsDecoded0
    }
}

extension InvalidContactFlowModuleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidContactFlowModuleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.problems = output.problems
        } else {
            self.problems = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The problems with the module. Please fix before trying again.
public struct InvalidContactFlowModuleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var problems: [ConnectClientTypes.ProblemDetail]?

    public init (
        problems: [ConnectClientTypes.ProblemDetail]? = nil
    )
    {
        self.problems = problems
    }
}

struct InvalidContactFlowModuleExceptionBody: Swift.Equatable {
    let problems: [ConnectClientTypes.ProblemDetail]?
}

extension InvalidContactFlowModuleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problems = "Problems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ProblemDetail?].self, forKey: .problems)
        var problemsDecoded0:[ConnectClientTypes.ProblemDetail]? = nil
        if let problemsContainer = problemsContainer {
            problemsDecoded0 = [ConnectClientTypes.ProblemDetail]()
            for structure0 in problemsContainer {
                if let structure0 = structure0 {
                    problemsDecoded0?.append(structure0)
                }
            }
        }
        problems = problemsDecoded0
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the specified parameters are not valid.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message about the parameters.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is not valid.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message about the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.KinesisFirehoseConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firehoseArn = "FirehoseArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firehoseArn = firehoseArn {
            try encodeContainer.encode(firehoseArn, forKey: .firehoseArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firehoseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firehoseArn)
        firehoseArn = firehoseArnDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of a Kinesis Data Firehose delivery stream.
    public struct KinesisFirehoseConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        /// This member is required.
        public var firehoseArn: Swift.String?

        public init (
            firehoseArn: Swift.String? = nil
        )
        {
            self.firehoseArn = firehoseArn
        }
    }

}

extension ConnectClientTypes.KinesisStreamConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of a Kinesis data stream.
    public struct KinesisStreamConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the data stream.
        /// This member is required.
        public var streamArn: Swift.String?

        public init (
            streamArn: Swift.String? = nil
        )
        {
            self.streamArn = streamArn
        }
    }

}

extension ConnectClientTypes.KinesisVideoStreamConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfig = "EncryptionConfig"
        case `prefix` = "Prefix"
        case retentionPeriodHours = "RetentionPeriodHours"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfig = encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let `prefix` = `prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if retentionPeriodHours != 0 {
            try encodeContainer.encode(retentionPeriodHours, forKey: .retentionPeriodHours)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let retentionPeriodHoursDecoded = try containerValues.decode(Swift.Int.self, forKey: .retentionPeriodHours)
        retentionPeriodHours = retentionPeriodHoursDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of a Kinesis video stream.
    public struct KinesisVideoStreamConfig: Swift.Equatable {
        /// The encryption configuration.
        /// This member is required.
        public var encryptionConfig: ConnectClientTypes.EncryptionConfig?
        /// The prefix of the video stream.
        /// This member is required.
        public var `prefix`: Swift.String?
        /// The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. The default value is 0, indicating that the stream does not persist data.
        /// This member is required.
        public var retentionPeriodHours: Swift.Int

        public init (
            encryptionConfig: ConnectClientTypes.EncryptionConfig? = nil,
            `prefix`: Swift.String? = nil,
            retentionPeriodHours: Swift.Int = 0
        )
        {
            self.encryptionConfig = encryptionConfig
            self.`prefix` = `prefix`
            self.retentionPeriodHours = retentionPeriodHours
        }
    }

}

extension ConnectClientTypes.LexBot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexRegion = "LexRegion"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexRegion = lexRegion {
            try encodeContainer.encode(lexRegion, forKey: .lexRegion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lexRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lexRegion)
        lexRegion = lexRegionDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of an Amazon Lex bot.
    public struct LexBot: Swift.Equatable {
        /// The Region that the Amazon Lex bot was created in.
        public var lexRegion: Swift.String?
        /// The name of the Amazon Lex bot.
        public var name: Swift.String?

        public init (
            lexRegion: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.lexRegion = lexRegion
            self.name = name
        }
    }

}

extension ConnectClientTypes.LexBotConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBot = "LexBot"
        case lexV2Bot = "LexV2Bot"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lexBot = lexBot {
            try encodeContainer.encode(lexBot, forKey: .lexBot)
        }
        if let lexV2Bot = lexV2Bot {
            try encodeContainer.encode(lexV2Bot, forKey: .lexV2Bot)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexBot.self, forKey: .lexBot)
        lexBot = lexBotDecoded
        let lexV2BotDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.LexV2Bot.self, forKey: .lexV2Bot)
        lexV2Bot = lexV2BotDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of an Amazon Lex or Amazon Lex V2 bot.
    public struct LexBotConfig: Swift.Equatable {
        /// Configuration information of an Amazon Lex bot.
        public var lexBot: ConnectClientTypes.LexBot?
        /// Configuration information of an Amazon Lex V2 bot.
        public var lexV2Bot: ConnectClientTypes.LexV2Bot?

        public init (
            lexBot: ConnectClientTypes.LexBot? = nil,
            lexV2Bot: ConnectClientTypes.LexV2Bot? = nil
        )
        {
            self.lexBot = lexBot
            self.lexV2Bot = lexV2Bot
        }
    }

}

extension ConnectClientTypes.LexV2Bot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasArn = aliasArn {
            try encodeContainer.encode(aliasArn, forKey: .aliasArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of an Amazon Lex V2 bot.
    public struct LexV2Bot: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.
        public var aliasArn: Swift.String?

        public init (
            aliasArn: Swift.String? = nil
        )
        {
            self.aliasArn = aliasArn
        }
    }

}

extension ConnectClientTypes {
    public enum LexVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case v1
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [LexVersion] {
            return [
                .v1,
                .v2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V1"
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LexVersion(rawValue: rawValue) ?? LexVersion.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The allowed limit for the resource has been exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message about the limit.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAgentStatusesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let agentStatusTypes = agentStatusTypes {
            agentStatusTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "AgentStatusTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListAgentStatusesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/agent-status/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListAgentStatusesInput: Swift.Equatable {
    /// Available agent status types.
    public var agentStatusTypes: [ConnectClientTypes.AgentStatusType]?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        agentStatusTypes: [ConnectClientTypes.AgentStatusType]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.agentStatusTypes = agentStatusTypes
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentStatusesInputBody: Swift.Equatable {
}

extension ListAgentStatusesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAgentStatusesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAgentStatusesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAgentStatusesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAgentStatusesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAgentStatusesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentStatusSummaryList = output.agentStatusSummaryList
            self.nextToken = output.nextToken
        } else {
            self.agentStatusSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAgentStatusesOutputResponse: Swift.Equatable {
    /// A summary of agent statuses.
    public var agentStatusSummaryList: [ConnectClientTypes.AgentStatusSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        agentStatusSummaryList: [ConnectClientTypes.AgentStatusSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentStatusSummaryList = agentStatusSummaryList
        self.nextToken = nextToken
    }
}

struct ListAgentStatusesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let agentStatusSummaryList: [ConnectClientTypes.AgentStatusSummary]?
}

extension ListAgentStatusesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentStatusSummaryList = "AgentStatusSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let agentStatusSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.AgentStatusSummary?].self, forKey: .agentStatusSummaryList)
        var agentStatusSummaryListDecoded0:[ConnectClientTypes.AgentStatusSummary]? = nil
        if let agentStatusSummaryListContainer = agentStatusSummaryListContainer {
            agentStatusSummaryListDecoded0 = [ConnectClientTypes.AgentStatusSummary]()
            for structure0 in agentStatusSummaryListContainer {
                if let structure0 = structure0 {
                    agentStatusSummaryListDecoded0?.append(structure0)
                }
            }
        }
        agentStatusSummaryList = agentStatusSummaryListDecoded0
    }
}

extension ListApprovedOriginsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListApprovedOriginsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/approved-origins"
    }
}

public struct ListApprovedOriginsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApprovedOriginsInputBody: Swift.Equatable {
}

extension ListApprovedOriginsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApprovedOriginsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApprovedOriginsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApprovedOriginsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApprovedOriginsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApprovedOriginsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.origins = output.origins
        } else {
            self.nextToken = nil
            self.origins = nil
        }
    }
}

public struct ListApprovedOriginsOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The approved origins.
    public var origins: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        origins: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.origins = origins
    }
}

struct ListApprovedOriginsOutputResponseBody: Swift.Equatable {
    let origins: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListApprovedOriginsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case origins = "Origins"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .origins)
        var originsDecoded0:[Swift.String]? = nil
        if let originsContainer = originsContainer {
            originsDecoded0 = [Swift.String]()
            for string0 in originsContainer {
                if let string0 = string0 {
                    originsDecoded0?.append(string0)
                }
            }
        }
        origins = originsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBotsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let lexVersion = lexVersion {
            let lexVersionQueryItem = ClientRuntime.URLQueryItem(name: "lexVersion".urlPercentEncoding(), value: Swift.String(lexVersion.rawValue).urlPercentEncoding())
            items.append(lexVersionQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/bots"
    }
}

public struct ListBotsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The version of Amazon Lex or Amazon Lex V2.
    /// This member is required.
    public var lexVersion: ConnectClientTypes.LexVersion?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        lexVersion: ConnectClientTypes.LexVersion? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.lexVersion = lexVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBotsInputBody: Swift.Equatable {
}

extension ListBotsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBotsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lexBots = output.lexBots
            self.nextToken = output.nextToken
        } else {
            self.lexBots = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotsOutputResponse: Swift.Equatable {
    /// The names and Regions of the Amazon Lex or Amazon Lex V2 bots associated with the specified instance.
    public var lexBots: [ConnectClientTypes.LexBotConfig]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        lexBots: [ConnectClientTypes.LexBotConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lexBots = lexBots
        self.nextToken = nextToken
    }
}

struct ListBotsOutputResponseBody: Swift.Equatable {
    let lexBots: [ConnectClientTypes.LexBotConfig]?
    let nextToken: Swift.String?
}

extension ListBotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBots = "LexBots"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.LexBotConfig?].self, forKey: .lexBots)
        var lexBotsDecoded0:[ConnectClientTypes.LexBotConfig]? = nil
        if let lexBotsContainer = lexBotsContainer {
            lexBotsDecoded0 = [ConnectClientTypes.LexBotConfig]()
            for structure0 in lexBotsContainer {
                if let structure0 = structure0 {
                    lexBotsDecoded0?.append(structure0)
                }
            }
        }
        lexBots = lexBotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContactFlowModulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let contactFlowModuleState = contactFlowModuleState {
            let contactFlowModuleStateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(contactFlowModuleState.rawValue).urlPercentEncoding())
            items.append(contactFlowModuleStateQueryItem)
        }
        return items
    }
}

extension ListContactFlowModulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/contact-flow-modules-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListContactFlowModulesInput: Swift.Equatable {
    /// The state of the contact flow module.
    public var contactFlowModuleState: ConnectClientTypes.ContactFlowModuleState?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        contactFlowModuleState: ConnectClientTypes.ContactFlowModuleState? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.contactFlowModuleState = contactFlowModuleState
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContactFlowModulesInputBody: Swift.Equatable {
}

extension ListContactFlowModulesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListContactFlowModulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactFlowModulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactFlowModulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactFlowModulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContactFlowModulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactFlowModulesSummaryList = output.contactFlowModulesSummaryList
            self.nextToken = output.nextToken
        } else {
            self.contactFlowModulesSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactFlowModulesOutputResponse: Swift.Equatable {
    /// Information about the contact flow module.
    public var contactFlowModulesSummaryList: [ConnectClientTypes.ContactFlowModuleSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        contactFlowModulesSummaryList: [ConnectClientTypes.ContactFlowModuleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactFlowModulesSummaryList = contactFlowModulesSummaryList
        self.nextToken = nextToken
    }
}

struct ListContactFlowModulesOutputResponseBody: Swift.Equatable {
    let contactFlowModulesSummaryList: [ConnectClientTypes.ContactFlowModuleSummary]?
    let nextToken: Swift.String?
}

extension ListContactFlowModulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowModulesSummaryList = "ContactFlowModulesSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowModulesSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ContactFlowModuleSummary?].self, forKey: .contactFlowModulesSummaryList)
        var contactFlowModulesSummaryListDecoded0:[ConnectClientTypes.ContactFlowModuleSummary]? = nil
        if let contactFlowModulesSummaryListContainer = contactFlowModulesSummaryListContainer {
            contactFlowModulesSummaryListDecoded0 = [ConnectClientTypes.ContactFlowModuleSummary]()
            for structure0 in contactFlowModulesSummaryListContainer {
                if let structure0 = structure0 {
                    contactFlowModulesSummaryListDecoded0?.append(structure0)
                }
            }
        }
        contactFlowModulesSummaryList = contactFlowModulesSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContactFlowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let contactFlowTypes = contactFlowTypes {
            contactFlowTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "contactFlowTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListContactFlowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/contact-flows-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListContactFlowsInput: Swift.Equatable {
    /// The type of contact flow.
    public var contactFlowTypes: [ConnectClientTypes.ContactFlowType]?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        contactFlowTypes: [ConnectClientTypes.ContactFlowType]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.contactFlowTypes = contactFlowTypes
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContactFlowsInputBody: Swift.Equatable {
}

extension ListContactFlowsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListContactFlowsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactFlowsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactFlowsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactFlowsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContactFlowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactFlowSummaryList = output.contactFlowSummaryList
            self.nextToken = output.nextToken
        } else {
            self.contactFlowSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactFlowsOutputResponse: Swift.Equatable {
    /// Information about the contact flows.
    public var contactFlowSummaryList: [ConnectClientTypes.ContactFlowSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        contactFlowSummaryList: [ConnectClientTypes.ContactFlowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactFlowSummaryList = contactFlowSummaryList
        self.nextToken = nextToken
    }
}

struct ListContactFlowsOutputResponseBody: Swift.Equatable {
    let contactFlowSummaryList: [ConnectClientTypes.ContactFlowSummary]?
    let nextToken: Swift.String?
}

extension ListContactFlowsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowSummaryList = "ContactFlowSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactFlowSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ContactFlowSummary?].self, forKey: .contactFlowSummaryList)
        var contactFlowSummaryListDecoded0:[ConnectClientTypes.ContactFlowSummary]? = nil
        if let contactFlowSummaryListContainer = contactFlowSummaryListContainer {
            contactFlowSummaryListDecoded0 = [ConnectClientTypes.ContactFlowSummary]()
            for structure0 in contactFlowSummaryListContainer {
                if let structure0 = structure0 {
                    contactFlowSummaryListDecoded0?.append(structure0)
                }
            }
        }
        contactFlowSummaryList = contactFlowSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContactReferencesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let referenceTypes = referenceTypes {
            referenceTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "referenceTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListContactReferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactId = contactId else {
            return nil
        }
        return "/contact/references/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

public struct ListContactReferencesInput: Swift.Equatable {
    /// The identifier of the initial contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. This is not expected to be set, because the value returned in the previous response is always null.
    public var nextToken: Swift.String?
    /// The type of reference.
    /// This member is required.
    public var referenceTypes: [ConnectClientTypes.ReferenceType]?

    public init (
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        referenceTypes: [ConnectClientTypes.ReferenceType]? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.nextToken = nextToken
        self.referenceTypes = referenceTypes
    }
}

struct ListContactReferencesInputBody: Swift.Equatable {
}

extension ListContactReferencesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListContactReferencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactReferencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactReferencesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactReferencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContactReferencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.referenceSummaryList = output.referenceSummaryList
        } else {
            self.nextToken = nil
            self.referenceSummaryList = nil
        }
    }
}

public struct ListContactReferencesOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results. This is always returned as null in the response.
    public var nextToken: Swift.String?
    /// Information about the contact flows.
    public var referenceSummaryList: [ConnectClientTypes.ReferenceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        referenceSummaryList: [ConnectClientTypes.ReferenceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.referenceSummaryList = referenceSummaryList
    }
}

struct ListContactReferencesOutputResponseBody: Swift.Equatable {
    let referenceSummaryList: [ConnectClientTypes.ReferenceSummary]?
    let nextToken: Swift.String?
}

extension ListContactReferencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case referenceSummaryList = "ReferenceSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.ReferenceSummary?].self, forKey: .referenceSummaryList)
        var referenceSummaryListDecoded0:[ConnectClientTypes.ReferenceSummary]? = nil
        if let referenceSummaryListContainer = referenceSummaryListContainer {
            referenceSummaryListDecoded0 = [ConnectClientTypes.ReferenceSummary]()
            for union0 in referenceSummaryListContainer {
                if let union0 = union0 {
                    referenceSummaryListDecoded0?.append(union0)
                }
            }
        }
        referenceSummaryList = referenceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHoursOfOperationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListHoursOfOperationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/hours-of-operations-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListHoursOfOperationsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHoursOfOperationsInputBody: Swift.Equatable {
}

extension ListHoursOfOperationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListHoursOfOperationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHoursOfOperationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHoursOfOperationsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHoursOfOperationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListHoursOfOperationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hoursOfOperationSummaryList = output.hoursOfOperationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.hoursOfOperationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListHoursOfOperationsOutputResponse: Swift.Equatable {
    /// Information about the hours of operation.
    public var hoursOfOperationSummaryList: [ConnectClientTypes.HoursOfOperationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        hoursOfOperationSummaryList: [ConnectClientTypes.HoursOfOperationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hoursOfOperationSummaryList = hoursOfOperationSummaryList
        self.nextToken = nextToken
    }
}

struct ListHoursOfOperationsOutputResponseBody: Swift.Equatable {
    let hoursOfOperationSummaryList: [ConnectClientTypes.HoursOfOperationSummary]?
    let nextToken: Swift.String?
}

extension ListHoursOfOperationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hoursOfOperationSummaryList = "HoursOfOperationSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HoursOfOperationSummary?].self, forKey: .hoursOfOperationSummaryList)
        var hoursOfOperationSummaryListDecoded0:[ConnectClientTypes.HoursOfOperationSummary]? = nil
        if let hoursOfOperationSummaryListContainer = hoursOfOperationSummaryListContainer {
            hoursOfOperationSummaryListDecoded0 = [ConnectClientTypes.HoursOfOperationSummary]()
            for structure0 in hoursOfOperationSummaryListContainer {
                if let structure0 = structure0 {
                    hoursOfOperationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        hoursOfOperationSummaryList = hoursOfOperationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstanceAttributesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListInstanceAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/attributes"
    }
}

public struct ListInstanceAttributesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstanceAttributesInputBody: Swift.Equatable {
}

extension ListInstanceAttributesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInstanceAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstanceAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstanceAttributesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInstanceAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
            self.nextToken = output.nextToken
        } else {
            self.attributes = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstanceAttributesOutputResponse: Swift.Equatable {
    /// The attribute types.
    public var attributes: [ConnectClientTypes.Attribute]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        attributes: [ConnectClientTypes.Attribute]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

struct ListInstanceAttributesOutputResponseBody: Swift.Equatable {
    let attributes: [ConnectClientTypes.Attribute]?
    let nextToken: Swift.String?
}

extension ListInstanceAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[ConnectClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ConnectClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstanceStorageConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let resourceType = resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension ListInstanceStorageConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-configs"
    }
}

public struct ListInstanceStorageConfigsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListInstanceStorageConfigsInputBody: Swift.Equatable {
}

extension ListInstanceStorageConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInstanceStorageConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstanceStorageConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstanceStorageConfigsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceStorageConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInstanceStorageConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.storageConfigs = output.storageConfigs
        } else {
            self.nextToken = nil
            self.storageConfigs = nil
        }
    }
}

public struct ListInstanceStorageConfigsOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// A valid storage type.
    public var storageConfigs: [ConnectClientTypes.InstanceStorageConfig]?

    public init (
        nextToken: Swift.String? = nil,
        storageConfigs: [ConnectClientTypes.InstanceStorageConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageConfigs = storageConfigs
    }
}

struct ListInstanceStorageConfigsOutputResponseBody: Swift.Equatable {
    let storageConfigs: [ConnectClientTypes.InstanceStorageConfig]?
    let nextToken: Swift.String?
}

extension ListInstanceStorageConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case storageConfigs = "StorageConfigs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.InstanceStorageConfig?].self, forKey: .storageConfigs)
        var storageConfigsDecoded0:[ConnectClientTypes.InstanceStorageConfig]? = nil
        if let storageConfigsContainer = storageConfigsContainer {
            storageConfigsDecoded0 = [ConnectClientTypes.InstanceStorageConfig]()
            for structure0 in storageConfigsContainer {
                if let structure0 = structure0 {
                    storageConfigsDecoded0?.append(structure0)
                }
            }
        }
        storageConfigs = storageConfigsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/instance"
    }
}

public struct ListInstancesInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstancesInputBody: Swift.Equatable {
}

extension ListInstancesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstancesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceSummaryList = output.instanceSummaryList
            self.nextToken = output.nextToken
        } else {
            self.instanceSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutputResponse: Swift.Equatable {
    /// Information about the instances.
    public var instanceSummaryList: [ConnectClientTypes.InstanceSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceSummaryList: [ConnectClientTypes.InstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceSummaryList = instanceSummaryList
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputResponseBody: Swift.Equatable {
    let instanceSummaryList: [ConnectClientTypes.InstanceSummary]?
    let nextToken: Swift.String?
}

extension ListInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceSummaryList = "InstanceSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.InstanceSummary?].self, forKey: .instanceSummaryList)
        var instanceSummaryListDecoded0:[ConnectClientTypes.InstanceSummary]? = nil
        if let instanceSummaryListContainer = instanceSummaryListContainer {
            instanceSummaryListDecoded0 = [ConnectClientTypes.InstanceSummary]()
            for structure0 in instanceSummaryListContainer {
                if let structure0 = structure0 {
                    instanceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        instanceSummaryList = instanceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIntegrationAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let integrationType = integrationType {
            let integrationTypeQueryItem = ClientRuntime.URLQueryItem(name: "integrationType".urlPercentEncoding(), value: Swift.String(integrationType.rawValue).urlPercentEncoding())
            items.append(integrationTypeQueryItem)
        }
        return items
    }
}

extension ListIntegrationAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations"
    }
}

public struct ListIntegrationAssociationsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The integration type.
    public var integrationType: ConnectClientTypes.IntegrationType?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        integrationType: ConnectClientTypes.IntegrationType? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationType = integrationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIntegrationAssociationsInputBody: Swift.Equatable {
}

extension ListIntegrationAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListIntegrationAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIntegrationAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIntegrationAssociationsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIntegrationAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIntegrationAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.integrationAssociationSummaryList = output.integrationAssociationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.integrationAssociationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListIntegrationAssociationsOutputResponse: Swift.Equatable {
    /// The associations.
    public var integrationAssociationSummaryList: [ConnectClientTypes.IntegrationAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        integrationAssociationSummaryList: [ConnectClientTypes.IntegrationAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.integrationAssociationSummaryList = integrationAssociationSummaryList
        self.nextToken = nextToken
    }
}

struct ListIntegrationAssociationsOutputResponseBody: Swift.Equatable {
    let integrationAssociationSummaryList: [ConnectClientTypes.IntegrationAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListIntegrationAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integrationAssociationSummaryList = "IntegrationAssociationSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationAssociationSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.IntegrationAssociationSummary?].self, forKey: .integrationAssociationSummaryList)
        var integrationAssociationSummaryListDecoded0:[ConnectClientTypes.IntegrationAssociationSummary]? = nil
        if let integrationAssociationSummaryListContainer = integrationAssociationSummaryListContainer {
            integrationAssociationSummaryListDecoded0 = [ConnectClientTypes.IntegrationAssociationSummary]()
            for structure0 in integrationAssociationSummaryListContainer {
                if let structure0 = structure0 {
                    integrationAssociationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        integrationAssociationSummaryList = integrationAssociationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLambdaFunctionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLambdaFunctionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lambda-functions"
    }
}

public struct ListLambdaFunctionsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLambdaFunctionsInputBody: Swift.Equatable {
}

extension ListLambdaFunctionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLambdaFunctionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLambdaFunctionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLambdaFunctionsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLambdaFunctionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLambdaFunctionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lambdaFunctions = output.lambdaFunctions
            self.nextToken = output.nextToken
        } else {
            self.lambdaFunctions = nil
            self.nextToken = nil
        }
    }
}

public struct ListLambdaFunctionsOutputResponse: Swift.Equatable {
    /// The Lambdafunction ARNs associated with the specified instance.
    public var lambdaFunctions: [Swift.String]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        lambdaFunctions: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lambdaFunctions = lambdaFunctions
        self.nextToken = nextToken
    }
}

struct ListLambdaFunctionsOutputResponseBody: Swift.Equatable {
    let lambdaFunctions: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListLambdaFunctionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaFunctions = "LambdaFunctions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lambdaFunctions)
        var lambdaFunctionsDecoded0:[Swift.String]? = nil
        if let lambdaFunctionsContainer = lambdaFunctionsContainer {
            lambdaFunctionsDecoded0 = [Swift.String]()
            for string0 in lambdaFunctionsContainer {
                if let string0 = string0 {
                    lambdaFunctionsDecoded0?.append(string0)
                }
            }
        }
        lambdaFunctions = lambdaFunctionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLexBotsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLexBotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/lex-bots"
    }
}

public struct ListLexBotsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page. If no value is specified, the default is 10.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLexBotsInputBody: Swift.Equatable {
}

extension ListLexBotsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLexBotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLexBotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLexBotsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLexBotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLexBotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lexBots = output.lexBots
            self.nextToken = output.nextToken
        } else {
            self.lexBots = nil
            self.nextToken = nil
        }
    }
}

public struct ListLexBotsOutputResponse: Swift.Equatable {
    /// The names and Regions of the Amazon Lex bots associated with the specified instance.
    public var lexBots: [ConnectClientTypes.LexBot]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        lexBots: [ConnectClientTypes.LexBot]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lexBots = lexBots
        self.nextToken = nextToken
    }
}

struct ListLexBotsOutputResponseBody: Swift.Equatable {
    let lexBots: [ConnectClientTypes.LexBot]?
    let nextToken: Swift.String?
}

extension ListLexBotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lexBots = "LexBots"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexBotsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.LexBot?].self, forKey: .lexBots)
        var lexBotsDecoded0:[ConnectClientTypes.LexBot]? = nil
        if let lexBotsContainer = lexBotsContainer {
            lexBotsDecoded0 = [ConnectClientTypes.LexBot]()
            for structure0 in lexBotsContainer {
                if let structure0 = structure0 {
                    lexBotsDecoded0?.append(structure0)
                }
            }
        }
        lexBots = lexBotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPhoneNumbersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let phoneNumberTypes = phoneNumberTypes {
            phoneNumberTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "phoneNumberTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let phoneNumberCountryCodes = phoneNumberCountryCodes {
            phoneNumberCountryCodes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "phoneNumberCountryCodes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListPhoneNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/phone-numbers-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListPhoneNumbersInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ISO country code.
    public var phoneNumberCountryCodes: [ConnectClientTypes.PhoneNumberCountryCode]?
    /// The type of phone number.
    public var phoneNumberTypes: [ConnectClientTypes.PhoneNumberType]?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        phoneNumberCountryCodes: [ConnectClientTypes.PhoneNumberCountryCode]? = nil,
        phoneNumberTypes: [ConnectClientTypes.PhoneNumberType]? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberCountryCodes = phoneNumberCountryCodes
        self.phoneNumberTypes = phoneNumberTypes
    }
}

struct ListPhoneNumbersInputBody: Swift.Equatable {
}

extension ListPhoneNumbersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPhoneNumbersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPhoneNumbersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPhoneNumbersOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPhoneNumbersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPhoneNumbersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumberSummaryList = output.phoneNumberSummaryList
        } else {
            self.nextToken = nil
            self.phoneNumberSummaryList = nil
        }
    }
}

public struct ListPhoneNumbersOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the phone numbers.
    public var phoneNumberSummaryList: [ConnectClientTypes.PhoneNumberSummary]?

    public init (
        nextToken: Swift.String? = nil,
        phoneNumberSummaryList: [ConnectClientTypes.PhoneNumberSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumberSummaryList = phoneNumberSummaryList
    }
}

struct ListPhoneNumbersOutputResponseBody: Swift.Equatable {
    let phoneNumberSummaryList: [ConnectClientTypes.PhoneNumberSummary]?
    let nextToken: Swift.String?
}

extension ListPhoneNumbersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumberSummaryList = "PhoneNumberSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.PhoneNumberSummary?].self, forKey: .phoneNumberSummaryList)
        var phoneNumberSummaryListDecoded0:[ConnectClientTypes.PhoneNumberSummary]? = nil
        if let phoneNumberSummaryListContainer = phoneNumberSummaryListContainer {
            phoneNumberSummaryListDecoded0 = [ConnectClientTypes.PhoneNumberSummary]()
            for structure0 in phoneNumberSummaryListContainer {
                if let structure0 = structure0 {
                    phoneNumberSummaryListDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberSummaryList = phoneNumberSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPromptsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPromptsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/prompts-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListPromptsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPromptsInputBody: Swift.Equatable {
}

extension ListPromptsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPromptsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPromptsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPromptsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPromptsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPromptsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.promptSummaryList = output.promptSummaryList
        } else {
            self.nextToken = nil
            self.promptSummaryList = nil
        }
    }
}

public struct ListPromptsOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the prompts.
    public var promptSummaryList: [ConnectClientTypes.PromptSummary]?

    public init (
        nextToken: Swift.String? = nil,
        promptSummaryList: [ConnectClientTypes.PromptSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.promptSummaryList = promptSummaryList
    }
}

struct ListPromptsOutputResponseBody: Swift.Equatable {
    let promptSummaryList: [ConnectClientTypes.PromptSummary]?
    let nextToken: Swift.String?
}

extension ListPromptsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case promptSummaryList = "PromptSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.PromptSummary?].self, forKey: .promptSummaryList)
        var promptSummaryListDecoded0:[ConnectClientTypes.PromptSummary]? = nil
        if let promptSummaryListContainer = promptSummaryListContainer {
            promptSummaryListDecoded0 = [ConnectClientTypes.PromptSummary]()
            for structure0 in promptSummaryListContainer {
                if let structure0 = structure0 {
                    promptSummaryListDecoded0?.append(structure0)
                }
            }
        }
        promptSummaryList = promptSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListQueueQuickConnectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListQueueQuickConnectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/quick-connects"
    }
}

public struct ListQueueQuickConnectsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

struct ListQueueQuickConnectsInputBody: Swift.Equatable {
}

extension ListQueueQuickConnectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListQueueQuickConnectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQueueQuickConnectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQueueQuickConnectsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQueueQuickConnectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListQueueQuickConnectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.quickConnectSummaryList = output.quickConnectSummaryList
        } else {
            self.nextToken = nil
            self.quickConnectSummaryList = nil
        }
    }
}

public struct ListQueueQuickConnectsOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the quick connects.
    public var quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]?

    public init (
        nextToken: Swift.String? = nil,
        quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.quickConnectSummaryList = quickConnectSummaryList
    }
}

struct ListQueueQuickConnectsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]?
}

extension ListQueueQuickConnectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case quickConnectSummaryList = "QuickConnectSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let quickConnectSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.QuickConnectSummary?].self, forKey: .quickConnectSummaryList)
        var quickConnectSummaryListDecoded0:[ConnectClientTypes.QuickConnectSummary]? = nil
        if let quickConnectSummaryListContainer = quickConnectSummaryListContainer {
            quickConnectSummaryListDecoded0 = [ConnectClientTypes.QuickConnectSummary]()
            for structure0 in quickConnectSummaryListContainer {
                if let structure0 = structure0 {
                    quickConnectSummaryListDecoded0?.append(structure0)
                }
            }
        }
        quickConnectSummaryList = quickConnectSummaryListDecoded0
    }
}

extension ListQueuesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let queueTypes = queueTypes {
            queueTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "queueTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListQueuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/queues-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListQueuesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The type of queue.
    public var queueTypes: [ConnectClientTypes.QueueType]?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        queueTypes: [ConnectClientTypes.QueueType]? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueTypes = queueTypes
    }
}

struct ListQueuesInputBody: Swift.Equatable {
}

extension ListQueuesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListQueuesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQueuesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQueuesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQueuesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListQueuesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queueSummaryList = output.queueSummaryList
        } else {
            self.nextToken = nil
            self.queueSummaryList = nil
        }
    }
}

public struct ListQueuesOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the queues.
    public var queueSummaryList: [ConnectClientTypes.QueueSummary]?

    public init (
        nextToken: Swift.String? = nil,
        queueSummaryList: [ConnectClientTypes.QueueSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.queueSummaryList = queueSummaryList
    }
}

struct ListQueuesOutputResponseBody: Swift.Equatable {
    let queueSummaryList: [ConnectClientTypes.QueueSummary]?
    let nextToken: Swift.String?
}

extension ListQueuesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case queueSummaryList = "QueueSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.QueueSummary?].self, forKey: .queueSummaryList)
        var queueSummaryListDecoded0:[ConnectClientTypes.QueueSummary]? = nil
        if let queueSummaryListContainer = queueSummaryListContainer {
            queueSummaryListDecoded0 = [ConnectClientTypes.QueueSummary]()
            for structure0 in queueSummaryListContainer {
                if let structure0 = structure0 {
                    queueSummaryListDecoded0?.append(structure0)
                }
            }
        }
        queueSummaryList = queueSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListQuickConnectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let quickConnectTypes = quickConnectTypes {
            quickConnectTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "QuickConnectTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListQuickConnectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListQuickConnectsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
    public var quickConnectTypes: [ConnectClientTypes.QuickConnectType]?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        quickConnectTypes: [ConnectClientTypes.QuickConnectType]? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quickConnectTypes = quickConnectTypes
    }
}

struct ListQuickConnectsInputBody: Swift.Equatable {
}

extension ListQuickConnectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListQuickConnectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQuickConnectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQuickConnectsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQuickConnectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListQuickConnectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.quickConnectSummaryList = output.quickConnectSummaryList
        } else {
            self.nextToken = nil
            self.quickConnectSummaryList = nil
        }
    }
}

public struct ListQuickConnectsOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the quick connects.
    public var quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]?

    public init (
        nextToken: Swift.String? = nil,
        quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.quickConnectSummaryList = quickConnectSummaryList
    }
}

struct ListQuickConnectsOutputResponseBody: Swift.Equatable {
    let quickConnectSummaryList: [ConnectClientTypes.QuickConnectSummary]?
    let nextToken: Swift.String?
}

extension ListQuickConnectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case quickConnectSummaryList = "QuickConnectSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.QuickConnectSummary?].self, forKey: .quickConnectSummaryList)
        var quickConnectSummaryListDecoded0:[ConnectClientTypes.QuickConnectSummary]? = nil
        if let quickConnectSummaryListContainer = quickConnectSummaryListContainer {
            quickConnectSummaryListDecoded0 = [ConnectClientTypes.QuickConnectSummary]()
            for structure0 in quickConnectSummaryListContainer {
                if let structure0 = structure0 {
                    quickConnectSummaryListDecoded0?.append(structure0)
                }
            }
        }
        quickConnectSummaryList = quickConnectSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRoutingProfileQueuesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRoutingProfileQueuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/queues"
    }
}

public struct ListRoutingProfileQueuesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.routingProfileId = routingProfileId
    }
}

struct ListRoutingProfileQueuesInputBody: Swift.Equatable {
}

extension ListRoutingProfileQueuesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRoutingProfileQueuesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoutingProfileQueuesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRoutingProfileQueuesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoutingProfileQueuesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRoutingProfileQueuesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.routingProfileQueueConfigSummaryList = output.routingProfileQueueConfigSummaryList
        } else {
            self.nextToken = nil
            self.routingProfileQueueConfigSummaryList = nil
        }
    }
}

public struct ListRoutingProfileQueuesOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the routing profiles.
    public var routingProfileQueueConfigSummaryList: [ConnectClientTypes.RoutingProfileQueueConfigSummary]?

    public init (
        nextToken: Swift.String? = nil,
        routingProfileQueueConfigSummaryList: [ConnectClientTypes.RoutingProfileQueueConfigSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.routingProfileQueueConfigSummaryList = routingProfileQueueConfigSummaryList
    }
}

struct ListRoutingProfileQueuesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let routingProfileQueueConfigSummaryList: [ConnectClientTypes.RoutingProfileQueueConfigSummary]?
}

extension ListRoutingProfileQueuesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case routingProfileQueueConfigSummaryList = "RoutingProfileQueueConfigSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let routingProfileQueueConfigSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileQueueConfigSummary?].self, forKey: .routingProfileQueueConfigSummaryList)
        var routingProfileQueueConfigSummaryListDecoded0:[ConnectClientTypes.RoutingProfileQueueConfigSummary]? = nil
        if let routingProfileQueueConfigSummaryListContainer = routingProfileQueueConfigSummaryListContainer {
            routingProfileQueueConfigSummaryListDecoded0 = [ConnectClientTypes.RoutingProfileQueueConfigSummary]()
            for structure0 in routingProfileQueueConfigSummaryListContainer {
                if let structure0 = structure0 {
                    routingProfileQueueConfigSummaryListDecoded0?.append(structure0)
                }
            }
        }
        routingProfileQueueConfigSummaryList = routingProfileQueueConfigSummaryListDecoded0
    }
}

extension ListRoutingProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRoutingProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/routing-profiles-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListRoutingProfilesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRoutingProfilesInputBody: Swift.Equatable {
}

extension ListRoutingProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRoutingProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoutingProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRoutingProfilesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoutingProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRoutingProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.routingProfileSummaryList = output.routingProfileSummaryList
        } else {
            self.nextToken = nil
            self.routingProfileSummaryList = nil
        }
    }
}

public struct ListRoutingProfilesOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the routing profiles.
    public var routingProfileSummaryList: [ConnectClientTypes.RoutingProfileSummary]?

    public init (
        nextToken: Swift.String? = nil,
        routingProfileSummaryList: [ConnectClientTypes.RoutingProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.routingProfileSummaryList = routingProfileSummaryList
    }
}

struct ListRoutingProfilesOutputResponseBody: Swift.Equatable {
    let routingProfileSummaryList: [ConnectClientTypes.RoutingProfileSummary]?
    let nextToken: Swift.String?
}

extension ListRoutingProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case routingProfileSummaryList = "RoutingProfileSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfileSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileSummary?].self, forKey: .routingProfileSummaryList)
        var routingProfileSummaryListDecoded0:[ConnectClientTypes.RoutingProfileSummary]? = nil
        if let routingProfileSummaryListContainer = routingProfileSummaryListContainer {
            routingProfileSummaryListDecoded0 = [ConnectClientTypes.RoutingProfileSummary]()
            for structure0 in routingProfileSummaryListContainer {
                if let structure0 = structure0 {
                    routingProfileSummaryListDecoded0?.append(structure0)
                }
            }
        }
        routingProfileSummaryList = routingProfileSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSecurityKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/security-keys"
    }
}

public struct ListSecurityKeysInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSecurityKeysInputBody: Swift.Equatable {
}

extension ListSecurityKeysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSecurityKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecurityKeysOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSecurityKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityKeys = output.securityKeys
        } else {
            self.nextToken = nil
            self.securityKeys = nil
        }
    }
}

public struct ListSecurityKeysOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The security keys.
    public var securityKeys: [ConnectClientTypes.SecurityKey]?

    public init (
        nextToken: Swift.String? = nil,
        securityKeys: [ConnectClientTypes.SecurityKey]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityKeys = securityKeys
    }
}

struct ListSecurityKeysOutputResponseBody: Swift.Equatable {
    let securityKeys: [ConnectClientTypes.SecurityKey]?
    let nextToken: Swift.String?
}

extension ListSecurityKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case securityKeys = "SecurityKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityKeysContainer = try containerValues.decodeIfPresent([ConnectClientTypes.SecurityKey?].self, forKey: .securityKeys)
        var securityKeysDecoded0:[ConnectClientTypes.SecurityKey]? = nil
        if let securityKeysContainer = securityKeysContainer {
            securityKeysDecoded0 = [ConnectClientTypes.SecurityKey]()
            for structure0 in securityKeysContainer {
                if let structure0 = structure0 {
                    securityKeysDecoded0?.append(structure0)
                }
            }
        }
        securityKeys = securityKeysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityProfilePermissionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSecurityProfilePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let securityProfileId = securityProfileId else {
            return nil
        }
        return "/security-profiles-permissions/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

public struct ListSecurityProfilePermissionsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileId = securityProfileId
    }
}

struct ListSecurityProfilePermissionsInputBody: Swift.Equatable {
}

extension ListSecurityProfilePermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSecurityProfilePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityProfilePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecurityProfilePermissionsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityProfilePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSecurityProfilePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListSecurityProfilePermissionsOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The permissions granted to the security profile.
    public var permissions: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListSecurityProfilePermissionsOutputResponseBody: Swift.Equatable {
    let permissions: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListSecurityProfilePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissions = "Permissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissions)
        var permissionsDecoded0:[Swift.String]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Swift.String]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSecurityProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/security-profiles-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListSecurityProfilesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSecurityProfilesInputBody: Swift.Equatable {
}

extension ListSecurityProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSecurityProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecurityProfilesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSecurityProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityProfileSummaryList = output.securityProfileSummaryList
        } else {
            self.nextToken = nil
            self.securityProfileSummaryList = nil
        }
    }
}

public struct ListSecurityProfilesOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the security profiles.
    public var securityProfileSummaryList: [ConnectClientTypes.SecurityProfileSummary]?

    public init (
        nextToken: Swift.String? = nil,
        securityProfileSummaryList: [ConnectClientTypes.SecurityProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileSummaryList = securityProfileSummaryList
    }
}

struct ListSecurityProfilesOutputResponseBody: Swift.Equatable {
    let securityProfileSummaryList: [ConnectClientTypes.SecurityProfileSummary]?
    let nextToken: Swift.String?
}

extension ListSecurityProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case securityProfileSummaryList = "SecurityProfileSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.SecurityProfileSummary?].self, forKey: .securityProfileSummaryList)
        var securityProfileSummaryListDecoded0:[ConnectClientTypes.SecurityProfileSummary]? = nil
        if let securityProfileSummaryListContainer = securityProfileSummaryListContainer {
            securityProfileSummaryListDecoded0 = [ConnectClientTypes.SecurityProfileSummary]()
            for structure0 in securityProfileSummaryListContainer {
                if let structure0 = structure0 {
                    securityProfileSummaryListDecoded0?.append(structure0)
                }
            }
        }
        securityProfileSummaryList = securityProfileSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Information about the tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListUseCasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUseCasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let integrationAssociationId = integrationAssociationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/integration-associations/\(integrationAssociationId.urlPercentEncoding())/use-cases"
    }
}

/// Provides summary information about the use cases for the specified integration association.
public struct ListUseCasesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the integration association.
    /// This member is required.
    public var integrationAssociationId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        integrationAssociationId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.integrationAssociationId = integrationAssociationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUseCasesInputBody: Swift.Equatable {
}

extension ListUseCasesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUseCasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUseCasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUseCasesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUseCasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUseCasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.useCaseSummaryList = output.useCaseSummaryList
        } else {
            self.nextToken = nil
            self.useCaseSummaryList = nil
        }
    }
}

public struct ListUseCasesOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The use cases.
    public var useCaseSummaryList: [ConnectClientTypes.UseCase]?

    public init (
        nextToken: Swift.String? = nil,
        useCaseSummaryList: [ConnectClientTypes.UseCase]? = nil
    )
    {
        self.nextToken = nextToken
        self.useCaseSummaryList = useCaseSummaryList
    }
}

struct ListUseCasesOutputResponseBody: Swift.Equatable {
    let useCaseSummaryList: [ConnectClientTypes.UseCase]?
    let nextToken: Swift.String?
}

extension ListUseCasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case useCaseSummaryList = "UseCaseSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let useCaseSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.UseCase?].self, forKey: .useCaseSummaryList)
        var useCaseSummaryListDecoded0:[ConnectClientTypes.UseCase]? = nil
        if let useCaseSummaryListContainer = useCaseSummaryListContainer {
            useCaseSummaryListDecoded0 = [ConnectClientTypes.UseCase]()
            for structure0 in useCaseSummaryListContainer {
                if let structure0 = structure0 {
                    useCaseSummaryListDecoded0?.append(structure0)
                }
            }
        }
        useCaseSummaryList = useCaseSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUserHierarchyGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUserHierarchyGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/user-hierarchy-groups-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListUserHierarchyGroupsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserHierarchyGroupsInputBody: Swift.Equatable {
}

extension ListUserHierarchyGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUserHierarchyGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserHierarchyGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUserHierarchyGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserHierarchyGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUserHierarchyGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userHierarchyGroupSummaryList = output.userHierarchyGroupSummaryList
        } else {
            self.nextToken = nil
            self.userHierarchyGroupSummaryList = nil
        }
    }
}

public struct ListUserHierarchyGroupsOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the hierarchy groups.
    public var userHierarchyGroupSummaryList: [ConnectClientTypes.HierarchyGroupSummary]?

    public init (
        nextToken: Swift.String? = nil,
        userHierarchyGroupSummaryList: [ConnectClientTypes.HierarchyGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userHierarchyGroupSummaryList = userHierarchyGroupSummaryList
    }
}

struct ListUserHierarchyGroupsOutputResponseBody: Swift.Equatable {
    let userHierarchyGroupSummaryList: [ConnectClientTypes.HierarchyGroupSummary]?
    let nextToken: Swift.String?
}

extension ListUserHierarchyGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case userHierarchyGroupSummaryList = "UserHierarchyGroupSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userHierarchyGroupSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HierarchyGroupSummary?].self, forKey: .userHierarchyGroupSummaryList)
        var userHierarchyGroupSummaryListDecoded0:[ConnectClientTypes.HierarchyGroupSummary]? = nil
        if let userHierarchyGroupSummaryListContainer = userHierarchyGroupSummaryListContainer {
            userHierarchyGroupSummaryListDecoded0 = [ConnectClientTypes.HierarchyGroupSummary]()
            for structure0 in userHierarchyGroupSummaryListContainer {
                if let structure0 = structure0 {
                    userHierarchyGroupSummaryListDecoded0?.append(structure0)
                }
            }
        }
        userHierarchyGroupSummaryList = userHierarchyGroupSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/users-summary/\(instanceId.urlPercentEncoding())"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Swift.Equatable {
}

extension ListUsersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userSummaryList = output.userSummaryList
        } else {
            self.nextToken = nil
            self.userSummaryList = nil
        }
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the users.
    public var userSummaryList: [ConnectClientTypes.UserSummary]?

    public init (
        nextToken: Swift.String? = nil,
        userSummaryList: [ConnectClientTypes.UserSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userSummaryList = userSummaryList
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    let userSummaryList: [ConnectClientTypes.UserSummary]?
    let nextToken: Swift.String?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case userSummaryList = "UserSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSummaryListContainer = try containerValues.decodeIfPresent([ConnectClientTypes.UserSummary?].self, forKey: .userSummaryList)
        var userSummaryListDecoded0:[ConnectClientTypes.UserSummary]? = nil
        if let userSummaryListContainer = userSummaryListContainer {
            userSummaryListDecoded0 = [ConnectClientTypes.UserSummary]()
            for structure0 in userSummaryListContainer {
                if let structure0 = structure0 {
                    userSummaryListDecoded0?.append(structure0)
                }
            }
        }
        userSummaryList = userSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ConnectClientTypes.MediaConcurrency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
        case concurrency = "Concurrency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if concurrency != 0 {
            try encodeContainer.encode(concurrency, forKey: .concurrency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
        let concurrencyDecoded = try containerValues.decode(Swift.Int.self, forKey: .concurrency)
        concurrency = concurrencyDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about which channels are supported, and how many contacts an agent can have on a channel simultaneously.
    public struct MediaConcurrency: Swift.Equatable {
        /// The channels that agents can handle in the Contact Control Panel (CCP).
        /// This member is required.
        public var channel: ConnectClientTypes.Channel?
        /// The number of contacts an agent can have on a channel simultaneously. Valid Range for VOICE: Minimum value of 1. Maximum value of 1. Valid Range for CHAT: Minimum value of 1. Maximum value of 10. Valid Range for TASK: Minimum value of 1. Maximum value of 10.
        /// This member is required.
        public var concurrency: Swift.Int

        public init (
            channel: ConnectClientTypes.Channel? = nil,
            concurrency: Swift.Int = 0
        )
        {
            self.channel = channel
            self.concurrency = concurrency
        }
    }

}

extension ConnectClientTypes.OutboundCallerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outboundCallerIdName = "OutboundCallerIdName"
        case outboundCallerIdNumberId = "OutboundCallerIdNumberId"
        case outboundFlowId = "OutboundFlowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outboundCallerIdName = outboundCallerIdName {
            try encodeContainer.encode(outboundCallerIdName, forKey: .outboundCallerIdName)
        }
        if let outboundCallerIdNumberId = outboundCallerIdNumberId {
            try encodeContainer.encode(outboundCallerIdNumberId, forKey: .outboundCallerIdNumberId)
        }
        if let outboundFlowId = outboundFlowId {
            try encodeContainer.encode(outboundFlowId, forKey: .outboundFlowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outboundCallerIdNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundCallerIdName)
        outboundCallerIdName = outboundCallerIdNameDecoded
        let outboundCallerIdNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundCallerIdNumberId)
        outboundCallerIdNumberId = outboundCallerIdNumberIdDecoded
        let outboundFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundFlowId)
        outboundFlowId = outboundFlowIdDecoded
    }
}

extension ConnectClientTypes {
    /// The outbound caller ID name, number, and outbound whisper flow.
    public struct OutboundCallerConfig: Swift.Equatable {
        /// The caller ID name.
        public var outboundCallerIdName: Swift.String?
        /// The caller ID number.
        public var outboundCallerIdNumberId: Swift.String?
        /// The outbound whisper flow to be used during an outbound call.
        public var outboundFlowId: Swift.String?

        public init (
            outboundCallerIdName: Swift.String? = nil,
            outboundCallerIdNumberId: Swift.String? = nil,
            outboundFlowId: Swift.String? = nil
        )
        {
            self.outboundCallerIdName = outboundCallerIdName
            self.outboundCallerIdNumberId = outboundCallerIdNumberId
            self.outboundFlowId = outboundFlowId
        }
    }

}

extension OutboundContactNotPermittedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OutboundContactNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The contact is not permitted.
public struct OutboundContactNotPermittedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message about the contact.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OutboundContactNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OutboundContactNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.ParticipantDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension ConnectClientTypes {
    /// The customer's details.
    public struct ParticipantDetails: Swift.Equatable {
        /// Display name of the participant.
        /// This member is required.
        public var displayName: Swift.String?

        public init (
            displayName: Swift.String? = nil
        )
        {
            self.displayName = displayName
        }
    }

}

extension ConnectClientTypes {
    public enum PhoneNumberCountryCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ad
        case ae
        case af
        case ag
        case ai
        case al
        case am
        case an
        case ao
        case aq
        case ar
        case `as`
        case at
        case au
        case aw
        case az
        case ba
        case bb
        case bd
        case be
        case bf
        case bg
        case bh
        case bi
        case bj
        case bl
        case bm
        case bn
        case bo
        case br
        case bs
        case bt
        case bw
        case by
        case bz
        case ca
        case cc
        case cd
        case cf
        case cg
        case ch
        case ci
        case ck
        case cl
        case cm
        case cn
        case co
        case cr
        case cu
        case cv
        case cw
        case cx
        case cy
        case cz
        case de
        case dj
        case dk
        case dm
        case `do`
        case dz
        case ec
        case ee
        case eg
        case eh
        case er
        case es
        case et
        case fi
        case fj
        case fk
        case fm
        case fo
        case fr
        case ga
        case gb
        case gd
        case ge
        case gg
        case gh
        case gi
        case gl
        case gm
        case gn
        case gq
        case gr
        case gt
        case gu
        case gw
        case gy
        case hk
        case hn
        case hr
        case ht
        case hu
        case id
        case ie
        case il
        case im
        case `in`
        case io
        case iq
        case ir
        case `is`
        case it
        case je
        case jm
        case jo
        case jp
        case ke
        case kg
        case kh
        case ki
        case km
        case kn
        case kp
        case kr
        case kw
        case ky
        case kz
        case la
        case lb
        case lc
        case li
        case lk
        case lr
        case ls
        case lt
        case lu
        case lv
        case ly
        case ma
        case mc
        case md
        case me
        case mf
        case mg
        case mh
        case mk
        case ml
        case mm
        case mn
        case mo
        case mp
        case mr
        case ms
        case mt
        case mu
        case mv
        case mw
        case mx
        case my
        case mz
        case na
        case nc
        case ne
        case ng
        case ni
        case nl
        case no
        case np
        case nr
        case nu
        case nz
        case om
        case pa
        case pe
        case pf
        case pg
        case ph
        case pk
        case pl
        case pm
        case pn
        case pr
        case pt
        case pw
        case py
        case qa
        case re
        case ro
        case rs
        case ru
        case rw
        case sa
        case sb
        case sc
        case sd
        case se
        case sg
        case sh
        case si
        case sj
        case sk
        case sl
        case sm
        case sn
        case so
        case sr
        case st
        case sv
        case sx
        case sy
        case sz
        case tc
        case td
        case tg
        case th
        case tj
        case tk
        case tl
        case tm
        case tn
        case to
        case tr
        case tt
        case tv
        case tw
        case tz
        case ua
        case ug
        case us
        case uy
        case uz
        case va
        case vc
        case ve
        case vg
        case vi
        case vn
        case vu
        case wf
        case ws
        case ye
        case yt
        case za
        case zm
        case zw
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberCountryCode] {
            return [
                .ad,
                .ae,
                .af,
                .ag,
                .ai,
                .al,
                .am,
                .an,
                .ao,
                .aq,
                .ar,
                .as,
                .at,
                .au,
                .aw,
                .az,
                .ba,
                .bb,
                .bd,
                .be,
                .bf,
                .bg,
                .bh,
                .bi,
                .bj,
                .bl,
                .bm,
                .bn,
                .bo,
                .br,
                .bs,
                .bt,
                .bw,
                .by,
                .bz,
                .ca,
                .cc,
                .cd,
                .cf,
                .cg,
                .ch,
                .ci,
                .ck,
                .cl,
                .cm,
                .cn,
                .co,
                .cr,
                .cu,
                .cv,
                .cw,
                .cx,
                .cy,
                .cz,
                .de,
                .dj,
                .dk,
                .dm,
                .do,
                .dz,
                .ec,
                .ee,
                .eg,
                .eh,
                .er,
                .es,
                .et,
                .fi,
                .fj,
                .fk,
                .fm,
                .fo,
                .fr,
                .ga,
                .gb,
                .gd,
                .ge,
                .gg,
                .gh,
                .gi,
                .gl,
                .gm,
                .gn,
                .gq,
                .gr,
                .gt,
                .gu,
                .gw,
                .gy,
                .hk,
                .hn,
                .hr,
                .ht,
                .hu,
                .id,
                .ie,
                .il,
                .im,
                .in,
                .io,
                .iq,
                .ir,
                .is,
                .it,
                .je,
                .jm,
                .jo,
                .jp,
                .ke,
                .kg,
                .kh,
                .ki,
                .km,
                .kn,
                .kp,
                .kr,
                .kw,
                .ky,
                .kz,
                .la,
                .lb,
                .lc,
                .li,
                .lk,
                .lr,
                .ls,
                .lt,
                .lu,
                .lv,
                .ly,
                .ma,
                .mc,
                .md,
                .me,
                .mf,
                .mg,
                .mh,
                .mk,
                .ml,
                .mm,
                .mn,
                .mo,
                .mp,
                .mr,
                .ms,
                .mt,
                .mu,
                .mv,
                .mw,
                .mx,
                .my,
                .mz,
                .na,
                .nc,
                .ne,
                .ng,
                .ni,
                .nl,
                .no,
                .np,
                .nr,
                .nu,
                .nz,
                .om,
                .pa,
                .pe,
                .pf,
                .pg,
                .ph,
                .pk,
                .pl,
                .pm,
                .pn,
                .pr,
                .pt,
                .pw,
                .py,
                .qa,
                .re,
                .ro,
                .rs,
                .ru,
                .rw,
                .sa,
                .sb,
                .sc,
                .sd,
                .se,
                .sg,
                .sh,
                .si,
                .sj,
                .sk,
                .sl,
                .sm,
                .sn,
                .so,
                .sr,
                .st,
                .sv,
                .sx,
                .sy,
                .sz,
                .tc,
                .td,
                .tg,
                .th,
                .tj,
                .tk,
                .tl,
                .tm,
                .tn,
                .to,
                .tr,
                .tt,
                .tv,
                .tw,
                .tz,
                .ua,
                .ug,
                .us,
                .uy,
                .uz,
                .va,
                .vc,
                .ve,
                .vg,
                .vi,
                .vn,
                .vu,
                .wf,
                .ws,
                .ye,
                .yt,
                .za,
                .zm,
                .zw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ad: return "AD"
            case .ae: return "AE"
            case .af: return "AF"
            case .ag: return "AG"
            case .ai: return "AI"
            case .al: return "AL"
            case .am: return "AM"
            case .an: return "AN"
            case .ao: return "AO"
            case .aq: return "AQ"
            case .ar: return "AR"
            case .as: return "AS"
            case .at: return "AT"
            case .au: return "AU"
            case .aw: return "AW"
            case .az: return "AZ"
            case .ba: return "BA"
            case .bb: return "BB"
            case .bd: return "BD"
            case .be: return "BE"
            case .bf: return "BF"
            case .bg: return "BG"
            case .bh: return "BH"
            case .bi: return "BI"
            case .bj: return "BJ"
            case .bl: return "BL"
            case .bm: return "BM"
            case .bn: return "BN"
            case .bo: return "BO"
            case .br: return "BR"
            case .bs: return "BS"
            case .bt: return "BT"
            case .bw: return "BW"
            case .by: return "BY"
            case .bz: return "BZ"
            case .ca: return "CA"
            case .cc: return "CC"
            case .cd: return "CD"
            case .cf: return "CF"
            case .cg: return "CG"
            case .ch: return "CH"
            case .ci: return "CI"
            case .ck: return "CK"
            case .cl: return "CL"
            case .cm: return "CM"
            case .cn: return "CN"
            case .co: return "CO"
            case .cr: return "CR"
            case .cu: return "CU"
            case .cv: return "CV"
            case .cw: return "CW"
            case .cx: return "CX"
            case .cy: return "CY"
            case .cz: return "CZ"
            case .de: return "DE"
            case .dj: return "DJ"
            case .dk: return "DK"
            case .dm: return "DM"
            case .do: return "DO"
            case .dz: return "DZ"
            case .ec: return "EC"
            case .ee: return "EE"
            case .eg: return "EG"
            case .eh: return "EH"
            case .er: return "ER"
            case .es: return "ES"
            case .et: return "ET"
            case .fi: return "FI"
            case .fj: return "FJ"
            case .fk: return "FK"
            case .fm: return "FM"
            case .fo: return "FO"
            case .fr: return "FR"
            case .ga: return "GA"
            case .gb: return "GB"
            case .gd: return "GD"
            case .ge: return "GE"
            case .gg: return "GG"
            case .gh: return "GH"
            case .gi: return "GI"
            case .gl: return "GL"
            case .gm: return "GM"
            case .gn: return "GN"
            case .gq: return "GQ"
            case .gr: return "GR"
            case .gt: return "GT"
            case .gu: return "GU"
            case .gw: return "GW"
            case .gy: return "GY"
            case .hk: return "HK"
            case .hn: return "HN"
            case .hr: return "HR"
            case .ht: return "HT"
            case .hu: return "HU"
            case .id: return "ID"
            case .ie: return "IE"
            case .il: return "IL"
            case .im: return "IM"
            case .in: return "IN"
            case .io: return "IO"
            case .iq: return "IQ"
            case .ir: return "IR"
            case .is: return "IS"
            case .it: return "IT"
            case .je: return "JE"
            case .jm: return "JM"
            case .jo: return "JO"
            case .jp: return "JP"
            case .ke: return "KE"
            case .kg: return "KG"
            case .kh: return "KH"
            case .ki: return "KI"
            case .km: return "KM"
            case .kn: return "KN"
            case .kp: return "KP"
            case .kr: return "KR"
            case .kw: return "KW"
            case .ky: return "KY"
            case .kz: return "KZ"
            case .la: return "LA"
            case .lb: return "LB"
            case .lc: return "LC"
            case .li: return "LI"
            case .lk: return "LK"
            case .lr: return "LR"
            case .ls: return "LS"
            case .lt: return "LT"
            case .lu: return "LU"
            case .lv: return "LV"
            case .ly: return "LY"
            case .ma: return "MA"
            case .mc: return "MC"
            case .md: return "MD"
            case .me: return "ME"
            case .mf: return "MF"
            case .mg: return "MG"
            case .mh: return "MH"
            case .mk: return "MK"
            case .ml: return "ML"
            case .mm: return "MM"
            case .mn: return "MN"
            case .mo: return "MO"
            case .mp: return "MP"
            case .mr: return "MR"
            case .ms: return "MS"
            case .mt: return "MT"
            case .mu: return "MU"
            case .mv: return "MV"
            case .mw: return "MW"
            case .mx: return "MX"
            case .my: return "MY"
            case .mz: return "MZ"
            case .na: return "NA"
            case .nc: return "NC"
            case .ne: return "NE"
            case .ng: return "NG"
            case .ni: return "NI"
            case .nl: return "NL"
            case .no: return "NO"
            case .np: return "NP"
            case .nr: return "NR"
            case .nu: return "NU"
            case .nz: return "NZ"
            case .om: return "OM"
            case .pa: return "PA"
            case .pe: return "PE"
            case .pf: return "PF"
            case .pg: return "PG"
            case .ph: return "PH"
            case .pk: return "PK"
            case .pl: return "PL"
            case .pm: return "PM"
            case .pn: return "PN"
            case .pr: return "PR"
            case .pt: return "PT"
            case .pw: return "PW"
            case .py: return "PY"
            case .qa: return "QA"
            case .re: return "RE"
            case .ro: return "RO"
            case .rs: return "RS"
            case .ru: return "RU"
            case .rw: return "RW"
            case .sa: return "SA"
            case .sb: return "SB"
            case .sc: return "SC"
            case .sd: return "SD"
            case .se: return "SE"
            case .sg: return "SG"
            case .sh: return "SH"
            case .si: return "SI"
            case .sj: return "SJ"
            case .sk: return "SK"
            case .sl: return "SL"
            case .sm: return "SM"
            case .sn: return "SN"
            case .so: return "SO"
            case .sr: return "SR"
            case .st: return "ST"
            case .sv: return "SV"
            case .sx: return "SX"
            case .sy: return "SY"
            case .sz: return "SZ"
            case .tc: return "TC"
            case .td: return "TD"
            case .tg: return "TG"
            case .th: return "TH"
            case .tj: return "TJ"
            case .tk: return "TK"
            case .tl: return "TL"
            case .tm: return "TM"
            case .tn: return "TN"
            case .to: return "TO"
            case .tr: return "TR"
            case .tt: return "TT"
            case .tv: return "TV"
            case .tw: return "TW"
            case .tz: return "TZ"
            case .ua: return "UA"
            case .ug: return "UG"
            case .us: return "US"
            case .uy: return "UY"
            case .uz: return "UZ"
            case .va: return "VA"
            case .vc: return "VC"
            case .ve: return "VE"
            case .vg: return "VG"
            case .vi: return "VI"
            case .vn: return "VN"
            case .vu: return "VU"
            case .wf: return "WF"
            case .ws: return "WS"
            case .ye: return "YE"
            case .yt: return "YT"
            case .za: return "ZA"
            case .zm: return "ZM"
            case .zw: return "ZW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberCountryCode(rawValue: rawValue) ?? PhoneNumberCountryCode.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.PhoneNumberQuickConnectConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a phone number for a quick connect.
    public struct PhoneNumberQuickConnectConfig: Swift.Equatable {
        /// The phone number in E.164 format.
        /// This member is required.
        public var phoneNumber: Swift.String?

        public init (
            phoneNumber: Swift.String? = nil
        )
        {
            self.phoneNumber = phoneNumber
        }
    }

}

extension ConnectClientTypes.PhoneNumberSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case phoneNumber = "PhoneNumber"
        case phoneNumberCountryCode = "PhoneNumberCountryCode"
        case phoneNumberType = "PhoneNumberType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumberCountryCode = phoneNumberCountryCode {
            try encodeContainer.encode(phoneNumberCountryCode.rawValue, forKey: .phoneNumberCountryCode)
        }
        if let phoneNumberType = phoneNumberType {
            try encodeContainer.encode(phoneNumberType.rawValue, forKey: .phoneNumberType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumberTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberType.self, forKey: .phoneNumberType)
        phoneNumberType = phoneNumberTypeDecoded
        let phoneNumberCountryCodeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberCountryCode.self, forKey: .phoneNumberCountryCode)
        phoneNumberCountryCode = phoneNumberCountryCodeDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a phone number for a contact center.
    public struct PhoneNumberSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the phone number.
        public var arn: Swift.String?
        /// The identifier of the phone number.
        public var id: Swift.String?
        /// The phone number.
        public var phoneNumber: Swift.String?
        /// The ISO country code.
        public var phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode?
        /// The type of phone number.
        public var phoneNumberType: ConnectClientTypes.PhoneNumberType?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumberCountryCode: ConnectClientTypes.PhoneNumberCountryCode? = nil,
            phoneNumberType: ConnectClientTypes.PhoneNumberType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.phoneNumber = phoneNumber
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberType = phoneNumberType
        }
    }

}

extension ConnectClientTypes {
    public enum PhoneNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case did
        case tollFree
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberType] {
            return [
                .did,
                .tollFree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .did: return "DID"
            case .tollFree: return "TOLL_FREE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberType(rawValue: rawValue) ?? PhoneNumberType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum PhoneType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deskPhone
        case softPhone
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneType] {
            return [
                .deskPhone,
                .softPhone,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deskPhone: return "DESK_PHONE"
            case .softPhone: return "SOFT_PHONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneType(rawValue: rawValue) ?? PhoneType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ProblemDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    /// Information about a problem detail.
    public struct ProblemDetail: Swift.Equatable {
        /// The problem detail's message.
        public var message: Swift.String?

        public init (
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension ConnectClientTypes.PromptSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the prompt.
    public struct PromptSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the prompt.
        public var arn: Swift.String?
        /// The identifier of the prompt.
        public var id: Swift.String?
        /// The name of the prompt.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension ConnectClientTypes.Queue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case hoursOfOperationId = "HoursOfOperationId"
        case maxContacts = "MaxContacts"
        case name = "Name"
        case outboundCallerConfig = "OutboundCallerConfig"
        case queueArn = "QueueArn"
        case queueId = "QueueId"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hoursOfOperationId = hoursOfOperationId {
            try encodeContainer.encode(hoursOfOperationId, forKey: .hoursOfOperationId)
        }
        if maxContacts != 0 {
            try encodeContainer.encode(maxContacts, forKey: .maxContacts)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundCallerConfig = outboundCallerConfig {
            try encodeContainer.encode(outboundCallerConfig, forKey: .outboundCallerConfig)
        }
        if let queueArn = queueArn {
            try encodeContainer.encode(queueArn, forKey: .queueArn)
        }
        if let queueId = queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let queueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let outboundCallerConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.OutboundCallerConfig.self, forKey: .outboundCallerConfig)
        outboundCallerConfig = outboundCallerConfigDecoded
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
        let maxContactsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxContacts)
        maxContacts = maxContactsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a queue.
    public struct Queue: Swift.Equatable {
        /// The description of the queue.
        public var description: Swift.String?
        /// The identifier for the hours of operation.
        public var hoursOfOperationId: Swift.String?
        /// The maximum number of contacts that can be in the queue before it is considered full.
        public var maxContacts: Swift.Int
        /// The name of the queue.
        public var name: Swift.String?
        /// The outbound caller ID name, number, and outbound whisper flow.
        public var outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
        /// The Amazon Resource Name (ARN) for the queue.
        public var queueArn: Swift.String?
        /// The identifier for the queue.
        public var queueId: Swift.String?
        /// The status of the queue.
        public var status: ConnectClientTypes.QueueStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            hoursOfOperationId: Swift.String? = nil,
            maxContacts: Swift.Int = 0,
            name: Swift.String? = nil,
            outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig? = nil,
            queueArn: Swift.String? = nil,
            queueId: Swift.String? = nil,
            status: ConnectClientTypes.QueueStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.hoursOfOperationId = hoursOfOperationId
            self.maxContacts = maxContacts
            self.name = name
            self.outboundCallerConfig = outboundCallerConfig
            self.queueArn = queueArn
            self.queueId = queueId
            self.status = status
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.QueueInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enqueueTimestamp = "EnqueueTimestamp"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enqueueTimestamp = enqueueTimestamp {
            try encodeContainer.encode(enqueueTimestamp.timeIntervalSince1970, forKey: .enqueueTimestamp)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let enqueueTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .enqueueTimestamp)
        enqueueTimestamp = enqueueTimestampDecoded
    }
}

extension ConnectClientTypes {
    /// If this contact was queued, this contains information about the queue.
    public struct QueueInfo: Swift.Equatable {
        /// The timestamp when the contact was added to the queue.
        public var enqueueTimestamp: ClientRuntime.Date?
        /// The identifier of the agent who accepted the contact.
        public var id: Swift.String?

        public init (
            enqueueTimestamp: ClientRuntime.Date? = nil,
            id: Swift.String? = nil
        )
        {
            self.enqueueTimestamp = enqueueTimestamp
            self.id = id
        }
    }

}

extension ConnectClientTypes.QueueQuickConnectConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowId = "ContactFlowId"
        case queueId = "QueueId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactFlowId = contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let queueId = queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a queue for a quick connect. The contact flow must be of type Transfer to Queue.
    public struct QueueQuickConnectConfig: Swift.Equatable {
        /// The identifier of the contact flow.
        /// This member is required.
        public var contactFlowId: Swift.String?
        /// The identifier for the queue.
        /// This member is required.
        public var queueId: Swift.String?

        public init (
            contactFlowId: Swift.String? = nil,
            queueId: Swift.String? = nil
        )
        {
            self.contactFlowId = contactFlowId
            self.queueId = queueId
        }
    }

}

extension ConnectClientTypes.QueueReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a queue resource for which metrics are returned.
    public struct QueueReference: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the queue.
        public var arn: Swift.String?
        /// The identifier of the queue.
        public var id: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension ConnectClientTypes {
    public enum QueueStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueueStatus(rawValue: rawValue) ?? QueueStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.QueueSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case queueType = "QueueType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queueType = queueType {
            try encodeContainer.encode(queueType.rawValue, forKey: .queueType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let queueTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueType.self, forKey: .queueType)
        queueType = queueTypeDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a queue.
    public struct QueueSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the queue.
        public var arn: Swift.String?
        /// The identifier of the queue.
        public var id: Swift.String?
        /// The name of the queue.
        public var name: Swift.String?
        /// The type of queue.
        public var queueType: ConnectClientTypes.QueueType?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            queueType: ConnectClientTypes.QueueType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.queueType = queueType
        }
    }

}

extension ConnectClientTypes {
    public enum QueueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueType] {
            return [
                .agent,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueueType(rawValue: rawValue) ?? QueueType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.QuickConnect: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case quickConnectARN = "QuickConnectARN"
        case quickConnectConfig = "QuickConnectConfig"
        case quickConnectId = "QuickConnectId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quickConnectARN = quickConnectARN {
            try encodeContainer.encode(quickConnectARN, forKey: .quickConnectARN)
        }
        if let quickConnectConfig = quickConnectConfig {
            try encodeContainer.encode(quickConnectConfig, forKey: .quickConnectConfig)
        }
        if let quickConnectId = quickConnectId {
            try encodeContainer.encode(quickConnectId, forKey: .quickConnectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickConnectARN)
        quickConnectARN = quickConnectARNDecoded
        let quickConnectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickConnectId)
        quickConnectId = quickConnectIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let quickConnectConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnectConfig.self, forKey: .quickConnectConfig)
        quickConnectConfig = quickConnectConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a quick connect.
    public struct QuickConnect: Swift.Equatable {
        /// The description.
        public var description: Swift.String?
        /// The name of the quick connect.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the quick connect.
        public var quickConnectARN: Swift.String?
        /// Contains information about the quick connect.
        public var quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
        /// The identifier for the quick connect.
        public var quickConnectId: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            quickConnectARN: Swift.String? = nil,
            quickConnectConfig: ConnectClientTypes.QuickConnectConfig? = nil,
            quickConnectId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.quickConnectARN = quickConnectARN
            self.quickConnectConfig = quickConnectConfig
            self.quickConnectId = quickConnectId
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.QuickConnectConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneConfig = "PhoneConfig"
        case queueConfig = "QueueConfig"
        case quickConnectType = "QuickConnectType"
        case userConfig = "UserConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneConfig = phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
        if let queueConfig = queueConfig {
            try encodeContainer.encode(queueConfig, forKey: .queueConfig)
        }
        if let quickConnectType = quickConnectType {
            try encodeContainer.encode(quickConnectType.rawValue, forKey: .quickConnectType)
        }
        if let userConfig = userConfig {
            try encodeContainer.encode(userConfig, forKey: .userConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnectType.self, forKey: .quickConnectType)
        quickConnectType = quickConnectTypeDecoded
        let userConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserQuickConnectConfig.self, forKey: .userConfig)
        userConfig = userConfigDecoded
        let queueConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueQuickConnectConfig.self, forKey: .queueConfig)
        queueConfig = queueConfigDecoded
        let phoneConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneNumberQuickConnectConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
    }
}

extension ConnectClientTypes {
    /// Contains configuration settings for a quick connect.
    public struct QuickConnectConfig: Swift.Equatable {
        /// The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
        public var phoneConfig: ConnectClientTypes.PhoneNumberQuickConnectConfig?
        /// The queue configuration. This is required only if QuickConnectType is QUEUE.
        public var queueConfig: ConnectClientTypes.QueueQuickConnectConfig?
        /// The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        /// This member is required.
        public var quickConnectType: ConnectClientTypes.QuickConnectType?
        /// The user configuration. This is required only if QuickConnectType is USER.
        public var userConfig: ConnectClientTypes.UserQuickConnectConfig?

        public init (
            phoneConfig: ConnectClientTypes.PhoneNumberQuickConnectConfig? = nil,
            queueConfig: ConnectClientTypes.QueueQuickConnectConfig? = nil,
            quickConnectType: ConnectClientTypes.QuickConnectType? = nil,
            userConfig: ConnectClientTypes.UserQuickConnectConfig? = nil
        )
        {
            self.phoneConfig = phoneConfig
            self.queueConfig = queueConfig
            self.quickConnectType = quickConnectType
            self.userConfig = userConfig
        }
    }

}

extension ConnectClientTypes.QuickConnectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case quickConnectType = "QuickConnectType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quickConnectType = quickConnectType {
            try encodeContainer.encode(quickConnectType.rawValue, forKey: .quickConnectType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let quickConnectTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnectType.self, forKey: .quickConnectType)
        quickConnectType = quickConnectTypeDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a quick connect.
    public struct QuickConnectSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the quick connect.
        public var arn: Swift.String?
        /// The identifier for the quick connect.
        public var id: Swift.String?
        /// The name of the quick connect.
        public var name: Swift.String?
        /// The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        public var quickConnectType: ConnectClientTypes.QuickConnectType?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            quickConnectType: ConnectClientTypes.QuickConnectType? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.quickConnectType = quickConnectType
        }
    }

}

extension ConnectClientTypes {
    public enum QuickConnectType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case phoneNumber
        case queue
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [QuickConnectType] {
            return [
                .phoneNumber,
                .queue,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .phoneNumber: return "PHONE_NUMBER"
            case .queue: return "QUEUE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuickConnectType(rawValue: rawValue) ?? QuickConnectType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.Reference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ReferenceType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ConnectClientTypes {
    /// A link that an agent selects to complete a given task. You can have up to 4,096 UTF-8 bytes across all references for a contact.
    public struct Reference: Swift.Equatable {
        /// The type of the reference. Only URL type can be added or updated on a contact.
        /// This member is required.
        public var type: ConnectClientTypes.ReferenceType?
        /// A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).
        /// This member is required.
        public var value: Swift.String?

        public init (
            type: ConnectClientTypes.ReferenceType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension ConnectClientTypes {
    public enum ReferenceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceStatus] {
            return [
                .approved,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceStatus(rawValue: rawValue) ?? ReferenceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.ReferenceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
        case url = "Url"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .attachment(attachment):
                try container.encode(attachment, forKey: .attachment)
            case let .url(url):
                try container.encode(url, forKey: .url)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try values.decodeIfPresent(ConnectClientTypes.UrlReference.self, forKey: .url)
        if let url = urlDecoded {
            self = .url(url)
            return
        }
        let attachmentDecoded = try values.decodeIfPresent(ConnectClientTypes.AttachmentReference.self, forKey: .attachment)
        if let attachment = attachmentDecoded {
            self = .attachment(attachment)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a reference. ReferenceSummary contains only one non null field between the URL and attachment based on the reference type.
    public enum ReferenceSummary: Swift.Equatable {
        /// Information about the URL reference if the referenceType is URL. Otherwise, null.
        case url(ConnectClientTypes.UrlReference)
        /// Information about the attachment reference if the referenceType is ATTACHMENT. Otherwise, null.
        case attachment(ConnectClientTypes.AttachmentReference)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectClientTypes {
    public enum ReferenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachment
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceType] {
            return [
                .attachment,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachment: return "ATTACHMENT"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceType(rawValue: rawValue) ?? ReferenceType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource already has that name.
public struct ResourceConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// That resource is already in use. Please try another.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The identifier for the resource.
    public var resourceId: Swift.String?
    /// The type of resource.
    public var resourceType: ConnectClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: ConnectClientTypes.ResourceType?
    let resourceId: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message about the resource.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contact
        case contactFlow
        case hierarchyGroup
        case hierarchyLevel
        case instance
        case participant
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .contact,
                .contactFlow,
                .hierarchyGroup,
                .hierarchyLevel,
                .instance,
                .participant,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contact: return "CONTACT"
            case .contactFlow: return "CONTACT_FLOW"
            case .hierarchyGroup: return "HIERARCHY_GROUP"
            case .hierarchyLevel: return "HIERARCHY_LEVEL"
            case .instance: return "INSTANCE"
            case .participant: return "PARTICIPANT"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ResumeContactRecordingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initialContactId = initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension ResumeContactRecordingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/resume-recording"
    }
}

public struct ResumeContactRecordingInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct ResumeContactRecordingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let initialContactId: Swift.String?
}

extension ResumeContactRecordingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
    }
}

extension ResumeContactRecordingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResumeContactRecordingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResumeContactRecordingOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeContactRecordingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResumeContactRecordingOutputResponse: Swift.Equatable {

}

extension ConnectClientTypes.RoutingProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
        case description = "Description"
        case instanceId = "InstanceId"
        case mediaConcurrencies = "MediaConcurrencies"
        case name = "Name"
        case routingProfileArn = "RoutingProfileArn"
        case routingProfileId = "RoutingProfileId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultOutboundQueueId = defaultOutboundQueueId {
            try encodeContainer.encode(defaultOutboundQueueId, forKey: .defaultOutboundQueueId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let mediaConcurrencies = mediaConcurrencies {
            var mediaConcurrenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaConcurrencies)
            for mediaconcurrencies0 in mediaConcurrencies {
                try mediaConcurrenciesContainer.encode(mediaconcurrencies0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let routingProfileArn = routingProfileArn {
            try encodeContainer.encode(routingProfileArn, forKey: .routingProfileArn)
        }
        if let routingProfileId = routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let routingProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileArn)
        routingProfileArn = routingProfileArnDecoded
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mediaConcurrenciesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.MediaConcurrency?].self, forKey: .mediaConcurrencies)
        var mediaConcurrenciesDecoded0:[ConnectClientTypes.MediaConcurrency]? = nil
        if let mediaConcurrenciesContainer = mediaConcurrenciesContainer {
            mediaConcurrenciesDecoded0 = [ConnectClientTypes.MediaConcurrency]()
            for structure0 in mediaConcurrenciesContainer {
                if let structure0 = structure0 {
                    mediaConcurrenciesDecoded0?.append(structure0)
                }
            }
        }
        mediaConcurrencies = mediaConcurrenciesDecoded0
        let defaultOutboundQueueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOutboundQueueId)
        defaultOutboundQueueId = defaultOutboundQueueIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a routing profile.
    public struct RoutingProfile: Swift.Equatable {
        /// The identifier of the default outbound queue for this routing profile.
        public var defaultOutboundQueueId: Swift.String?
        /// The description of the routing profile.
        public var description: Swift.String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public var instanceId: Swift.String?
        /// The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        public var mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
        /// The name of the routing profile.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the routing profile.
        public var routingProfileArn: Swift.String?
        /// The identifier of the routing profile.
        public var routingProfileId: Swift.String?
        /// One or more tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            defaultOutboundQueueId: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]? = nil,
            name: Swift.String? = nil,
            routingProfileArn: Swift.String? = nil,
            routingProfileId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.defaultOutboundQueueId = defaultOutboundQueueId
            self.description = description
            self.instanceId = instanceId
            self.mediaConcurrencies = mediaConcurrencies
            self.name = name
            self.routingProfileArn = routingProfileArn
            self.routingProfileId = routingProfileId
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.RoutingProfileQueueConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delay = "Delay"
        case priority = "Priority"
        case queueReference = "QueueReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if delay != 0 {
            try encodeContainer.encode(delay, forKey: .delay)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let queueReference = queueReference {
            try encodeContainer.encode(queueReference, forKey: .queueReference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueReferenceDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.RoutingProfileQueueReference.self, forKey: .queueReference)
        queueReference = queueReferenceDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let delayDecoded = try containerValues.decode(Swift.Int.self, forKey: .delay)
        delay = delayDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the queue and channel for which priority and delay can be set.
    public struct RoutingProfileQueueConfig: Swift.Equatable {
        /// The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html) in the Amazon Connect Administrator Guide.
        /// This member is required.
        public var delay: Swift.Int
        /// The order in which contacts are to be handled for the queue. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html).
        /// This member is required.
        public var priority: Swift.Int
        /// Contains information about a queue resource.
        /// This member is required.
        public var queueReference: ConnectClientTypes.RoutingProfileQueueReference?

        public init (
            delay: Swift.Int = 0,
            priority: Swift.Int = 0,
            queueReference: ConnectClientTypes.RoutingProfileQueueReference? = nil
        )
        {
            self.delay = delay
            self.priority = priority
            self.queueReference = queueReference
        }
    }

}

extension ConnectClientTypes.RoutingProfileQueueConfigSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
        case delay = "Delay"
        case priority = "Priority"
        case queueArn = "QueueArn"
        case queueId = "QueueId"
        case queueName = "QueueName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if delay != 0 {
            try encodeContainer.encode(delay, forKey: .delay)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let queueArn = queueArn {
            try encodeContainer.encode(queueArn, forKey: .queueArn)
        }
        if let queueId = queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let queueName = queueName {
            try encodeContainer.encode(queueName, forKey: .queueName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let queueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
        let queueNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueName)
        queueName = queueNameDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let delayDecoded = try containerValues.decode(Swift.Int.self, forKey: .delay)
        delay = delayDecoded
        let channelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a routing profile queue.
    public struct RoutingProfileQueueConfigSummary: Swift.Equatable {
        /// The channels this queue supports.
        /// This member is required.
        public var channel: ConnectClientTypes.Channel?
        /// The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html) in the Amazon Connect Administrator Guide.
        /// This member is required.
        public var delay: Swift.Int
        /// The order in which contacts are to be handled for the queue. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html).
        /// This member is required.
        public var priority: Swift.Int
        /// The Amazon Resource Name (ARN) of the queue.
        /// This member is required.
        public var queueArn: Swift.String?
        /// The identifier for the queue.
        /// This member is required.
        public var queueId: Swift.String?
        /// The name of the queue.
        /// This member is required.
        public var queueName: Swift.String?

        public init (
            channel: ConnectClientTypes.Channel? = nil,
            delay: Swift.Int = 0,
            priority: Swift.Int = 0,
            queueArn: Swift.String? = nil,
            queueId: Swift.String? = nil,
            queueName: Swift.String? = nil
        )
        {
            self.channel = channel
            self.delay = delay
            self.priority = priority
            self.queueArn = queueArn
            self.queueId = queueId
            self.queueName = queueName
        }
    }

}

extension ConnectClientTypes.RoutingProfileQueueReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
        case queueId = "QueueId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = channel {
            try encodeContainer.encode(channel.rawValue, forKey: .channel)
        }
        if let queueId = queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let channelDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension ConnectClientTypes {
    /// Contains the channel and queue identifier for a routing profile.
    public struct RoutingProfileQueueReference: Swift.Equatable {
        /// The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        /// This member is required.
        public var channel: ConnectClientTypes.Channel?
        /// The identifier for the queue.
        /// This member is required.
        public var queueId: Swift.String?

        public init (
            channel: ConnectClientTypes.Channel? = nil,
            queueId: Swift.String? = nil
        )
        {
            self.channel = channel
            self.queueId = queueId
        }
    }

}

extension ConnectClientTypes.RoutingProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a routing profile.
    public struct RoutingProfileSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the routing profile.
        public var arn: Swift.String?
        /// The identifier of the routing profile.
        public var id: Swift.String?
        /// The name of the routing profile.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension ConnectClientTypes.S3Config: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case bucketPrefix = "BucketPrefix"
        case encryptionConfig = "EncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let encryptionConfig = encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

extension ConnectClientTypes {
    /// Information about the Amazon Simple Storage Service (Amazon S3) storage type.
    public struct S3Config: Swift.Equatable {
        /// The S3 bucket name.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The S3 bucket prefix.
        /// This member is required.
        public var bucketPrefix: Swift.String?
        /// The Amazon S3 encryption configuration.
        public var encryptionConfig: ConnectClientTypes.EncryptionConfig?

        public init (
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            encryptionConfig: ConnectClientTypes.EncryptionConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.encryptionConfig = encryptionConfig
        }
    }

}

extension ConnectClientTypes.SecurityKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case creationTime = "CreationTime"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension ConnectClientTypes {
    /// Configuration information of the security key.
    public struct SecurityKey: Swift.Equatable {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public var associationId: Swift.String?
        /// When the security key was created.
        public var creationTime: ClientRuntime.Date?
        /// The key of the security key.
        public var key: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            key: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.creationTime = creationTime
            self.key = key
        }
    }

}

extension ConnectClientTypes.SecurityProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case organizationResourceId = "OrganizationResourceId"
        case securityProfileName = "SecurityProfileName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let organizationResourceId = organizationResourceId {
            try encodeContainer.encode(organizationResourceId, forKey: .organizationResourceId)
        }
        if let securityProfileName = securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let organizationResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationResourceId)
        organizationResourceId = organizationResourceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a security profile.
    public struct SecurityProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the secruity profile.
        public var arn: Swift.String?
        /// The description of the security profile.
        public var description: Swift.String?
        /// The identifier for the security profile.
        public var id: Swift.String?
        /// The organization resource identifier for the security profile.
        public var organizationResourceId: Swift.String?
        /// The name for the security profile.
        public var securityProfileName: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            organizationResourceId: Swift.String? = nil,
            securityProfileName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.organizationResourceId = organizationResourceId
            self.securityProfileName = securityProfileName
            self.tags = tags
        }
    }

}

extension ConnectClientTypes.SecurityProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about a security profile.
    public struct SecurityProfileSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the security profile.
        public var arn: Swift.String?
        /// The identifier of the security profile.
        public var id: Swift.String?
        /// The name of the security profile.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service quota has been exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case salesforce
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .salesforce,
                .zendesk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .salesforce: return "SALESFORCE"
            case .zendesk: return "ZENDESK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension StartChatContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case initialMessage = "InitialMessage"
        case instanceId = "InstanceId"
        case participantDetails = "ParticipantDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactFlowId = contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let initialMessage = initialMessage {
            try encodeContainer.encode(initialMessage, forKey: .initialMessage)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let participantDetails = participantDetails {
            try encodeContainer.encode(participantDetails, forKey: .participantDetails)
        }
    }
}

extension StartChatContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/chat"
    }
}

public struct StartChatContactInput: Swift.Equatable {
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in contact flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
    public var attributes: [Swift.String:Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the contact flow for initiating the chat. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to Routing, Contact Flows. Choose the contact flow. On the contact flow page, under the name of the contact flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold: arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The initial message to be sent to the newly created chat.
    public var initialMessage: ConnectClientTypes.ChatMessage?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Information identifying the participant.
    /// This member is required.
    public var participantDetails: ConnectClientTypes.ParticipantDetails?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        initialMessage: ConnectClientTypes.ChatMessage? = nil,
        instanceId: Swift.String? = nil,
        participantDetails: ConnectClientTypes.ParticipantDetails? = nil
    )
    {
        self.attributes = attributes
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.initialMessage = initialMessage
        self.instanceId = instanceId
        self.participantDetails = participantDetails
    }
}

struct StartChatContactInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactFlowId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let participantDetails: ConnectClientTypes.ParticipantDetails?
    let initialMessage: ConnectClientTypes.ChatMessage?
    let clientToken: Swift.String?
}

extension StartChatContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case initialMessage = "InitialMessage"
        case instanceId = "InstanceId"
        case participantDetails = "ParticipantDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let participantDetailsDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ParticipantDetails.self, forKey: .participantDetails)
        participantDetails = participantDetailsDecoded
        let initialMessageDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ChatMessage.self, forKey: .initialMessage)
        initialMessage = initialMessageDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartChatContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartChatContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartChatContactOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartChatContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartChatContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
            self.participantId = output.participantId
            self.participantToken = output.participantToken
        } else {
            self.contactId = nil
            self.participantId = nil
            self.participantToken = nil
        }
    }
}

public struct StartChatContactOutputResponse: Swift.Equatable {
    /// The identifier of this contact within the Amazon Connect instance.
    public var contactId: Swift.String?
    /// The identifier for a chat participant. The participantId for a chat participant is the same throughout the chat lifecycle.
    public var participantId: Swift.String?
    /// The token used by the chat participant to call [CreateParticipantConnection](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html). The participant token is valid for the lifetime of a chat participant.
    public var participantToken: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        participantId: Swift.String? = nil,
        participantToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.participantId = participantId
        self.participantToken = participantToken
    }
}

struct StartChatContactOutputResponseBody: Swift.Equatable {
    let contactId: Swift.String?
    let participantId: Swift.String?
    let participantToken: Swift.String?
}

extension StartChatContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case participantId = "ParticipantId"
        case participantToken = "ParticipantToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let participantTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantToken)
        participantToken = participantTokenDecoded
    }
}

extension StartContactRecordingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
        case voiceRecordingConfiguration = "VoiceRecordingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initialContactId = initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let voiceRecordingConfiguration = voiceRecordingConfiguration {
            try encodeContainer.encode(voiceRecordingConfiguration, forKey: .voiceRecordingConfiguration)
        }
    }
}

extension StartContactRecordingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/start-recording"
    }
}

public struct StartContactRecordingInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The person being recorded.
    /// This member is required.
    public var voiceRecordingConfiguration: ConnectClientTypes.VoiceRecordingConfiguration?

    public init (
        contactId: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        voiceRecordingConfiguration: ConnectClientTypes.VoiceRecordingConfiguration? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
        self.voiceRecordingConfiguration = voiceRecordingConfiguration
    }
}

struct StartContactRecordingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let initialContactId: Swift.String?
    let voiceRecordingConfiguration: ConnectClientTypes.VoiceRecordingConfiguration?
}

extension StartContactRecordingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
        case voiceRecordingConfiguration = "VoiceRecordingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let voiceRecordingConfigurationDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VoiceRecordingConfiguration.self, forKey: .voiceRecordingConfiguration)
        voiceRecordingConfiguration = voiceRecordingConfigurationDecoded
    }
}

extension StartContactRecordingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartContactRecordingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartContactRecordingOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartContactRecordingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartContactRecordingOutputResponse: Swift.Equatable {

}

extension StartContactStreamingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatStreamingConfiguration = "ChatStreamingConfiguration"
        case clientToken = "ClientToken"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chatStreamingConfiguration = chatStreamingConfiguration {
            try encodeContainer.encode(chatStreamingConfiguration, forKey: .chatStreamingConfiguration)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension StartContactStreamingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/start-streaming"
    }
}

public struct StartContactStreamingInput: Swift.Equatable {
    /// The streaming configuration, such as the Amazon SNS streaming endpoint.
    /// This member is required.
    public var chatStreamingConfiguration: ConnectClientTypes.ChatStreamingConfiguration?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        chatStreamingConfiguration: ConnectClientTypes.ChatStreamingConfiguration? = nil,
        clientToken: Swift.String? = nil,
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.chatStreamingConfiguration = chatStreamingConfiguration
        self.clientToken = clientToken
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

struct StartContactStreamingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let chatStreamingConfiguration: ConnectClientTypes.ChatStreamingConfiguration?
    let clientToken: Swift.String?
}

extension StartContactStreamingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatStreamingConfiguration = "ChatStreamingConfiguration"
        case clientToken = "ClientToken"
        case contactId = "ContactId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let chatStreamingConfigurationDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ChatStreamingConfiguration.self, forKey: .chatStreamingConfiguration)
        chatStreamingConfiguration = chatStreamingConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartContactStreamingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartContactStreamingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartContactStreamingOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartContactStreamingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartContactStreamingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingId = output.streamingId
        } else {
            self.streamingId = nil
        }
    }
}

public struct StartContactStreamingOutputResponse: Swift.Equatable {
    /// The identifier of the streaming configuration enabled.
    /// This member is required.
    public var streamingId: Swift.String?

    public init (
        streamingId: Swift.String? = nil
    )
    {
        self.streamingId = streamingId
    }
}

struct StartContactStreamingOutputResponseBody: Swift.Equatable {
    let streamingId: Swift.String?
}

extension StartContactStreamingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingId = "StreamingId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingId)
        streamingId = streamingIdDecoded
    }
}

extension StartOutboundVoiceContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerMachineDetectionConfig = "AnswerMachineDetectionConfig"
        case attributes = "Attributes"
        case campaignId = "CampaignId"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case instanceId = "InstanceId"
        case queueId = "QueueId"
        case sourcePhoneNumber = "SourcePhoneNumber"
        case trafficType = "TrafficType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answerMachineDetectionConfig = answerMachineDetectionConfig {
            try encodeContainer.encode(answerMachineDetectionConfig, forKey: .answerMachineDetectionConfig)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let campaignId = campaignId {
            try encodeContainer.encode(campaignId, forKey: .campaignId)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactFlowId = contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let destinationPhoneNumber = destinationPhoneNumber {
            try encodeContainer.encode(destinationPhoneNumber, forKey: .destinationPhoneNumber)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let queueId = queueId {
            try encodeContainer.encode(queueId, forKey: .queueId)
        }
        if let sourcePhoneNumber = sourcePhoneNumber {
            try encodeContainer.encode(sourcePhoneNumber, forKey: .sourcePhoneNumber)
        }
        if let trafficType = trafficType {
            try encodeContainer.encode(trafficType.rawValue, forKey: .trafficType)
        }
    }
}

extension StartOutboundVoiceContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/outbound-voice"
    }
}

public struct StartOutboundVoiceContactInput: Swift.Equatable {
    /// Configuration of the answering machine detection for this outbound call.
    public var answerMachineDetectionConfig: ConnectClientTypes.AnswerMachineDetectionConfig?
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in contact flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
    public var attributes: [Swift.String:Swift.String]?
    /// The campaign identifier of the outbound communication.
    public var campaignId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned.
    public var clientToken: Swift.String?
    /// The identifier of the contact flow for the outbound call. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to Routing, Contact Flows. Choose the contact flow. On the contact flow page, under the name of the contact flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold: arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The phone number of the customer, in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the contact flow is used. If you do not specify a queue, you must specify a source phone number.
    public var queueId: Swift.String?
    /// The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
    public var sourcePhoneNumber: Swift.String?
    /// Denotes the class of traffic. Calls with different traffic types are handled differently by Amazon Connect. The default value is GENERAL. Use CAMPAIGN if EnableAnswerMachineDetection is set to true. For all other cases, use GENERAL.
    public var trafficType: ConnectClientTypes.TrafficType?

    public init (
        answerMachineDetectionConfig: ConnectClientTypes.AnswerMachineDetectionConfig? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        campaignId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        sourcePhoneNumber: Swift.String? = nil,
        trafficType: ConnectClientTypes.TrafficType? = nil
    )
    {
        self.answerMachineDetectionConfig = answerMachineDetectionConfig
        self.attributes = attributes
        self.campaignId = campaignId
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.destinationPhoneNumber = destinationPhoneNumber
        self.instanceId = instanceId
        self.queueId = queueId
        self.sourcePhoneNumber = sourcePhoneNumber
        self.trafficType = trafficType
    }
}

struct StartOutboundVoiceContactInputBody: Swift.Equatable {
    let destinationPhoneNumber: Swift.String?
    let contactFlowId: Swift.String?
    let instanceId: Swift.String?
    let clientToken: Swift.String?
    let sourcePhoneNumber: Swift.String?
    let queueId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let answerMachineDetectionConfig: ConnectClientTypes.AnswerMachineDetectionConfig?
    let campaignId: Swift.String?
    let trafficType: ConnectClientTypes.TrafficType?
}

extension StartOutboundVoiceContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerMachineDetectionConfig = "AnswerMachineDetectionConfig"
        case attributes = "Attributes"
        case campaignId = "CampaignId"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case instanceId = "InstanceId"
        case queueId = "QueueId"
        case sourcePhoneNumber = "SourcePhoneNumber"
        case trafficType = "TrafficType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcePhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePhoneNumber)
        sourcePhoneNumber = sourcePhoneNumberDecoded
        let queueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueId)
        queueId = queueIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let answerMachineDetectionConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AnswerMachineDetectionConfig.self, forKey: .answerMachineDetectionConfig)
        answerMachineDetectionConfig = answerMachineDetectionConfigDecoded
        let campaignIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignId)
        campaignId = campaignIdDecoded
        let trafficTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.TrafficType.self, forKey: .trafficType)
        trafficType = trafficTypeDecoded
    }
}

extension StartOutboundVoiceContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartOutboundVoiceContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DestinationNotAllowedException" : self = .destinationNotAllowedException(try DestinationNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OutboundContactNotPermittedException" : self = .outboundContactNotPermittedException(try OutboundContactNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartOutboundVoiceContactOutputError: Swift.Error, Swift.Equatable {
    case destinationNotAllowedException(DestinationNotAllowedException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case outboundContactNotPermittedException(OutboundContactNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartOutboundVoiceContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartOutboundVoiceContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

public struct StartOutboundVoiceContactOutputResponse: Swift.Equatable {
    /// The identifier of this contact within the Amazon Connect instance.
    public var contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct StartOutboundVoiceContactOutputResponseBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension StartOutboundVoiceContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension StartTaskContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case description = "Description"
        case instanceId = "InstanceId"
        case name = "Name"
        case previousContactId = "PreviousContactId"
        case references = "References"
        case scheduledTime = "ScheduledTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contactFlowId = contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let previousContactId = previousContactId {
            try encodeContainer.encode(previousContactId, forKey: .previousContactId)
        }
        if let references = references {
            var referencesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .references)
            for (dictKey0, contactreferences0) in references {
                try referencesContainer.encode(contactreferences0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scheduledTime = scheduledTime {
            try encodeContainer.encode(scheduledTime.timeIntervalSince1970, forKey: .scheduledTime)
        }
    }
}

extension StartTaskContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/task"
    }
}

public struct StartTaskContactInput: Swift.Equatable {
    /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in contact flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
    public var attributes: [Swift.String:Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the contact flow for initiating the tasks. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to Routing, Contact Flows. Choose the contact flow. On the contact flow page, under the name of the contact flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold: arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// A description of the task that is shown to an agent in the Contact Control Panel (CCP).
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of a task that is shown to an agent in the Contact Control Panel (CCP).
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the previous chat, voice, or task contact.
    public var previousContactId: Swift.String?
    /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP).
    public var references: [Swift.String:ConnectClientTypes.Reference]?
    /// The timestamp, in Unix Epoch seconds format, at which to start running the inbound contact flow. The scheduled time cannot be in the past. It must be within up to 6 days in future.
    public var scheduledTime: ClientRuntime.Date?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        contactFlowId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        previousContactId: Swift.String? = nil,
        references: [Swift.String:ConnectClientTypes.Reference]? = nil,
        scheduledTime: ClientRuntime.Date? = nil
    )
    {
        self.attributes = attributes
        self.clientToken = clientToken
        self.contactFlowId = contactFlowId
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.previousContactId = previousContactId
        self.references = references
        self.scheduledTime = scheduledTime
    }
}

struct StartTaskContactInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let previousContactId: Swift.String?
    let contactFlowId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let name: Swift.String?
    let references: [Swift.String:ConnectClientTypes.Reference]?
    let description: Swift.String?
    let clientToken: Swift.String?
    let scheduledTime: ClientRuntime.Date?
}

extension StartTaskContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case clientToken = "ClientToken"
        case contactFlowId = "ContactFlowId"
        case description = "Description"
        case instanceId = "InstanceId"
        case name = "Name"
        case previousContactId = "PreviousContactId"
        case references = "References"
        case scheduledTime = "ScheduledTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let previousContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previousContactId)
        previousContactId = previousContactIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let referencesContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.Reference?].self, forKey: .references)
        var referencesDecoded0: [Swift.String:ConnectClientTypes.Reference]? = nil
        if let referencesContainer = referencesContainer {
            referencesDecoded0 = [Swift.String:ConnectClientTypes.Reference]()
            for (key0, reference0) in referencesContainer {
                if let reference0 = reference0 {
                    referencesDecoded0?[key0] = reference0
                }
            }
        }
        references = referencesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let scheduledTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
    }
}

extension StartTaskContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartTaskContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartTaskContactOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartTaskContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartTaskContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

public struct StartTaskContactOutputResponse: Swift.Equatable {
    /// The identifier of this contact within the Amazon Connect instance.
    public var contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct StartTaskContactOutputResponseBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension StartTaskContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension ConnectClientTypes {
    public enum Statistic: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avg
        case max
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [Statistic] {
            return [
                .avg,
                .max,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avg: return "AVG"
            case .max: return "MAX"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Statistic(rawValue: rawValue) ?? Statistic.sdkUnknown(rawValue)
        }
    }
}

extension StopContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension StopContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/stop"
    }
}

public struct StopContactInput: Swift.Equatable {
    /// The ID of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
    }
}

struct StopContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let instanceId: Swift.String?
}

extension StopContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension StopContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContactNotFoundException" : self = .contactNotFoundException(try ContactNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopContactOutputError: Swift.Error, Swift.Equatable {
    case contactNotFoundException(ContactNotFoundException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopContactOutputResponse: Swift.Equatable {

}

extension StopContactRecordingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initialContactId = initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension StopContactRecordingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/stop-recording"
    }
}

public struct StopContactRecordingInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct StopContactRecordingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let initialContactId: Swift.String?
}

extension StopContactRecordingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
    }
}

extension StopContactRecordingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopContactRecordingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopContactRecordingOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopContactRecordingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopContactRecordingOutputResponse: Swift.Equatable {

}

extension StopContactStreamingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case streamingId = "StreamingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let streamingId = streamingId {
            try encodeContainer.encode(streamingId, forKey: .streamingId)
        }
    }
}

extension StopContactStreamingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/stop-streaming"
    }
}

public struct StopContactStreamingInput: Swift.Equatable {
    /// The identifier of the contact. This is the identifier of the contact that is associated with the first interaction with the contact center.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the streaming configuration enabled.
    /// This member is required.
    public var streamingId: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        streamingId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.streamingId = streamingId
    }
}

struct StopContactStreamingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let streamingId: Swift.String?
}

extension StopContactStreamingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case streamingId = "StreamingId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let streamingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingId)
        streamingId = streamingIdDecoded
    }
}

extension StopContactStreamingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopContactStreamingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopContactStreamingOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopContactStreamingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopContactStreamingOutputResponse: Swift.Equatable {

}

extension ConnectClientTypes {
    public enum StorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kinesisFirehose
        case kinesisStream
        case kinesisVideoStream
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageType] {
            return [
                .kinesisFirehose,
                .kinesisStream,
                .kinesisVideoStream,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kinesisFirehose: return "KINESIS_FIREHOSE"
            case .kinesisStream: return "KINESIS_STREAM"
            case .kinesisVideoStream: return "KINESIS_VIDEO_STREAM"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageType(rawValue: rawValue) ?? StorageType.sdkUnknown(rawValue)
        }
    }
}

extension SuspendContactRecordingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let initialContactId = initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension SuspendContactRecordingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/suspend-recording"
    }
}

public struct SuspendContactRecordingInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct SuspendContactRecordingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let initialContactId: Swift.String?
}

extension SuspendContactRecordingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
    }
}

extension SuspendContactRecordingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SuspendContactRecordingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SuspendContactRecordingOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SuspendContactRecordingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SuspendContactRecordingOutputResponse: Swift.Equatable {

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ConnectClientTypes.Threshold: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison = "Comparison"
        case thresholdValue = "ThresholdValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let thresholdValue = thresholdValue {
            try encodeContainer.encode(thresholdValue, forKey: .thresholdValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.Comparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let thresholdValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .thresholdValue)
        thresholdValue = thresholdValueDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the threshold for service level metrics.
    public struct Threshold: Swift.Equatable {
        /// The type of comparison. Only "less than" (LT) comparisons are supported.
        public var comparison: ConnectClientTypes.Comparison?
        /// The threshold value to compare.
        public var thresholdValue: Swift.Double?

        public init (
            comparison: ConnectClientTypes.Comparison? = nil,
            thresholdValue: Swift.Double? = nil
        )
        {
            self.comparison = comparison
            self.thresholdValue = thresholdValue
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The throttling limit has been exceeded.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes {
    public enum TrafficType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case campaign
        case general
        case sdkUnknown(Swift.String)

        public static var allCases: [TrafficType] {
            return [
                .campaign,
                .general,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .campaign: return "CAMPAIGN"
            case .general: return "GENERAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrafficType(rawValue: rawValue) ?? TrafficType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes {
    public enum Unit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case count
        case percent
        case seconds
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .count,
                .percent,
                .seconds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .count: return "COUNT"
            case .percent: return "PERCENT"
            case .seconds: return "SECONDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateAgentStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayOrder = "DisplayOrder"
        case name = "Name"
        case resetOrderNumber = "ResetOrderNumber"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayOrder = displayOrder {
            try encodeContainer.encode(displayOrder, forKey: .displayOrder)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if resetOrderNumber != false {
            try encodeContainer.encode(resetOrderNumber, forKey: .resetOrderNumber)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension UpdateAgentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let agentStatusId = agentStatusId else {
            return nil
        }
        return "/agent-status/\(instanceId.urlPercentEncoding())/\(agentStatusId.urlPercentEncoding())"
    }
}

public struct UpdateAgentStatusInput: Swift.Equatable {
    /// The identifier of the agent status.
    /// This member is required.
    public var agentStatusId: Swift.String?
    /// The description of the agent status.
    public var description: Swift.String?
    /// The display order of the agent status.
    public var displayOrder: Swift.Int?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the agent status.
    public var name: Swift.String?
    /// A number indicating the reset order of the agent status.
    public var resetOrderNumber: Swift.Bool
    /// The state of the agent status.
    public var state: ConnectClientTypes.AgentStatusState?

    public init (
        agentStatusId: Swift.String? = nil,
        description: Swift.String? = nil,
        displayOrder: Swift.Int? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        resetOrderNumber: Swift.Bool = false,
        state: ConnectClientTypes.AgentStatusState? = nil
    )
    {
        self.agentStatusId = agentStatusId
        self.description = description
        self.displayOrder = displayOrder
        self.instanceId = instanceId
        self.name = name
        self.resetOrderNumber = resetOrderNumber
        self.state = state
    }
}

struct UpdateAgentStatusInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let state: ConnectClientTypes.AgentStatusState?
    let displayOrder: Swift.Int?
    let resetOrderNumber: Swift.Bool
}

extension UpdateAgentStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayOrder = "DisplayOrder"
        case name = "Name"
        case resetOrderNumber = "ResetOrderNumber"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.AgentStatusState.self, forKey: .state)
        state = stateDecoded
        let displayOrderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .displayOrder)
        displayOrder = displayOrderDecoded
        let resetOrderNumberDecoded = try containerValues.decode(Swift.Bool.self, forKey: .resetOrderNumber)
        resetOrderNumber = resetOrderNumberDecoded
    }
}

extension UpdateAgentStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAgentStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAgentStatusOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAgentStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAgentStatusOutputResponse: Swift.Equatable {

}

extension UpdateContactAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let initialContactId = initialContactId {
            try encodeContainer.encode(initialContactId, forKey: .initialContactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension UpdateContactAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/attributes"
    }
}

public struct UpdateContactAttributesInput: Swift.Equatable {
    /// The Amazon Connect attributes. These attributes can be accessed in contact flows just like any other contact attributes. You can have up to 32,768 UTF-8 bytes across all attributes for a contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
    /// This member is required.
    public var attributes: [Swift.String:Swift.String]?
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
    /// This member is required.
    public var initialContactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        initialContactId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.initialContactId = initialContactId
        self.instanceId = instanceId
    }
}

struct UpdateContactAttributesInputBody: Swift.Equatable {
    let initialContactId: Swift.String?
    let instanceId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
}

extension UpdateContactAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case initialContactId = "InitialContactId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension UpdateContactAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactAttributesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactAttributesOutputResponse: Swift.Equatable {

}

extension UpdateContactFlowContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

extension UpdateContactFlowContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowId = contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())/content"
    }
}

public struct UpdateContactFlowContentInput: Swift.Equatable {
    /// The identifier of the contact flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The JSON string that represents contact flow’s content. For an example, see [Example contact flow in Amazon Connect Flow language](https://docs.aws.amazon.com/connect/latest/adminguide/flow-language-example.html) in the Amazon Connect Administrator Guide.
    /// This member is required.
    public var content: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        contactFlowId: Swift.String? = nil,
        content: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.content = content
        self.instanceId = instanceId
    }
}

struct UpdateContactFlowContentInputBody: Swift.Equatable {
    let content: Swift.String?
}

extension UpdateContactFlowContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension UpdateContactFlowContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactFlowContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContactFlowException" : self = .invalidContactFlowException(try InvalidContactFlowException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactFlowContentOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidContactFlowException(InvalidContactFlowException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactFlowContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactFlowContentOutputResponse: Swift.Equatable {

}

extension UpdateContactFlowMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowState = "ContactFlowState"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactFlowState = contactFlowState {
            try encodeContainer.encode(contactFlowState.rawValue, forKey: .contactFlowState)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateContactFlowMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowId = contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())/metadata"
    }
}

public struct UpdateContactFlowMetadataInput: Swift.Equatable {
    /// The identifier of the contact flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The state of contact flow.
    public var contactFlowState: ConnectClientTypes.ContactFlowState?
    /// The description of the contact flow.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// TThe name of the contact flow.
    public var name: Swift.String?

    public init (
        contactFlowId: Swift.String? = nil,
        contactFlowState: ConnectClientTypes.ContactFlowState? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.contactFlowState = contactFlowState
        self.description = description
        self.instanceId = instanceId
        self.name = name
    }
}

struct UpdateContactFlowMetadataInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let contactFlowState: ConnectClientTypes.ContactFlowState?
}

extension UpdateContactFlowMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowState = "ContactFlowState"
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contactFlowStateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowState.self, forKey: .contactFlowState)
        contactFlowState = contactFlowStateDecoded
    }
}

extension UpdateContactFlowMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactFlowMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactFlowMetadataOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactFlowMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactFlowMetadataOutputResponse: Swift.Equatable {

}

extension UpdateContactFlowModuleContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

extension UpdateContactFlowModuleContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowModuleId = contactFlowModuleId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())/\(contactFlowModuleId.urlPercentEncoding())/content"
    }
}

public struct UpdateContactFlowModuleContentInput: Swift.Equatable {
    /// The identifier of the contact flow module.
    /// This member is required.
    public var contactFlowModuleId: Swift.String?
    /// The content of the contact flow module.
    /// This member is required.
    public var content: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        contactFlowModuleId: Swift.String? = nil,
        content: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.contactFlowModuleId = contactFlowModuleId
        self.content = content
        self.instanceId = instanceId
    }
}

struct UpdateContactFlowModuleContentInputBody: Swift.Equatable {
    let content: Swift.String?
}

extension UpdateContactFlowModuleContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension UpdateContactFlowModuleContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactFlowModuleContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContactFlowModuleException" : self = .invalidContactFlowModuleException(try InvalidContactFlowModuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactFlowModuleContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidContactFlowModuleException(InvalidContactFlowModuleException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactFlowModuleContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactFlowModuleContentOutputResponse: Swift.Equatable {

}

extension UpdateContactFlowModuleMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension UpdateContactFlowModuleMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowModuleId = contactFlowModuleId else {
            return nil
        }
        return "/contact-flow-modules/\(instanceId.urlPercentEncoding())/\(contactFlowModuleId.urlPercentEncoding())/metadata"
    }
}

public struct UpdateContactFlowModuleMetadataInput: Swift.Equatable {
    /// The identifier of the contact flow module.
    /// This member is required.
    public var contactFlowModuleId: Swift.String?
    /// The description of the contact flow module.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the contact flow module.
    public var name: Swift.String?
    /// The state of contact flow module.
    public var state: ConnectClientTypes.ContactFlowModuleState?

    public init (
        contactFlowModuleId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        state: ConnectClientTypes.ContactFlowModuleState? = nil
    )
    {
        self.contactFlowModuleId = contactFlowModuleId
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.state = state
    }
}

struct UpdateContactFlowModuleMetadataInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let state: ConnectClientTypes.ContactFlowModuleState?
}

extension UpdateContactFlowModuleMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.ContactFlowModuleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdateContactFlowModuleMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactFlowModuleMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactFlowModuleMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactFlowModuleMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactFlowModuleMetadataOutputResponse: Swift.Equatable {

}

extension UpdateContactFlowNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateContactFlowNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactFlowId = contactFlowId else {
            return nil
        }
        return "/contact-flows/\(instanceId.urlPercentEncoding())/\(contactFlowId.urlPercentEncoding())/name"
    }
}

public struct UpdateContactFlowNameInput: Swift.Equatable {
    /// The identifier of the contact flow.
    /// This member is required.
    public var contactFlowId: Swift.String?
    /// The description of the contact flow.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the contact flow.
    public var name: Swift.String?

    public init (
        contactFlowId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.contactFlowId = contactFlowId
        self.description = description
        self.instanceId = instanceId
        self.name = name
    }
}

struct UpdateContactFlowNameInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateContactFlowNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateContactFlowNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactFlowNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactFlowNameOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactFlowNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactFlowNameOutputResponse: Swift.Equatable {

}

extension UpdateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case references = "References"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let references = references {
            var referencesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .references)
            for (dictKey0, contactreferences0) in references {
                try referencesContainer.encode(contactreferences0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let contactId = contactId else {
            return nil
        }
        return "/contacts/\(instanceId.urlPercentEncoding())/\(contactId.urlPercentEncoding())"
    }
}

public struct UpdateContactInput: Swift.Equatable {
    /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with your contact center.
    /// This member is required.
    public var contactId: Swift.String?
    /// The description of the contact.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the contact.
    public var name: Swift.String?
    /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP).
    public var references: [Swift.String:ConnectClientTypes.Reference]?

    public init (
        contactId: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        references: [Swift.String:ConnectClientTypes.Reference]? = nil
    )
    {
        self.contactId = contactId
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.references = references
    }
}

struct UpdateContactInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let references: [Swift.String:ConnectClientTypes.Reference]?
}

extension UpdateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case references = "References"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let referencesContainer = try containerValues.decodeIfPresent([Swift.String: ConnectClientTypes.Reference?].self, forKey: .references)
        var referencesDecoded0: [Swift.String:ConnectClientTypes.Reference]? = nil
        if let referencesContainer = referencesContainer {
            referencesDecoded0 = [Swift.String:ConnectClientTypes.Reference]()
            for (key0, reference0) in referencesContainer {
                if let reference0 = reference0 {
                    referencesDecoded0?[key0] = reference0
                }
            }
        }
        references = referencesDecoded0
    }
}

extension UpdateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactOutputResponse: Swift.Equatable {

}

extension UpdateContactScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case scheduledTime = "ScheduledTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let scheduledTime = scheduledTime {
            try encodeContainer.encode(scheduledTime.timeIntervalSince1970, forKey: .scheduledTime)
        }
    }
}

extension UpdateContactScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact/schedule"
    }
}

public struct UpdateContactScheduleInput: Swift.Equatable {
    /// The identifier of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The timestamp, in Unix Epoch seconds format, at which to start running the inbound contact flow. The scheduled time cannot be in the past. It must be within up to 6 days in future.
    /// This member is required.
    public var scheduledTime: ClientRuntime.Date?

    public init (
        contactId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        scheduledTime: ClientRuntime.Date? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.scheduledTime = scheduledTime
    }
}

struct UpdateContactScheduleInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let contactId: Swift.String?
    let scheduledTime: ClientRuntime.Date?
}

extension UpdateContactScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case scheduledTime = "ScheduledTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let scheduledTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
    }
}

extension UpdateContactScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactScheduleOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactScheduleOutputResponse: Swift.Equatable {

}

extension UpdateHoursOfOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case description = "Description"
        case name = "Name"
        case timeZone = "TimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            var configContainer = encodeContainer.nestedUnkeyedContainer(forKey: .config)
            for hoursofoperationconfiglist0 in config {
                try configContainer.encode(hoursofoperationconfiglist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let timeZone = timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
    }
}

extension UpdateHoursOfOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let hoursOfOperationId = hoursOfOperationId else {
            return nil
        }
        return "/hours-of-operations/\(instanceId.urlPercentEncoding())/\(hoursOfOperationId.urlPercentEncoding())"
    }
}

public struct UpdateHoursOfOperationInput: Swift.Equatable {
    /// Configuration information of the hours of operation.
    public var config: [ConnectClientTypes.HoursOfOperationConfig]?
    /// The description of the hours of operation.
    public var description: Swift.String?
    /// The identifier of the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the hours of operation.
    public var name: Swift.String?
    /// The time zone of the hours of operation.
    public var timeZone: Swift.String?

    public init (
        config: [ConnectClientTypes.HoursOfOperationConfig]? = nil,
        description: Swift.String? = nil,
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        timeZone: Swift.String? = nil
    )
    {
        self.config = config
        self.description = description
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
        self.name = name
        self.timeZone = timeZone
    }
}

struct UpdateHoursOfOperationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let timeZone: Swift.String?
    let config: [ConnectClientTypes.HoursOfOperationConfig]?
}

extension UpdateHoursOfOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case description = "Description"
        case name = "Name"
        case timeZone = "TimeZone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let configContainer = try containerValues.decodeIfPresent([ConnectClientTypes.HoursOfOperationConfig?].self, forKey: .config)
        var configDecoded0:[ConnectClientTypes.HoursOfOperationConfig]? = nil
        if let configContainer = configContainer {
            configDecoded0 = [ConnectClientTypes.HoursOfOperationConfig]()
            for structure0 in configContainer {
                if let structure0 = structure0 {
                    configDecoded0?.append(structure0)
                }
            }
        }
        config = configDecoded0
    }
}

extension UpdateHoursOfOperationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateHoursOfOperationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateHoursOfOperationOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateHoursOfOperationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateHoursOfOperationOutputResponse: Swift.Equatable {

}

extension UpdateInstanceAttributeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

extension UpdateInstanceAttributeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let attributeType = attributeType else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/attribute/\(attributeType.rawValue.urlPercentEncoding())"
    }
}

public struct UpdateInstanceAttributeInput: Swift.Equatable {
    /// The type of attribute. Only allowlisted customers can consume USE_CUSTOM_TTS_VOICES. To access this feature, contact AWS Support for allowlisting.
    /// This member is required.
    public var attributeType: ConnectClientTypes.InstanceAttributeType?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The value for the attribute. Maximum character limit is 100.
    /// This member is required.
    public var value: Swift.String?

    public init (
        attributeType: ConnectClientTypes.InstanceAttributeType? = nil,
        instanceId: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.attributeType = attributeType
        self.instanceId = instanceId
        self.value = value
    }
}

struct UpdateInstanceAttributeInputBody: Swift.Equatable {
    let value: Swift.String?
}

extension UpdateInstanceAttributeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension UpdateInstanceAttributeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceAttributeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceAttributeOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceAttributeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInstanceAttributeOutputResponse: Swift.Equatable {

}

extension UpdateInstanceStorageConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageConfig = "StorageConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let storageConfig = storageConfig {
            try encodeContainer.encode(storageConfig, forKey: .storageConfig)
        }
    }
}

extension UpdateInstanceStorageConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceType = resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension UpdateInstanceStorageConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let associationId = associationId else {
            return nil
        }
        return "/instance/\(instanceId.urlPercentEncoding())/storage-config/\(associationId.urlPercentEncoding())"
    }
}

public struct UpdateInstanceStorageConfigInput: Swift.Equatable {
    /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// A valid resource type.
    /// This member is required.
    public var resourceType: ConnectClientTypes.InstanceStorageResourceType?
    /// The storage configuration for the instance.
    /// This member is required.
    public var storageConfig: ConnectClientTypes.InstanceStorageConfig?

    public init (
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        resourceType: ConnectClientTypes.InstanceStorageResourceType? = nil,
        storageConfig: ConnectClientTypes.InstanceStorageConfig? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.resourceType = resourceType
        self.storageConfig = storageConfig
    }
}

struct UpdateInstanceStorageConfigInputBody: Swift.Equatable {
    let storageConfig: ConnectClientTypes.InstanceStorageConfig?
}

extension UpdateInstanceStorageConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageConfig = "StorageConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.InstanceStorageConfig.self, forKey: .storageConfig)
        storageConfig = storageConfigDecoded
    }
}

extension UpdateInstanceStorageConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceStorageConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceStorageConfigOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceStorageConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInstanceStorageConfigOutputResponse: Swift.Equatable {

}

extension UpdateQueueHoursOfOperationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hoursOfOperationId = "HoursOfOperationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hoursOfOperationId = hoursOfOperationId {
            try encodeContainer.encode(hoursOfOperationId, forKey: .hoursOfOperationId)
        }
    }
}

extension UpdateQueueHoursOfOperationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/hours-of-operation"
    }
}

public struct UpdateQueueHoursOfOperationInput: Swift.Equatable {
    /// The identifier for the hours of operation.
    /// This member is required.
    public var hoursOfOperationId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init (
        hoursOfOperationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.hoursOfOperationId = hoursOfOperationId
        self.instanceId = instanceId
        self.queueId = queueId
    }
}

struct UpdateQueueHoursOfOperationInputBody: Swift.Equatable {
    let hoursOfOperationId: Swift.String?
}

extension UpdateQueueHoursOfOperationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hoursOfOperationId = "HoursOfOperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hoursOfOperationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hoursOfOperationId)
        hoursOfOperationId = hoursOfOperationIdDecoded
    }
}

extension UpdateQueueHoursOfOperationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQueueHoursOfOperationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQueueHoursOfOperationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQueueHoursOfOperationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQueueHoursOfOperationOutputResponse: Swift.Equatable {

}

extension UpdateQueueMaxContactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxContacts = "MaxContacts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxContacts != 0 {
            try encodeContainer.encode(maxContacts, forKey: .maxContacts)
        }
    }
}

extension UpdateQueueMaxContactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/max-contacts"
    }
}

public struct UpdateQueueMaxContactsInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of contacts that can be in the queue before it is considered full.
    public var maxContacts: Swift.Int
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        maxContacts: Swift.Int = 0,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxContacts = maxContacts
        self.queueId = queueId
    }
}

struct UpdateQueueMaxContactsInputBody: Swift.Equatable {
    let maxContacts: Swift.Int
}

extension UpdateQueueMaxContactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxContacts = "MaxContacts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxContactsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxContacts)
        maxContacts = maxContactsDecoded
    }
}

extension UpdateQueueMaxContactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQueueMaxContactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQueueMaxContactsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQueueMaxContactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQueueMaxContactsOutputResponse: Swift.Equatable {

}

extension UpdateQueueNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateQueueNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/name"
    }
}

public struct UpdateQueueNameInput: Swift.Equatable {
    /// The description of the queue.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the queue.
    public var name: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init (
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.queueId = queueId
    }
}

struct UpdateQueueNameInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateQueueNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateQueueNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQueueNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQueueNameOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQueueNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQueueNameOutputResponse: Swift.Equatable {

}

extension UpdateQueueOutboundCallerConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outboundCallerConfig = "OutboundCallerConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outboundCallerConfig = outboundCallerConfig {
            try encodeContainer.encode(outboundCallerConfig, forKey: .outboundCallerConfig)
        }
    }
}

extension UpdateQueueOutboundCallerConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/outbound-caller-config"
    }
}

public struct UpdateQueueOutboundCallerConfigInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The outbound caller ID name, number, and outbound whisper flow.
    /// This member is required.
    public var outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.outboundCallerConfig = outboundCallerConfig
        self.queueId = queueId
    }
}

struct UpdateQueueOutboundCallerConfigInputBody: Swift.Equatable {
    let outboundCallerConfig: ConnectClientTypes.OutboundCallerConfig?
}

extension UpdateQueueOutboundCallerConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outboundCallerConfig = "OutboundCallerConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outboundCallerConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.OutboundCallerConfig.self, forKey: .outboundCallerConfig)
        outboundCallerConfig = outboundCallerConfigDecoded
    }
}

extension UpdateQueueOutboundCallerConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQueueOutboundCallerConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQueueOutboundCallerConfigOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQueueOutboundCallerConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQueueOutboundCallerConfigOutputResponse: Swift.Equatable {

}

extension UpdateQueueStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateQueueStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let queueId = queueId else {
            return nil
        }
        return "/queues/\(instanceId.urlPercentEncoding())/\(queueId.urlPercentEncoding())/status"
    }
}

public struct UpdateQueueStatusInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier for the queue.
    /// This member is required.
    public var queueId: Swift.String?
    /// The status of the queue.
    /// This member is required.
    public var status: ConnectClientTypes.QueueStatus?

    public init (
        instanceId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        status: ConnectClientTypes.QueueStatus? = nil
    )
    {
        self.instanceId = instanceId
        self.queueId = queueId
        self.status = status
    }
}

struct UpdateQueueStatusInputBody: Swift.Equatable {
    let status: ConnectClientTypes.QueueStatus?
}

extension UpdateQueueStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QueueStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateQueueStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQueueStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQueueStatusOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQueueStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQueueStatusOutputResponse: Swift.Equatable {

}

extension UpdateQuickConnectConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectConfig = "QuickConnectConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quickConnectConfig = quickConnectConfig {
            try encodeContainer.encode(quickConnectConfig, forKey: .quickConnectConfig)
        }
    }
}

extension UpdateQuickConnectConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let quickConnectId = quickConnectId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())/\(quickConnectId.urlPercentEncoding())/config"
    }
}

public struct UpdateQuickConnectConfigInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Information about the configuration settings for the quick connect.
    /// This member is required.
    public var quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
    /// The identifier for the quick connect.
    /// This member is required.
    public var quickConnectId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        quickConnectConfig: ConnectClientTypes.QuickConnectConfig? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.quickConnectConfig = quickConnectConfig
        self.quickConnectId = quickConnectId
    }
}

struct UpdateQuickConnectConfigInputBody: Swift.Equatable {
    let quickConnectConfig: ConnectClientTypes.QuickConnectConfig?
}

extension UpdateQuickConnectConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickConnectConfig = "QuickConnectConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickConnectConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.QuickConnectConfig.self, forKey: .quickConnectConfig)
        quickConnectConfig = quickConnectConfigDecoded
    }
}

extension UpdateQuickConnectConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQuickConnectConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQuickConnectConfigOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQuickConnectConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQuickConnectConfigOutputResponse: Swift.Equatable {

}

extension UpdateQuickConnectNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateQuickConnectNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let quickConnectId = quickConnectId else {
            return nil
        }
        return "/quick-connects/\(instanceId.urlPercentEncoding())/\(quickConnectId.urlPercentEncoding())/name"
    }
}

public struct UpdateQuickConnectNameInput: Swift.Equatable {
    /// The description of the quick connect.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the quick connect.
    public var name: Swift.String?
    /// The identifier for the quick connect.
    /// This member is required.
    public var quickConnectId: Swift.String?

    public init (
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        quickConnectId: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.quickConnectId = quickConnectId
    }
}

struct UpdateQuickConnectNameInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateQuickConnectNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateQuickConnectNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateQuickConnectNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateQuickConnectNameOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateQuickConnectNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateQuickConnectNameOutputResponse: Swift.Equatable {

}

extension UpdateRoutingProfileConcurrencyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaConcurrencies = "MediaConcurrencies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaConcurrencies = mediaConcurrencies {
            var mediaConcurrenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaConcurrencies)
            for mediaconcurrencies0 in mediaConcurrencies {
                try mediaConcurrenciesContainer.encode(mediaconcurrencies0)
            }
        }
    }
}

extension UpdateRoutingProfileConcurrencyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/concurrency"
    }
}

public struct UpdateRoutingProfileConcurrencyInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The channels that agents can handle in the Contact Control Panel (CCP).
    /// This member is required.
    public var mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.mediaConcurrencies = mediaConcurrencies
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileConcurrencyInputBody: Swift.Equatable {
    let mediaConcurrencies: [ConnectClientTypes.MediaConcurrency]?
}

extension UpdateRoutingProfileConcurrencyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaConcurrencies = "MediaConcurrencies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaConcurrenciesContainer = try containerValues.decodeIfPresent([ConnectClientTypes.MediaConcurrency?].self, forKey: .mediaConcurrencies)
        var mediaConcurrenciesDecoded0:[ConnectClientTypes.MediaConcurrency]? = nil
        if let mediaConcurrenciesContainer = mediaConcurrenciesContainer {
            mediaConcurrenciesDecoded0 = [ConnectClientTypes.MediaConcurrency]()
            for structure0 in mediaConcurrenciesContainer {
                if let structure0 = structure0 {
                    mediaConcurrenciesDecoded0?.append(structure0)
                }
            }
        }
        mediaConcurrencies = mediaConcurrenciesDecoded0
    }
}

extension UpdateRoutingProfileConcurrencyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoutingProfileConcurrencyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoutingProfileConcurrencyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoutingProfileConcurrencyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoutingProfileConcurrencyOutputResponse: Swift.Equatable {

}

extension UpdateRoutingProfileDefaultOutboundQueueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultOutboundQueueId = defaultOutboundQueueId {
            try encodeContainer.encode(defaultOutboundQueueId, forKey: .defaultOutboundQueueId)
        }
    }
}

extension UpdateRoutingProfileDefaultOutboundQueueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/default-outbound-queue"
    }
}

public struct UpdateRoutingProfileDefaultOutboundQueueInput: Swift.Equatable {
    /// The identifier for the default outbound queue.
    /// This member is required.
    public var defaultOutboundQueueId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init (
        defaultOutboundQueueId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.defaultOutboundQueueId = defaultOutboundQueueId
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileDefaultOutboundQueueInputBody: Swift.Equatable {
    let defaultOutboundQueueId: Swift.String?
}

extension UpdateRoutingProfileDefaultOutboundQueueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultOutboundQueueId = "DefaultOutboundQueueId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultOutboundQueueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOutboundQueueId)
        defaultOutboundQueueId = defaultOutboundQueueIdDecoded
    }
}

extension UpdateRoutingProfileDefaultOutboundQueueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoutingProfileDefaultOutboundQueueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoutingProfileDefaultOutboundQueueOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoutingProfileDefaultOutboundQueueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoutingProfileDefaultOutboundQueueOutputResponse: Swift.Equatable {

}

extension UpdateRoutingProfileNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateRoutingProfileNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/name"
    }
}

public struct UpdateRoutingProfileNameInput: Swift.Equatable {
    /// The description of the routing profile. Must not be more than 250 characters.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the routing profile. Must not be more than 127 characters.
    public var name: Swift.String?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init (
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileNameInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateRoutingProfileNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRoutingProfileNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoutingProfileNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoutingProfileNameOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoutingProfileNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoutingProfileNameOutputResponse: Swift.Equatable {

}

extension UpdateRoutingProfileQueuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueConfigs = "QueueConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queueConfigs = queueConfigs {
            var queueConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queueConfigs)
            for routingprofilequeueconfiglist0 in queueConfigs {
                try queueConfigsContainer.encode(routingprofilequeueconfiglist0)
            }
        }
    }
}

extension UpdateRoutingProfileQueuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let routingProfileId = routingProfileId else {
            return nil
        }
        return "/routing-profiles/\(instanceId.urlPercentEncoding())/\(routingProfileId.urlPercentEncoding())/queues"
    }
}

public struct UpdateRoutingProfileQueuesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The queues to be updated for this routing profile. Queues must first be associated to the routing profile. You can do this using AssociateRoutingProfileQueues.
    /// This member is required.
    public var queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
    /// The identifier of the routing profile.
    /// This member is required.
    public var routingProfileId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]? = nil,
        routingProfileId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.queueConfigs = queueConfigs
        self.routingProfileId = routingProfileId
    }
}

struct UpdateRoutingProfileQueuesInputBody: Swift.Equatable {
    let queueConfigs: [ConnectClientTypes.RoutingProfileQueueConfig]?
}

extension UpdateRoutingProfileQueuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueConfigs = "QueueConfigs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueConfigsContainer = try containerValues.decodeIfPresent([ConnectClientTypes.RoutingProfileQueueConfig?].self, forKey: .queueConfigs)
        var queueConfigsDecoded0:[ConnectClientTypes.RoutingProfileQueueConfig]? = nil
        if let queueConfigsContainer = queueConfigsContainer {
            queueConfigsDecoded0 = [ConnectClientTypes.RoutingProfileQueueConfig]()
            for structure0 in queueConfigsContainer {
                if let structure0 = structure0 {
                    queueConfigsDecoded0?.append(structure0)
                }
            }
        }
        queueConfigs = queueConfigsDecoded0
    }
}

extension UpdateRoutingProfileQueuesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoutingProfileQueuesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoutingProfileQueuesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoutingProfileQueuesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoutingProfileQueuesOutputResponse: Swift.Equatable {

}

extension UpdateSecurityProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case permissions = "Permissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permissionslist0 in permissions {
                try permissionsContainer.encode(permissionslist0)
            }
        }
    }
}

extension UpdateSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let securityProfileId = securityProfileId else {
            return nil
        }
        return "/security-profiles/\(instanceId.urlPercentEncoding())/\(securityProfileId.urlPercentEncoding())"
    }
}

public struct UpdateSecurityProfileInput: Swift.Equatable {
    /// The description of the security profile.
    public var description: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The permissions granted to a security profile.
    public var permissions: [Swift.String]?
    /// The identifier for the security profle.
    /// This member is required.
    public var securityProfileId: Swift.String?

    public init (
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        permissions: [Swift.String]? = nil,
        securityProfileId: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceId = instanceId
        self.permissions = permissions
        self.securityProfileId = securityProfileId
    }
}

struct UpdateSecurityProfileInputBody: Swift.Equatable {
    let description: Swift.String?
    let permissions: [Swift.String]?
}

extension UpdateSecurityProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case permissions = "Permissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissions)
        var permissionsDecoded0:[Swift.String]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Swift.String]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

extension UpdateSecurityProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecurityProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSecurityProfileOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecurityProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSecurityProfileOutputResponse: Swift.Equatable {

}

extension UpdateUserHierarchyGroupNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateUserHierarchyGroupNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let hierarchyGroupId = hierarchyGroupId else {
            return nil
        }
        return "/user-hierarchy-groups/\(instanceId.urlPercentEncoding())/\(hierarchyGroupId.urlPercentEncoding())/name"
    }
}

public struct UpdateUserHierarchyGroupNameInput: Swift.Equatable {
    /// The identifier of the hierarchy group.
    /// This member is required.
    public var hierarchyGroupId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the hierarchy group. Must not be more than 100 characters.
    /// This member is required.
    public var name: Swift.String?

    public init (
        hierarchyGroupId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
        self.name = name
    }
}

struct UpdateUserHierarchyGroupNameInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateUserHierarchyGroupNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateUserHierarchyGroupNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserHierarchyGroupNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserHierarchyGroupNameOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserHierarchyGroupNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserHierarchyGroupNameOutputResponse: Swift.Equatable {

}

extension UpdateUserHierarchyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyGroupId = "HierarchyGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyGroupId = hierarchyGroupId {
            try encodeContainer.encode(hierarchyGroupId, forKey: .hierarchyGroupId)
        }
    }
}

extension UpdateUserHierarchyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/hierarchy"
    }
}

public struct UpdateUserHierarchyInput: Swift.Equatable {
    /// The identifier of the hierarchy group.
    public var hierarchyGroupId: Swift.String?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        hierarchyGroupId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.hierarchyGroupId = hierarchyGroupId
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct UpdateUserHierarchyInputBody: Swift.Equatable {
    let hierarchyGroupId: Swift.String?
}

extension UpdateUserHierarchyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyGroupId = "HierarchyGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
    }
}

extension UpdateUserHierarchyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserHierarchyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserHierarchyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserHierarchyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserHierarchyOutputResponse: Swift.Equatable {

}

extension UpdateUserHierarchyStructureInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyStructure = "HierarchyStructure"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyStructure = hierarchyStructure {
            try encodeContainer.encode(hierarchyStructure, forKey: .hierarchyStructure)
        }
    }
}

extension UpdateUserHierarchyStructureInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        return "/user-hierarchy-structure/\(instanceId.urlPercentEncoding())"
    }
}

public struct UpdateUserHierarchyStructureInput: Swift.Equatable {
    /// The hierarchy levels to update.
    /// This member is required.
    public var hierarchyStructure: ConnectClientTypes.HierarchyStructureUpdate?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        hierarchyStructure: ConnectClientTypes.HierarchyStructureUpdate? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.hierarchyStructure = hierarchyStructure
        self.instanceId = instanceId
    }
}

struct UpdateUserHierarchyStructureInputBody: Swift.Equatable {
    let hierarchyStructure: ConnectClientTypes.HierarchyStructureUpdate?
}

extension UpdateUserHierarchyStructureInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyStructure = "HierarchyStructure"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyStructureDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.HierarchyStructureUpdate.self, forKey: .hierarchyStructure)
        hierarchyStructure = hierarchyStructureDecoded
    }
}

extension UpdateUserHierarchyStructureOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserHierarchyStructureOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserHierarchyStructureOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserHierarchyStructureOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserHierarchyStructureOutputResponse: Swift.Equatable {

}

extension UpdateUserIdentityInfoInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityInfo = "IdentityInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityInfo = identityInfo {
            try encodeContainer.encode(identityInfo, forKey: .identityInfo)
        }
    }
}

extension UpdateUserIdentityInfoInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/identity-info"
    }
}

public struct UpdateUserIdentityInfoInput: Swift.Equatable {
    /// The identity information for the user.
    /// This member is required.
    public var identityInfo: ConnectClientTypes.UserIdentityInfo?
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        identityInfo: ConnectClientTypes.UserIdentityInfo? = nil,
        instanceId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityInfo = identityInfo
        self.instanceId = instanceId
        self.userId = userId
    }
}

struct UpdateUserIdentityInfoInputBody: Swift.Equatable {
    let identityInfo: ConnectClientTypes.UserIdentityInfo?
}

extension UpdateUserIdentityInfoInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityInfo = "IdentityInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityInfoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserIdentityInfo.self, forKey: .identityInfo)
        identityInfo = identityInfoDecoded
    }
}

extension UpdateUserIdentityInfoOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserIdentityInfoOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserIdentityInfoOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserIdentityInfoOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserIdentityInfoOutputResponse: Swift.Equatable {

}

extension UpdateUserPhoneConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneConfig = "PhoneConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneConfig = phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
    }
}

extension UpdateUserPhoneConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/phone-config"
    }
}

public struct UpdateUserPhoneConfigInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Information about phone configuration settings for the user.
    /// This member is required.
    public var phoneConfig: ConnectClientTypes.UserPhoneConfig?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        phoneConfig: ConnectClientTypes.UserPhoneConfig? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.phoneConfig = phoneConfig
        self.userId = userId
    }
}

struct UpdateUserPhoneConfigInputBody: Swift.Equatable {
    let phoneConfig: ConnectClientTypes.UserPhoneConfig?
}

extension UpdateUserPhoneConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneConfig = "PhoneConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserPhoneConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
    }
}

extension UpdateUserPhoneConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserPhoneConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserPhoneConfigOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserPhoneConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserPhoneConfigOutputResponse: Swift.Equatable {

}

extension UpdateUserRoutingProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingProfileId = "RoutingProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routingProfileId = routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
    }
}

extension UpdateUserRoutingProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/routing-profile"
    }
}

public struct UpdateUserRoutingProfileInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifier of the routing profile for the user.
    /// This member is required.
    public var routingProfileId: Swift.String?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        routingProfileId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.routingProfileId = routingProfileId
        self.userId = userId
    }
}

struct UpdateUserRoutingProfileInputBody: Swift.Equatable {
    let routingProfileId: Swift.String?
}

extension UpdateUserRoutingProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingProfileId = "RoutingProfileId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
    }
}

extension UpdateUserRoutingProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserRoutingProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserRoutingProfileOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserRoutingProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserRoutingProfileOutputResponse: Swift.Equatable {

}

extension UpdateUserSecurityProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityProfileIds = "SecurityProfileIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityProfileIds = securityProfileIds {
            var securityProfileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityProfileIds)
            for securityprofileids0 in securityProfileIds {
                try securityProfileIdsContainer.encode(securityprofileids0)
            }
        }
    }
}

extension UpdateUserSecurityProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let instanceId = instanceId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/users/\(instanceId.urlPercentEncoding())/\(userId.urlPercentEncoding())/security-profiles"
    }
}

public struct UpdateUserSecurityProfilesInput: Swift.Equatable {
    /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The identifiers of the security profiles for the user.
    /// This member is required.
    public var securityProfileIds: [Swift.String]?
    /// The identifier of the user account.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        securityProfileIds: [Swift.String]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.securityProfileIds = securityProfileIds
        self.userId = userId
    }
}

struct UpdateUserSecurityProfilesInputBody: Swift.Equatable {
    let securityProfileIds: [Swift.String]?
}

extension UpdateUserSecurityProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityProfileIds = "SecurityProfileIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityProfileIds)
        var securityProfileIdsDecoded0:[Swift.String]? = nil
        if let securityProfileIdsContainer = securityProfileIdsContainer {
            securityProfileIdsDecoded0 = [Swift.String]()
            for string0 in securityProfileIdsContainer {
                if let string0 = string0 {
                    securityProfileIdsDecoded0?.append(string0)
                }
            }
        }
        securityProfileIds = securityProfileIdsDecoded0
    }
}

extension UpdateUserSecurityProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserSecurityProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserSecurityProfilesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceException(InternalServiceException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserSecurityProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserSecurityProfilesOutputResponse: Swift.Equatable {

}

extension ConnectClientTypes.UrlReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectClientTypes {
    /// The URL reference.
    public struct UrlReference: Swift.Equatable {
        /// Identifier of the URL reference.
        public var name: Swift.String?
        /// A valid URL.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ConnectClientTypes.UseCase: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case useCaseArn = "UseCaseArn"
        case useCaseId = "UseCaseId"
        case useCaseType = "UseCaseType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let useCaseArn = useCaseArn {
            try encodeContainer.encode(useCaseArn, forKey: .useCaseArn)
        }
        if let useCaseId = useCaseId {
            try encodeContainer.encode(useCaseId, forKey: .useCaseId)
        }
        if let useCaseType = useCaseType {
            try encodeContainer.encode(useCaseType.rawValue, forKey: .useCaseType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let useCaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .useCaseId)
        useCaseId = useCaseIdDecoded
        let useCaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .useCaseArn)
        useCaseArn = useCaseArnDecoded
        let useCaseTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UseCaseType.self, forKey: .useCaseType)
        useCaseType = useCaseTypeDecoded
    }
}

extension ConnectClientTypes {
    /// Contains the use case.
    public struct UseCase: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the use case.
        public var useCaseArn: Swift.String?
        /// The identifier for the use case.
        public var useCaseId: Swift.String?
        /// The type of use case to associate to the integration association. Each integration association can have only one of each use case type.
        public var useCaseType: ConnectClientTypes.UseCaseType?

        public init (
            useCaseArn: Swift.String? = nil,
            useCaseId: Swift.String? = nil,
            useCaseType: ConnectClientTypes.UseCaseType? = nil
        )
        {
            self.useCaseArn = useCaseArn
            self.useCaseId = useCaseId
            self.useCaseType = useCaseType
        }
    }

}

extension ConnectClientTypes {
    public enum UseCaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectCampaigns
        case rulesEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [UseCaseType] {
            return [
                .connectCampaigns,
                .rulesEvaluation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectCampaigns: return "CONNECT_CAMPAIGNS"
            case .rulesEvaluation: return "RULES_EVALUATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UseCaseType(rawValue: rawValue) ?? UseCaseType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case directoryUserId = "DirectoryUserId"
        case hierarchyGroupId = "HierarchyGroupId"
        case id = "Id"
        case identityInfo = "IdentityInfo"
        case phoneConfig = "PhoneConfig"
        case routingProfileId = "RoutingProfileId"
        case securityProfileIds = "SecurityProfileIds"
        case tags = "Tags"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let directoryUserId = directoryUserId {
            try encodeContainer.encode(directoryUserId, forKey: .directoryUserId)
        }
        if let hierarchyGroupId = hierarchyGroupId {
            try encodeContainer.encode(hierarchyGroupId, forKey: .hierarchyGroupId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identityInfo = identityInfo {
            try encodeContainer.encode(identityInfo, forKey: .identityInfo)
        }
        if let phoneConfig = phoneConfig {
            try encodeContainer.encode(phoneConfig, forKey: .phoneConfig)
        }
        if let routingProfileId = routingProfileId {
            try encodeContainer.encode(routingProfileId, forKey: .routingProfileId)
        }
        if let securityProfileIds = securityProfileIds {
            var securityProfileIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityProfileIds)
            for securityprofileids0 in securityProfileIds {
                try securityProfileIdsContainer.encode(securityprofileids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let identityInfoDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserIdentityInfo.self, forKey: .identityInfo)
        identityInfo = identityInfoDecoded
        let phoneConfigDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.UserPhoneConfig.self, forKey: .phoneConfig)
        phoneConfig = phoneConfigDecoded
        let directoryUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryUserId)
        directoryUserId = directoryUserIdDecoded
        let securityProfileIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityProfileIds)
        var securityProfileIdsDecoded0:[Swift.String]? = nil
        if let securityProfileIdsContainer = securityProfileIdsContainer {
            securityProfileIdsDecoded0 = [Swift.String]()
            for string0 in securityProfileIdsContainer {
                if let string0 = string0 {
                    securityProfileIdsDecoded0?.append(string0)
                }
            }
        }
        securityProfileIds = securityProfileIdsDecoded0
        let routingProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingProfileId)
        routingProfileId = routingProfileIdDecoded
        let hierarchyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyGroupId)
        hierarchyGroupId = hierarchyGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectClientTypes {
    /// Contains information about a user account for a Amazon Connect instance.
    public struct User: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the user account.
        public var arn: Swift.String?
        /// The identifier of the user account in the directory used for identity management.
        public var directoryUserId: Swift.String?
        /// The identifier of the hierarchy group for the user.
        public var hierarchyGroupId: Swift.String?
        /// The identifier of the user account.
        public var id: Swift.String?
        /// Information about the user identity.
        public var identityInfo: ConnectClientTypes.UserIdentityInfo?
        /// Information about the phone configuration for the user.
        public var phoneConfig: ConnectClientTypes.UserPhoneConfig?
        /// The identifier of the routing profile for the user.
        public var routingProfileId: Swift.String?
        /// The identifiers of the security profiles for the user.
        public var securityProfileIds: [Swift.String]?
        /// The tags.
        public var tags: [Swift.String:Swift.String]?
        /// The user name assigned to the user account.
        public var username: Swift.String?

        public init (
            arn: Swift.String? = nil,
            directoryUserId: Swift.String? = nil,
            hierarchyGroupId: Swift.String? = nil,
            id: Swift.String? = nil,
            identityInfo: ConnectClientTypes.UserIdentityInfo? = nil,
            phoneConfig: ConnectClientTypes.UserPhoneConfig? = nil,
            routingProfileId: Swift.String? = nil,
            securityProfileIds: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            username: Swift.String? = nil
        )
        {
            self.arn = arn
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.id = id
            self.identityInfo = identityInfo
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.tags = tags
            self.username = username
        }
    }

}

extension ConnectClientTypes.UserIdentityInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case firstName = "FirstName"
        case lastName = "LastName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the identity of a user.
    public struct UserIdentityInfo: Swift.Equatable {
        /// The email address. If you are using SAML for identity management and include this parameter, an error is returned.
        public var email: Swift.String?
        /// The first name. This is required if you are using Amazon Connect or SAML for identity management.
        public var firstName: Swift.String?
        /// The last name. This is required if you are using Amazon Connect or SAML for identity management.
        public var lastName: Swift.String?

        public init (
            email: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil
        )
        {
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
        }
    }

}

extension UserNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UserNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No user with the specified credentials was found in the Amazon Connect instance.
public struct UserNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UserNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UserNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectClientTypes.UserPhoneConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterContactWorkTimeLimit = "AfterContactWorkTimeLimit"
        case autoAccept = "AutoAccept"
        case deskPhoneNumber = "DeskPhoneNumber"
        case phoneType = "PhoneType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if afterContactWorkTimeLimit != 0 {
            try encodeContainer.encode(afterContactWorkTimeLimit, forKey: .afterContactWorkTimeLimit)
        }
        if autoAccept != false {
            try encodeContainer.encode(autoAccept, forKey: .autoAccept)
        }
        if let deskPhoneNumber = deskPhoneNumber {
            try encodeContainer.encode(deskPhoneNumber, forKey: .deskPhoneNumber)
        }
        if let phoneType = phoneType {
            try encodeContainer.encode(phoneType.rawValue, forKey: .phoneType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneTypeDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.PhoneType.self, forKey: .phoneType)
        phoneType = phoneTypeDecoded
        let autoAcceptDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoAccept)
        autoAccept = autoAcceptDecoded
        let afterContactWorkTimeLimitDecoded = try containerValues.decode(Swift.Int.self, forKey: .afterContactWorkTimeLimit)
        afterContactWorkTimeLimit = afterContactWorkTimeLimitDecoded
        let deskPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deskPhoneNumber)
        deskPhoneNumber = deskPhoneNumberDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the phone configuration settings for a user.
    public struct UserPhoneConfig: Swift.Equatable {
        /// The After Call Work (ACW) timeout setting, in seconds.
        public var afterContactWorkTimeLimit: Swift.Int
        /// The Auto accept setting.
        public var autoAccept: Swift.Bool
        /// The phone number for the user's desk phone.
        public var deskPhoneNumber: Swift.String?
        /// The phone type.
        /// This member is required.
        public var phoneType: ConnectClientTypes.PhoneType?

        public init (
            afterContactWorkTimeLimit: Swift.Int = 0,
            autoAccept: Swift.Bool = false,
            deskPhoneNumber: Swift.String? = nil,
            phoneType: ConnectClientTypes.PhoneType? = nil
        )
        {
            self.afterContactWorkTimeLimit = afterContactWorkTimeLimit
            self.autoAccept = autoAccept
            self.deskPhoneNumber = deskPhoneNumber
            self.phoneType = phoneType
        }
    }

}

extension ConnectClientTypes.UserQuickConnectConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactFlowId = "ContactFlowId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactFlowId = contactFlowId {
            try encodeContainer.encode(contactFlowId, forKey: .contactFlowId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let contactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactFlowId)
        contactFlowId = contactFlowIdDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the quick connect configuration settings for a user. The contact flow must be of type Transfer to Agent.
    public struct UserQuickConnectConfig: Swift.Equatable {
        /// The identifier of the contact flow.
        /// This member is required.
        public var contactFlowId: Swift.String?
        /// The identifier of the user.
        /// This member is required.
        public var userId: Swift.String?

        public init (
            contactFlowId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.contactFlowId = contactFlowId
            self.userId = userId
        }
    }

}

extension ConnectClientTypes.UserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension ConnectClientTypes {
    /// Contains summary information about a user.
    public struct UserSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the user account.
        public var arn: Swift.String?
        /// The identifier of the user account.
        public var id: Swift.String?
        /// The Amazon Connect user name of the user account.
        public var username: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.username = username
        }
    }

}

extension ConnectClientTypes.VoiceRecordingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceRecordingTrack = "VoiceRecordingTrack"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let voiceRecordingTrack = voiceRecordingTrack {
            try encodeContainer.encode(voiceRecordingTrack.rawValue, forKey: .voiceRecordingTrack)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceRecordingTrackDecoded = try containerValues.decodeIfPresent(ConnectClientTypes.VoiceRecordingTrack.self, forKey: .voiceRecordingTrack)
        voiceRecordingTrack = voiceRecordingTrackDecoded
    }
}

extension ConnectClientTypes {
    /// Contains information about the recording configuration settings.
    public struct VoiceRecordingConfiguration: Swift.Equatable {
        /// Identifies which track is being recorded.
        public var voiceRecordingTrack: ConnectClientTypes.VoiceRecordingTrack?

        public init (
            voiceRecordingTrack: ConnectClientTypes.VoiceRecordingTrack? = nil
        )
        {
            self.voiceRecordingTrack = voiceRecordingTrack
        }
    }

}

extension ConnectClientTypes {
    public enum VoiceRecordingTrack: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case fromAgent
        case toAgent
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceRecordingTrack] {
            return [
                .all,
                .fromAgent,
                .toAgent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .fromAgent: return "FROM_AGENT"
            case .toAgent: return "TO_AGENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceRecordingTrack(rawValue: rawValue) ?? VoiceRecordingTrack.sdkUnknown(rawValue)
        }
    }
}
