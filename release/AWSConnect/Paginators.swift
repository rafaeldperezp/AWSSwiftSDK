// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[GetCurrentMetricDataOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetCurrentMetricDataInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetCurrentMetricDataOutputResponse`
extension ConnectClient {
    public func getCurrentMetricDataPaginated(input: GetCurrentMetricDataInput) -> ClientRuntime.PaginatorSequence<GetCurrentMetricDataInput, GetCurrentMetricDataOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetCurrentMetricDataInput, GetCurrentMetricDataOutputResponse>(input: input, inputKey: \GetCurrentMetricDataInput.nextToken, outputKey: \GetCurrentMetricDataOutputResponse.nextToken, paginationFunction: self.getCurrentMetricData(input:))
    }
}

extension GetCurrentMetricDataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCurrentMetricDataInput {
        return GetCurrentMetricDataInput(
            currentMetrics: self.currentMetrics,
            filters: self.filters,
            groupings: self.groupings,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetMetricDataOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetMetricDataInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetMetricDataOutputResponse`
extension ConnectClient {
    public func getMetricDataPaginated(input: GetMetricDataInput) -> ClientRuntime.PaginatorSequence<GetMetricDataInput, GetMetricDataOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetMetricDataInput, GetMetricDataOutputResponse>(input: input, inputKey: \GetMetricDataInput.nextToken, outputKey: \GetMetricDataOutputResponse.nextToken, paginationFunction: self.getMetricData(input:))
    }
}

extension GetMetricDataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetMetricDataInput {
        return GetMetricDataInput(
            endTime: self.endTime,
            filters: self.filters,
            groupings: self.groupings,
            historicalMetrics: self.historicalMetrics,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )}
}

/// Paginate over `[ListAgentStatusesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAgentStatusesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAgentStatusesOutputResponse`
extension ConnectClient {
    public func listAgentStatusesPaginated(input: ListAgentStatusesInput) -> ClientRuntime.PaginatorSequence<ListAgentStatusesInput, ListAgentStatusesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAgentStatusesInput, ListAgentStatusesOutputResponse>(input: input, inputKey: \ListAgentStatusesInput.nextToken, outputKey: \ListAgentStatusesOutputResponse.nextToken, paginationFunction: self.listAgentStatuses(input:))
    }
}

extension ListAgentStatusesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAgentStatusesInput {
        return ListAgentStatusesInput(
            agentStatusTypes: self.agentStatusTypes,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAgentStatusesPaginated`
/// to access the nested member `[ConnectClientTypes.AgentStatusSummary]`
/// - Returns: `[ConnectClientTypes.AgentStatusSummary]`
extension PaginatorSequence where Input == ListAgentStatusesInput, Output == ListAgentStatusesOutputResponse {
    func agentStatusSummaryList() async throws -> [ConnectClientTypes.AgentStatusSummary] {
        return try await self.asyncCompactMap { item in item.agentStatusSummaryList }
    }
}

/// Paginate over `[ListApprovedOriginsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListApprovedOriginsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListApprovedOriginsOutputResponse`
extension ConnectClient {
    public func listApprovedOriginsPaginated(input: ListApprovedOriginsInput) -> ClientRuntime.PaginatorSequence<ListApprovedOriginsInput, ListApprovedOriginsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListApprovedOriginsInput, ListApprovedOriginsOutputResponse>(input: input, inputKey: \ListApprovedOriginsInput.nextToken, outputKey: \ListApprovedOriginsOutputResponse.nextToken, paginationFunction: self.listApprovedOrigins(input:))
    }
}

extension ListApprovedOriginsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApprovedOriginsInput {
        return ListApprovedOriginsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listApprovedOriginsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListApprovedOriginsInput, Output == ListApprovedOriginsOutputResponse {
    func origins() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.origins }
    }
}

/// Paginate over `[ListBotsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBotsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBotsOutputResponse`
extension ConnectClient {
    public func listBotsPaginated(input: ListBotsInput) -> ClientRuntime.PaginatorSequence<ListBotsInput, ListBotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBotsInput, ListBotsOutputResponse>(input: input, inputKey: \ListBotsInput.nextToken, outputKey: \ListBotsOutputResponse.nextToken, paginationFunction: self.listBots(input:))
    }
}

extension ListBotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotsInput {
        return ListBotsInput(
            instanceId: self.instanceId,
            lexVersion: self.lexVersion,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listBotsPaginated`
/// to access the nested member `[ConnectClientTypes.LexBotConfig]`
/// - Returns: `[ConnectClientTypes.LexBotConfig]`
extension PaginatorSequence where Input == ListBotsInput, Output == ListBotsOutputResponse {
    func lexBots() async throws -> [ConnectClientTypes.LexBotConfig] {
        return try await self.asyncCompactMap { item in item.lexBots }
    }
}

/// Paginate over `[ListContactFlowModulesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListContactFlowModulesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListContactFlowModulesOutputResponse`
extension ConnectClient {
    public func listContactFlowModulesPaginated(input: ListContactFlowModulesInput) -> ClientRuntime.PaginatorSequence<ListContactFlowModulesInput, ListContactFlowModulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListContactFlowModulesInput, ListContactFlowModulesOutputResponse>(input: input, inputKey: \ListContactFlowModulesInput.nextToken, outputKey: \ListContactFlowModulesOutputResponse.nextToken, paginationFunction: self.listContactFlowModules(input:))
    }
}

extension ListContactFlowModulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListContactFlowModulesInput {
        return ListContactFlowModulesInput(
            contactFlowModuleState: self.contactFlowModuleState,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listContactFlowModulesPaginated`
/// to access the nested member `[ConnectClientTypes.ContactFlowModuleSummary]`
/// - Returns: `[ConnectClientTypes.ContactFlowModuleSummary]`
extension PaginatorSequence where Input == ListContactFlowModulesInput, Output == ListContactFlowModulesOutputResponse {
    func contactFlowModulesSummaryList() async throws -> [ConnectClientTypes.ContactFlowModuleSummary] {
        return try await self.asyncCompactMap { item in item.contactFlowModulesSummaryList }
    }
}

/// Paginate over `[ListContactFlowsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListContactFlowsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListContactFlowsOutputResponse`
extension ConnectClient {
    public func listContactFlowsPaginated(input: ListContactFlowsInput) -> ClientRuntime.PaginatorSequence<ListContactFlowsInput, ListContactFlowsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListContactFlowsInput, ListContactFlowsOutputResponse>(input: input, inputKey: \ListContactFlowsInput.nextToken, outputKey: \ListContactFlowsOutputResponse.nextToken, paginationFunction: self.listContactFlows(input:))
    }
}

extension ListContactFlowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListContactFlowsInput {
        return ListContactFlowsInput(
            contactFlowTypes: self.contactFlowTypes,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listContactFlowsPaginated`
/// to access the nested member `[ConnectClientTypes.ContactFlowSummary]`
/// - Returns: `[ConnectClientTypes.ContactFlowSummary]`
extension PaginatorSequence where Input == ListContactFlowsInput, Output == ListContactFlowsOutputResponse {
    func contactFlowSummaryList() async throws -> [ConnectClientTypes.ContactFlowSummary] {
        return try await self.asyncCompactMap { item in item.contactFlowSummaryList }
    }
}

/// Paginate over `[ListContactReferencesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListContactReferencesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListContactReferencesOutputResponse`
extension ConnectClient {
    public func listContactReferencesPaginated(input: ListContactReferencesInput) -> ClientRuntime.PaginatorSequence<ListContactReferencesInput, ListContactReferencesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListContactReferencesInput, ListContactReferencesOutputResponse>(input: input, inputKey: \ListContactReferencesInput.nextToken, outputKey: \ListContactReferencesOutputResponse.nextToken, paginationFunction: self.listContactReferences(input:))
    }
}

extension ListContactReferencesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListContactReferencesInput {
        return ListContactReferencesInput(
            contactId: self.contactId,
            instanceId: self.instanceId,
            nextToken: token,
            referenceTypes: self.referenceTypes
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listContactReferencesPaginated`
/// to access the nested member `[ConnectClientTypes.ReferenceSummary]`
/// - Returns: `[ConnectClientTypes.ReferenceSummary]`
extension PaginatorSequence where Input == ListContactReferencesInput, Output == ListContactReferencesOutputResponse {
    func referenceSummaryList() async throws -> [ConnectClientTypes.ReferenceSummary] {
        return try await self.asyncCompactMap { item in item.referenceSummaryList }
    }
}

/// Paginate over `[ListHoursOfOperationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListHoursOfOperationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListHoursOfOperationsOutputResponse`
extension ConnectClient {
    public func listHoursOfOperationsPaginated(input: ListHoursOfOperationsInput) -> ClientRuntime.PaginatorSequence<ListHoursOfOperationsInput, ListHoursOfOperationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListHoursOfOperationsInput, ListHoursOfOperationsOutputResponse>(input: input, inputKey: \ListHoursOfOperationsInput.nextToken, outputKey: \ListHoursOfOperationsOutputResponse.nextToken, paginationFunction: self.listHoursOfOperations(input:))
    }
}

extension ListHoursOfOperationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHoursOfOperationsInput {
        return ListHoursOfOperationsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listHoursOfOperationsPaginated`
/// to access the nested member `[ConnectClientTypes.HoursOfOperationSummary]`
/// - Returns: `[ConnectClientTypes.HoursOfOperationSummary]`
extension PaginatorSequence where Input == ListHoursOfOperationsInput, Output == ListHoursOfOperationsOutputResponse {
    func hoursOfOperationSummaryList() async throws -> [ConnectClientTypes.HoursOfOperationSummary] {
        return try await self.asyncCompactMap { item in item.hoursOfOperationSummaryList }
    }
}

/// Paginate over `[ListInstanceAttributesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListInstanceAttributesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListInstanceAttributesOutputResponse`
extension ConnectClient {
    public func listInstanceAttributesPaginated(input: ListInstanceAttributesInput) -> ClientRuntime.PaginatorSequence<ListInstanceAttributesInput, ListInstanceAttributesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInstanceAttributesInput, ListInstanceAttributesOutputResponse>(input: input, inputKey: \ListInstanceAttributesInput.nextToken, outputKey: \ListInstanceAttributesOutputResponse.nextToken, paginationFunction: self.listInstanceAttributes(input:))
    }
}

extension ListInstanceAttributesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstanceAttributesInput {
        return ListInstanceAttributesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listInstanceAttributesPaginated`
/// to access the nested member `[ConnectClientTypes.Attribute]`
/// - Returns: `[ConnectClientTypes.Attribute]`
extension PaginatorSequence where Input == ListInstanceAttributesInput, Output == ListInstanceAttributesOutputResponse {
    func attributes() async throws -> [ConnectClientTypes.Attribute] {
        return try await self.asyncCompactMap { item in item.attributes }
    }
}

/// Paginate over `[ListInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListInstancesOutputResponse`
extension ConnectClient {
    public func listInstancesPaginated(input: ListInstancesInput) -> ClientRuntime.PaginatorSequence<ListInstancesInput, ListInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInstancesInput, ListInstancesOutputResponse>(input: input, inputKey: \ListInstancesInput.nextToken, outputKey: \ListInstancesOutputResponse.nextToken, paginationFunction: self.listInstances(input:))
    }
}

extension ListInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstancesInput {
        return ListInstancesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listInstancesPaginated`
/// to access the nested member `[ConnectClientTypes.InstanceSummary]`
/// - Returns: `[ConnectClientTypes.InstanceSummary]`
extension PaginatorSequence where Input == ListInstancesInput, Output == ListInstancesOutputResponse {
    func instanceSummaryList() async throws -> [ConnectClientTypes.InstanceSummary] {
        return try await self.asyncCompactMap { item in item.instanceSummaryList }
    }
}

/// Paginate over `[ListInstanceStorageConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListInstanceStorageConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListInstanceStorageConfigsOutputResponse`
extension ConnectClient {
    public func listInstanceStorageConfigsPaginated(input: ListInstanceStorageConfigsInput) -> ClientRuntime.PaginatorSequence<ListInstanceStorageConfigsInput, ListInstanceStorageConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInstanceStorageConfigsInput, ListInstanceStorageConfigsOutputResponse>(input: input, inputKey: \ListInstanceStorageConfigsInput.nextToken, outputKey: \ListInstanceStorageConfigsOutputResponse.nextToken, paginationFunction: self.listInstanceStorageConfigs(input:))
    }
}

extension ListInstanceStorageConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstanceStorageConfigsInput {
        return ListInstanceStorageConfigsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listInstanceStorageConfigsPaginated`
/// to access the nested member `[ConnectClientTypes.InstanceStorageConfig]`
/// - Returns: `[ConnectClientTypes.InstanceStorageConfig]`
extension PaginatorSequence where Input == ListInstanceStorageConfigsInput, Output == ListInstanceStorageConfigsOutputResponse {
    func storageConfigs() async throws -> [ConnectClientTypes.InstanceStorageConfig] {
        return try await self.asyncCompactMap { item in item.storageConfigs }
    }
}

/// Paginate over `[ListIntegrationAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListIntegrationAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListIntegrationAssociationsOutputResponse`
extension ConnectClient {
    public func listIntegrationAssociationsPaginated(input: ListIntegrationAssociationsInput) -> ClientRuntime.PaginatorSequence<ListIntegrationAssociationsInput, ListIntegrationAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIntegrationAssociationsInput, ListIntegrationAssociationsOutputResponse>(input: input, inputKey: \ListIntegrationAssociationsInput.nextToken, outputKey: \ListIntegrationAssociationsOutputResponse.nextToken, paginationFunction: self.listIntegrationAssociations(input:))
    }
}

extension ListIntegrationAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIntegrationAssociationsInput {
        return ListIntegrationAssociationsInput(
            instanceId: self.instanceId,
            integrationType: self.integrationType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listIntegrationAssociationsPaginated`
/// to access the nested member `[ConnectClientTypes.IntegrationAssociationSummary]`
/// - Returns: `[ConnectClientTypes.IntegrationAssociationSummary]`
extension PaginatorSequence where Input == ListIntegrationAssociationsInput, Output == ListIntegrationAssociationsOutputResponse {
    func integrationAssociationSummaryList() async throws -> [ConnectClientTypes.IntegrationAssociationSummary] {
        return try await self.asyncCompactMap { item in item.integrationAssociationSummaryList }
    }
}

/// Paginate over `[ListLambdaFunctionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListLambdaFunctionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListLambdaFunctionsOutputResponse`
extension ConnectClient {
    public func listLambdaFunctionsPaginated(input: ListLambdaFunctionsInput) -> ClientRuntime.PaginatorSequence<ListLambdaFunctionsInput, ListLambdaFunctionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLambdaFunctionsInput, ListLambdaFunctionsOutputResponse>(input: input, inputKey: \ListLambdaFunctionsInput.nextToken, outputKey: \ListLambdaFunctionsOutputResponse.nextToken, paginationFunction: self.listLambdaFunctions(input:))
    }
}

extension ListLambdaFunctionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLambdaFunctionsInput {
        return ListLambdaFunctionsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listLambdaFunctionsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListLambdaFunctionsInput, Output == ListLambdaFunctionsOutputResponse {
    func lambdaFunctions() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.lambdaFunctions }
    }
}

/// Paginate over `[ListLexBotsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListLexBotsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListLexBotsOutputResponse`
extension ConnectClient {
    public func listLexBotsPaginated(input: ListLexBotsInput) -> ClientRuntime.PaginatorSequence<ListLexBotsInput, ListLexBotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLexBotsInput, ListLexBotsOutputResponse>(input: input, inputKey: \ListLexBotsInput.nextToken, outputKey: \ListLexBotsOutputResponse.nextToken, paginationFunction: self.listLexBots(input:))
    }
}

extension ListLexBotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLexBotsInput {
        return ListLexBotsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listLexBotsPaginated`
/// to access the nested member `[ConnectClientTypes.LexBot]`
/// - Returns: `[ConnectClientTypes.LexBot]`
extension PaginatorSequence where Input == ListLexBotsInput, Output == ListLexBotsOutputResponse {
    func lexBots() async throws -> [ConnectClientTypes.LexBot] {
        return try await self.asyncCompactMap { item in item.lexBots }
    }
}

/// Paginate over `[ListPhoneNumbersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPhoneNumbersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPhoneNumbersOutputResponse`
extension ConnectClient {
    public func listPhoneNumbersPaginated(input: ListPhoneNumbersInput) -> ClientRuntime.PaginatorSequence<ListPhoneNumbersInput, ListPhoneNumbersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPhoneNumbersInput, ListPhoneNumbersOutputResponse>(input: input, inputKey: \ListPhoneNumbersInput.nextToken, outputKey: \ListPhoneNumbersOutputResponse.nextToken, paginationFunction: self.listPhoneNumbers(input:))
    }
}

extension ListPhoneNumbersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPhoneNumbersInput {
        return ListPhoneNumbersInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            phoneNumberCountryCodes: self.phoneNumberCountryCodes,
            phoneNumberTypes: self.phoneNumberTypes
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPhoneNumbersPaginated`
/// to access the nested member `[ConnectClientTypes.PhoneNumberSummary]`
/// - Returns: `[ConnectClientTypes.PhoneNumberSummary]`
extension PaginatorSequence where Input == ListPhoneNumbersInput, Output == ListPhoneNumbersOutputResponse {
    func phoneNumberSummaryList() async throws -> [ConnectClientTypes.PhoneNumberSummary] {
        return try await self.asyncCompactMap { item in item.phoneNumberSummaryList }
    }
}

/// Paginate over `[ListPromptsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPromptsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPromptsOutputResponse`
extension ConnectClient {
    public func listPromptsPaginated(input: ListPromptsInput) -> ClientRuntime.PaginatorSequence<ListPromptsInput, ListPromptsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPromptsInput, ListPromptsOutputResponse>(input: input, inputKey: \ListPromptsInput.nextToken, outputKey: \ListPromptsOutputResponse.nextToken, paginationFunction: self.listPrompts(input:))
    }
}

extension ListPromptsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPromptsInput {
        return ListPromptsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPromptsPaginated`
/// to access the nested member `[ConnectClientTypes.PromptSummary]`
/// - Returns: `[ConnectClientTypes.PromptSummary]`
extension PaginatorSequence where Input == ListPromptsInput, Output == ListPromptsOutputResponse {
    func promptSummaryList() async throws -> [ConnectClientTypes.PromptSummary] {
        return try await self.asyncCompactMap { item in item.promptSummaryList }
    }
}

/// Paginate over `[ListQueueQuickConnectsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListQueueQuickConnectsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListQueueQuickConnectsOutputResponse`
extension ConnectClient {
    public func listQueueQuickConnectsPaginated(input: ListQueueQuickConnectsInput) -> ClientRuntime.PaginatorSequence<ListQueueQuickConnectsInput, ListQueueQuickConnectsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListQueueQuickConnectsInput, ListQueueQuickConnectsOutputResponse>(input: input, inputKey: \ListQueueQuickConnectsInput.nextToken, outputKey: \ListQueueQuickConnectsOutputResponse.nextToken, paginationFunction: self.listQueueQuickConnects(input:))
    }
}

extension ListQueueQuickConnectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQueueQuickConnectsInput {
        return ListQueueQuickConnectsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listQueueQuickConnectsPaginated`
/// to access the nested member `[ConnectClientTypes.QuickConnectSummary]`
/// - Returns: `[ConnectClientTypes.QuickConnectSummary]`
extension PaginatorSequence where Input == ListQueueQuickConnectsInput, Output == ListQueueQuickConnectsOutputResponse {
    func quickConnectSummaryList() async throws -> [ConnectClientTypes.QuickConnectSummary] {
        return try await self.asyncCompactMap { item in item.quickConnectSummaryList }
    }
}

/// Paginate over `[ListQueuesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListQueuesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListQueuesOutputResponse`
extension ConnectClient {
    public func listQueuesPaginated(input: ListQueuesInput) -> ClientRuntime.PaginatorSequence<ListQueuesInput, ListQueuesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListQueuesInput, ListQueuesOutputResponse>(input: input, inputKey: \ListQueuesInput.nextToken, outputKey: \ListQueuesOutputResponse.nextToken, paginationFunction: self.listQueues(input:))
    }
}

extension ListQueuesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQueuesInput {
        return ListQueuesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            queueTypes: self.queueTypes
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listQueuesPaginated`
/// to access the nested member `[ConnectClientTypes.QueueSummary]`
/// - Returns: `[ConnectClientTypes.QueueSummary]`
extension PaginatorSequence where Input == ListQueuesInput, Output == ListQueuesOutputResponse {
    func queueSummaryList() async throws -> [ConnectClientTypes.QueueSummary] {
        return try await self.asyncCompactMap { item in item.queueSummaryList }
    }
}

/// Paginate over `[ListQuickConnectsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListQuickConnectsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListQuickConnectsOutputResponse`
extension ConnectClient {
    public func listQuickConnectsPaginated(input: ListQuickConnectsInput) -> ClientRuntime.PaginatorSequence<ListQuickConnectsInput, ListQuickConnectsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListQuickConnectsInput, ListQuickConnectsOutputResponse>(input: input, inputKey: \ListQuickConnectsInput.nextToken, outputKey: \ListQuickConnectsOutputResponse.nextToken, paginationFunction: self.listQuickConnects(input:))
    }
}

extension ListQuickConnectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQuickConnectsInput {
        return ListQuickConnectsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            quickConnectTypes: self.quickConnectTypes
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listQuickConnectsPaginated`
/// to access the nested member `[ConnectClientTypes.QuickConnectSummary]`
/// - Returns: `[ConnectClientTypes.QuickConnectSummary]`
extension PaginatorSequence where Input == ListQuickConnectsInput, Output == ListQuickConnectsOutputResponse {
    func quickConnectSummaryList() async throws -> [ConnectClientTypes.QuickConnectSummary] {
        return try await self.asyncCompactMap { item in item.quickConnectSummaryList }
    }
}

/// Paginate over `[ListRoutingProfileQueuesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListRoutingProfileQueuesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListRoutingProfileQueuesOutputResponse`
extension ConnectClient {
    public func listRoutingProfileQueuesPaginated(input: ListRoutingProfileQueuesInput) -> ClientRuntime.PaginatorSequence<ListRoutingProfileQueuesInput, ListRoutingProfileQueuesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRoutingProfileQueuesInput, ListRoutingProfileQueuesOutputResponse>(input: input, inputKey: \ListRoutingProfileQueuesInput.nextToken, outputKey: \ListRoutingProfileQueuesOutputResponse.nextToken, paginationFunction: self.listRoutingProfileQueues(input:))
    }
}

extension ListRoutingProfileQueuesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRoutingProfileQueuesInput {
        return ListRoutingProfileQueuesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            routingProfileId: self.routingProfileId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listRoutingProfileQueuesPaginated`
/// to access the nested member `[ConnectClientTypes.RoutingProfileQueueConfigSummary]`
/// - Returns: `[ConnectClientTypes.RoutingProfileQueueConfigSummary]`
extension PaginatorSequence where Input == ListRoutingProfileQueuesInput, Output == ListRoutingProfileQueuesOutputResponse {
    func routingProfileQueueConfigSummaryList() async throws -> [ConnectClientTypes.RoutingProfileQueueConfigSummary] {
        return try await self.asyncCompactMap { item in item.routingProfileQueueConfigSummaryList }
    }
}

/// Paginate over `[ListRoutingProfilesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListRoutingProfilesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListRoutingProfilesOutputResponse`
extension ConnectClient {
    public func listRoutingProfilesPaginated(input: ListRoutingProfilesInput) -> ClientRuntime.PaginatorSequence<ListRoutingProfilesInput, ListRoutingProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRoutingProfilesInput, ListRoutingProfilesOutputResponse>(input: input, inputKey: \ListRoutingProfilesInput.nextToken, outputKey: \ListRoutingProfilesOutputResponse.nextToken, paginationFunction: self.listRoutingProfiles(input:))
    }
}

extension ListRoutingProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRoutingProfilesInput {
        return ListRoutingProfilesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listRoutingProfilesPaginated`
/// to access the nested member `[ConnectClientTypes.RoutingProfileSummary]`
/// - Returns: `[ConnectClientTypes.RoutingProfileSummary]`
extension PaginatorSequence where Input == ListRoutingProfilesInput, Output == ListRoutingProfilesOutputResponse {
    func routingProfileSummaryList() async throws -> [ConnectClientTypes.RoutingProfileSummary] {
        return try await self.asyncCompactMap { item in item.routingProfileSummaryList }
    }
}

/// Paginate over `[ListSecurityKeysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSecurityKeysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSecurityKeysOutputResponse`
extension ConnectClient {
    public func listSecurityKeysPaginated(input: ListSecurityKeysInput) -> ClientRuntime.PaginatorSequence<ListSecurityKeysInput, ListSecurityKeysOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSecurityKeysInput, ListSecurityKeysOutputResponse>(input: input, inputKey: \ListSecurityKeysInput.nextToken, outputKey: \ListSecurityKeysOutputResponse.nextToken, paginationFunction: self.listSecurityKeys(input:))
    }
}

extension ListSecurityKeysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityKeysInput {
        return ListSecurityKeysInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSecurityKeysPaginated`
/// to access the nested member `[ConnectClientTypes.SecurityKey]`
/// - Returns: `[ConnectClientTypes.SecurityKey]`
extension PaginatorSequence where Input == ListSecurityKeysInput, Output == ListSecurityKeysOutputResponse {
    func securityKeys() async throws -> [ConnectClientTypes.SecurityKey] {
        return try await self.asyncCompactMap { item in item.securityKeys }
    }
}

/// Paginate over `[ListSecurityProfilePermissionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSecurityProfilePermissionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSecurityProfilePermissionsOutputResponse`
extension ConnectClient {
    public func listSecurityProfilePermissionsPaginated(input: ListSecurityProfilePermissionsInput) -> ClientRuntime.PaginatorSequence<ListSecurityProfilePermissionsInput, ListSecurityProfilePermissionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSecurityProfilePermissionsInput, ListSecurityProfilePermissionsOutputResponse>(input: input, inputKey: \ListSecurityProfilePermissionsInput.nextToken, outputKey: \ListSecurityProfilePermissionsOutputResponse.nextToken, paginationFunction: self.listSecurityProfilePermissions(input:))
    }
}

extension ListSecurityProfilePermissionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityProfilePermissionsInput {
        return ListSecurityProfilePermissionsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileId: self.securityProfileId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSecurityProfilePermissionsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListSecurityProfilePermissionsInput, Output == ListSecurityProfilePermissionsOutputResponse {
    func permissions() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.permissions }
    }
}

/// Paginate over `[ListSecurityProfilesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSecurityProfilesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSecurityProfilesOutputResponse`
extension ConnectClient {
    public func listSecurityProfilesPaginated(input: ListSecurityProfilesInput) -> ClientRuntime.PaginatorSequence<ListSecurityProfilesInput, ListSecurityProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSecurityProfilesInput, ListSecurityProfilesOutputResponse>(input: input, inputKey: \ListSecurityProfilesInput.nextToken, outputKey: \ListSecurityProfilesOutputResponse.nextToken, paginationFunction: self.listSecurityProfiles(input:))
    }
}

extension ListSecurityProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityProfilesInput {
        return ListSecurityProfilesInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSecurityProfilesPaginated`
/// to access the nested member `[ConnectClientTypes.SecurityProfileSummary]`
/// - Returns: `[ConnectClientTypes.SecurityProfileSummary]`
extension PaginatorSequence where Input == ListSecurityProfilesInput, Output == ListSecurityProfilesOutputResponse {
    func securityProfileSummaryList() async throws -> [ConnectClientTypes.SecurityProfileSummary] {
        return try await self.asyncCompactMap { item in item.securityProfileSummaryList }
    }
}

/// Paginate over `[ListUseCasesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListUseCasesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListUseCasesOutputResponse`
extension ConnectClient {
    public func listUseCasesPaginated(input: ListUseCasesInput) -> ClientRuntime.PaginatorSequence<ListUseCasesInput, ListUseCasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUseCasesInput, ListUseCasesOutputResponse>(input: input, inputKey: \ListUseCasesInput.nextToken, outputKey: \ListUseCasesOutputResponse.nextToken, paginationFunction: self.listUseCases(input:))
    }
}

extension ListUseCasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUseCasesInput {
        return ListUseCasesInput(
            instanceId: self.instanceId,
            integrationAssociationId: self.integrationAssociationId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listUseCasesPaginated`
/// to access the nested member `[ConnectClientTypes.UseCase]`
/// - Returns: `[ConnectClientTypes.UseCase]`
extension PaginatorSequence where Input == ListUseCasesInput, Output == ListUseCasesOutputResponse {
    func useCaseSummaryList() async throws -> [ConnectClientTypes.UseCase] {
        return try await self.asyncCompactMap { item in item.useCaseSummaryList }
    }
}

/// Paginate over `[ListUserHierarchyGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListUserHierarchyGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListUserHierarchyGroupsOutputResponse`
extension ConnectClient {
    public func listUserHierarchyGroupsPaginated(input: ListUserHierarchyGroupsInput) -> ClientRuntime.PaginatorSequence<ListUserHierarchyGroupsInput, ListUserHierarchyGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUserHierarchyGroupsInput, ListUserHierarchyGroupsOutputResponse>(input: input, inputKey: \ListUserHierarchyGroupsInput.nextToken, outputKey: \ListUserHierarchyGroupsOutputResponse.nextToken, paginationFunction: self.listUserHierarchyGroups(input:))
    }
}

extension ListUserHierarchyGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUserHierarchyGroupsInput {
        return ListUserHierarchyGroupsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listUserHierarchyGroupsPaginated`
/// to access the nested member `[ConnectClientTypes.HierarchyGroupSummary]`
/// - Returns: `[ConnectClientTypes.HierarchyGroupSummary]`
extension PaginatorSequence where Input == ListUserHierarchyGroupsInput, Output == ListUserHierarchyGroupsOutputResponse {
    func userHierarchyGroupSummaryList() async throws -> [ConnectClientTypes.HierarchyGroupSummary] {
        return try await self.asyncCompactMap { item in item.userHierarchyGroupSummaryList }
    }
}

/// Paginate over `[ListUsersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListUsersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListUsersOutputResponse`
extension ConnectClient {
    public func listUsersPaginated(input: ListUsersInput) -> ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutputResponse>(input: input, inputKey: \ListUsersInput.nextToken, outputKey: \ListUsersOutputResponse.nextToken, paginationFunction: self.listUsers(input:))
    }
}

extension ListUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUsersInput {
        return ListUsersInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listUsersPaginated`
/// to access the nested member `[ConnectClientTypes.UserSummary]`
/// - Returns: `[ConnectClientTypes.UserSummary]`
extension PaginatorSequence where Input == ListUsersInput, Output == ListUsersOutputResponse {
    func userSummaryList() async throws -> [ConnectClientTypes.UserSummary] {
        return try await self.asyncCompactMap { item in item.userSummaryList }
    }
}
