// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IotWirelessClientTypes.AbpV1_0_x: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devAddr = "DevAddr"
        case sessionKeys = "SessionKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devAddr = devAddr {
            try encodeContainer.encode(devAddr, forKey: .devAddr)
        }
        if let sessionKeys = sessionKeys {
            try encodeContainer.encode(sessionKeys, forKey: .sessionKeys)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devAddrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devAddr)
        devAddr = devAddrDecoded
        let sessionKeysDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SessionKeysAbpV1_0_x.self, forKey: .sessionKeys)
        sessionKeys = sessionKeysDecoded
    }
}

extension IotWirelessClientTypes {
    /// ABP device object for LoRaWAN specification v1.0.x
    public struct AbpV1_0_x: Swift.Equatable {
        /// The DevAddr value.
        public var devAddr: Swift.String?
        /// Session keys for ABP v1.0.x
        public var sessionKeys: IotWirelessClientTypes.SessionKeysAbpV1_0_x?

        public init (
            devAddr: Swift.String? = nil,
            sessionKeys: IotWirelessClientTypes.SessionKeysAbpV1_0_x? = nil
        )
        {
            self.devAddr = devAddr
            self.sessionKeys = sessionKeys
        }
    }

}

extension IotWirelessClientTypes.AbpV1_1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devAddr = "DevAddr"
        case sessionKeys = "SessionKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devAddr = devAddr {
            try encodeContainer.encode(devAddr, forKey: .devAddr)
        }
        if let sessionKeys = sessionKeys {
            try encodeContainer.encode(sessionKeys, forKey: .sessionKeys)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devAddrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devAddr)
        devAddr = devAddrDecoded
        let sessionKeysDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SessionKeysAbpV1_1.self, forKey: .sessionKeys)
        sessionKeys = sessionKeysDecoded
    }
}

extension IotWirelessClientTypes {
    /// ABP device object for LoRaWAN specification v1.1
    public struct AbpV1_1: Swift.Equatable {
        /// The DevAddr value.
        public var devAddr: Swift.String?
        /// Session keys for ABP v1.1
        public var sessionKeys: IotWirelessClientTypes.SessionKeysAbpV1_1?

        public init (
            devAddr: Swift.String? = nil,
            sessionKeys: IotWirelessClientTypes.SessionKeysAbpV1_1? = nil
        )
        {
            self.devAddr = devAddr
            self.sessionKeys = sessionKeys
        }
    }

}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User does not have permission to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateAwsAccountWithPartnerAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension AssociateAwsAccountWithPartnerAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/partner-accounts"
    }
}

public struct AssociateAwsAccountWithPartnerAccountInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The Sidewalk account credentials.
    /// This member is required.
    public var sidewalk: IotWirelessClientTypes.SidewalkAccountInfo?
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        sidewalk: IotWirelessClientTypes.SidewalkAccountInfo? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sidewalk = sidewalk
        self.tags = tags
    }
}

struct AssociateAwsAccountWithPartnerAccountInputBody: Swift.Equatable {
    let sidewalk: IotWirelessClientTypes.SidewalkAccountInfo?
    let clientRequestToken: Swift.String?
    let tags: [IotWirelessClientTypes.Tag]?
}

extension AssociateAwsAccountWithPartnerAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkAccountInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AssociateAwsAccountWithPartnerAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAwsAccountWithPartnerAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateAwsAccountWithPartnerAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAwsAccountWithPartnerAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateAwsAccountWithPartnerAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.sidewalk = output.sidewalk
        } else {
            self.arn = nil
            self.sidewalk = nil
        }
    }
}

public struct AssociateAwsAccountWithPartnerAccountOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The Sidewalk account credentials.
    public var sidewalk: IotWirelessClientTypes.SidewalkAccountInfo?

    public init (
        arn: Swift.String? = nil,
        sidewalk: IotWirelessClientTypes.SidewalkAccountInfo? = nil
    )
    {
        self.arn = arn
        self.sidewalk = sidewalk
    }
}

struct AssociateAwsAccountWithPartnerAccountOutputResponseBody: Swift.Equatable {
    let sidewalk: IotWirelessClientTypes.SidewalkAccountInfo?
    let arn: Swift.String?
}

extension AssociateAwsAccountWithPartnerAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkAccountInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension AssociateMulticastGroupWithFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastGroupId = "MulticastGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let multicastGroupId = multicastGroupId {
            try encodeContainer.encode(multicastGroupId, forKey: .multicastGroupId)
        }
    }
}

extension AssociateMulticastGroupWithFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/multicast-group"
    }
}

public struct AssociateMulticastGroupWithFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the multicast group.
    /// This member is required.
    public var multicastGroupId: Swift.String?

    public init (
        id: Swift.String? = nil,
        multicastGroupId: Swift.String? = nil
    )
    {
        self.id = id
        self.multicastGroupId = multicastGroupId
    }
}

struct AssociateMulticastGroupWithFuotaTaskInputBody: Swift.Equatable {
    let multicastGroupId: Swift.String?
}

extension AssociateMulticastGroupWithFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastGroupId = "MulticastGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multicastGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multicastGroupId)
        multicastGroupId = multicastGroupIdDecoded
    }
}

extension AssociateMulticastGroupWithFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateMulticastGroupWithFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateMulticastGroupWithFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateMulticastGroupWithFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateMulticastGroupWithFuotaTaskOutputResponse: Swift.Equatable {

}

extension AssociateWirelessDeviceWithFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessDeviceId = wirelessDeviceId {
            try encodeContainer.encode(wirelessDeviceId, forKey: .wirelessDeviceId)
        }
    }
}

extension AssociateWirelessDeviceWithFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/wireless-device"
    }
}

public struct AssociateWirelessDeviceWithFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init (
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct AssociateWirelessDeviceWithFuotaTaskInputBody: Swift.Equatable {
    let wirelessDeviceId: Swift.String?
}

extension AssociateWirelessDeviceWithFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessDeviceId)
        wirelessDeviceId = wirelessDeviceIdDecoded
    }
}

extension AssociateWirelessDeviceWithFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessDeviceWithFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWirelessDeviceWithFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessDeviceWithFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWirelessDeviceWithFuotaTaskOutputResponse: Swift.Equatable {

}

extension AssociateWirelessDeviceWithMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessDeviceId = wirelessDeviceId {
            try encodeContainer.encode(wirelessDeviceId, forKey: .wirelessDeviceId)
        }
    }
}

extension AssociateWirelessDeviceWithMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/wireless-device"
    }
}

public struct AssociateWirelessDeviceWithMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init (
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct AssociateWirelessDeviceWithMulticastGroupInputBody: Swift.Equatable {
    let wirelessDeviceId: Swift.String?
}

extension AssociateWirelessDeviceWithMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessDeviceId)
        wirelessDeviceId = wirelessDeviceIdDecoded
    }
}

extension AssociateWirelessDeviceWithMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessDeviceWithMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWirelessDeviceWithMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessDeviceWithMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWirelessDeviceWithMulticastGroupOutputResponse: Swift.Equatable {

}

extension AssociateWirelessDeviceWithThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }
}

extension AssociateWirelessDeviceWithThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/thing"
    }
}

public struct AssociateWirelessDeviceWithThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of the thing to associate with the wireless device.
    /// This member is required.
    public var thingArn: Swift.String?

    public init (
        id: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.id = id
        self.thingArn = thingArn
    }
}

struct AssociateWirelessDeviceWithThingInputBody: Swift.Equatable {
    let thingArn: Swift.String?
}

extension AssociateWirelessDeviceWithThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension AssociateWirelessDeviceWithThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessDeviceWithThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWirelessDeviceWithThingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessDeviceWithThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWirelessDeviceWithThingOutputResponse: Swift.Equatable {

}

extension AssociateWirelessGatewayWithCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotCertificateId = iotCertificateId {
            try encodeContainer.encode(iotCertificateId, forKey: .iotCertificateId)
        }
    }
}

extension AssociateWirelessGatewayWithCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
    }
}

public struct AssociateWirelessGatewayWithCertificateInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the certificate to associate with the wireless gateway.
    /// This member is required.
    public var iotCertificateId: Swift.String?

    public init (
        id: Swift.String? = nil,
        iotCertificateId: Swift.String? = nil
    )
    {
        self.id = id
        self.iotCertificateId = iotCertificateId
    }
}

struct AssociateWirelessGatewayWithCertificateInputBody: Swift.Equatable {
    let iotCertificateId: Swift.String?
}

extension AssociateWirelessGatewayWithCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
    }
}

extension AssociateWirelessGatewayWithCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessGatewayWithCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWirelessGatewayWithCertificateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessGatewayWithCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateWirelessGatewayWithCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iotCertificateId = output.iotCertificateId
        } else {
            self.iotCertificateId = nil
        }
    }
}

public struct AssociateWirelessGatewayWithCertificateOutputResponse: Swift.Equatable {
    /// The ID of the certificate associated with the wireless gateway.
    public var iotCertificateId: Swift.String?

    public init (
        iotCertificateId: Swift.String? = nil
    )
    {
        self.iotCertificateId = iotCertificateId
    }
}

struct AssociateWirelessGatewayWithCertificateOutputResponseBody: Swift.Equatable {
    let iotCertificateId: Swift.String?
}

extension AssociateWirelessGatewayWithCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
    }
}

extension AssociateWirelessGatewayWithThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }
}

extension AssociateWirelessGatewayWithThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/thing"
    }
}

public struct AssociateWirelessGatewayWithThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of the thing to associate with the wireless gateway.
    /// This member is required.
    public var thingArn: Swift.String?

    public init (
        id: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.id = id
        self.thingArn = thingArn
    }
}

struct AssociateWirelessGatewayWithThingInputBody: Swift.Equatable {
    let thingArn: Swift.String?
}

extension AssociateWirelessGatewayWithThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension AssociateWirelessGatewayWithThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessGatewayWithThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWirelessGatewayWithThingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessGatewayWithThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWirelessGatewayWithThingOutputResponse: Swift.Equatable {

}

extension IotWirelessClientTypes {
    /// Sidewalk device battery level.
    public enum BatteryLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case low
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [BatteryLevel] {
            return [
                .critical,
                .low,
                .normal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "critical"
            case .low: return "low"
            case .normal: return "normal"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatteryLevel(rawValue: rawValue) ?? BatteryLevel.sdkUnknown(rawValue)
        }
    }
}

extension CancelMulticastGroupSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/session"
    }
}

public struct CancelMulticastGroupSessionInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CancelMulticastGroupSessionInputBody: Swift.Equatable {
}

extension CancelMulticastGroupSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelMulticastGroupSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelMulticastGroupSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelMulticastGroupSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelMulticastGroupSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelMulticastGroupSessionOutputResponse: Swift.Equatable {

}

extension IotWirelessClientTypes.CertificateList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingAlg = "SigningAlg"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingAlg = signingAlg {
            try encodeContainer.encode(signingAlg.rawValue, forKey: .signingAlg)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingAlgDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SigningAlg.self, forKey: .signingAlg)
        signingAlg = signingAlgDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IotWirelessClientTypes {
    /// List of sidewalk certificates.
    public struct CertificateList: Swift.Equatable {
        /// The certificate chain algorithm provided by sidewalk.
        /// This member is required.
        public var signingAlg: IotWirelessClientTypes.SigningAlg?
        /// The value of the chosen sidewalk certificate.
        /// This member is required.
        public var value: Swift.String?

        public init (
            signingAlg: IotWirelessClientTypes.SigningAlg? = nil,
            value: Swift.String? = nil
        )
        {
            self.signingAlg = signingAlg
            self.value = value
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Adding, updating, or deleting the resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Id of the resource in the conflicting operation.
    public var resourceId: Swift.String?
    /// Type of the resource in the conflicting operation.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension IotWirelessClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .disconnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .disconnected: return "Disconnected"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/destinations"
    }
}

public struct CreateDestinationInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The rule name or topic rule to send messages to.
    /// This member is required.
    public var expression: Swift.String?
    /// The type of value in Expression.
    /// This member is required.
    public var expressionType: IotWirelessClientTypes.ExpressionType?
    /// The name of the new resource.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags to attach to the new destination. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IotWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDestinationInputBody: Swift.Equatable {
    let name: Swift.String?
    let expressionType: IotWirelessClientTypes.ExpressionType?
    let expression: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let tags: [IotWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateDestinationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The name of the new resource.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateDestinationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
}

extension CreateDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateDeviceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateDeviceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/device-profiles"
    }
}

public struct CreateDeviceProfileInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The device profile information to use to create the device profile.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANDeviceProfile?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new device profile. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANDeviceProfile? = nil,
        name: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateDeviceProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANDeviceProfile?
    let tags: [IotWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateDeviceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANDeviceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateDeviceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeviceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeviceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeviceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeviceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateDeviceProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new device profile.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateDeviceProfileOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateDeviceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firmwareUpdateImage = firmwareUpdateImage {
            try encodeContainer.encode(firmwareUpdateImage, forKey: .firmwareUpdateImage)
        }
        if let firmwareUpdateRole = firmwareUpdateRole {
            try encodeContainer.encode(firmwareUpdateRole, forKey: .firmwareUpdateRole)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/fuota-tasks"
    }
}

public struct CreateFuotaTaskInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The S3 URI points to a firmware update image that is to be used with a FUOTA task.
    /// This member is required.
    public var firmwareUpdateImage: Swift.String?
    /// The firmware update role that is to be used with a FUOTA task.
    /// This member is required.
    public var firmwareUpdateRole: Swift.String?
    /// The LoRaWAN information used with a FUOTA task.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANFuotaTask?
    /// The name of a FUOTA task.
    public var name: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        firmwareUpdateImage: Swift.String? = nil,
        firmwareUpdateRole: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANFuotaTask? = nil,
        name: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.firmwareUpdateImage = firmwareUpdateImage
        self.firmwareUpdateRole = firmwareUpdateRole
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateFuotaTaskInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANFuotaTask?
    let firmwareUpdateImage: Swift.String?
    let firmwareUpdateRole: Swift.String?
    let tags: [IotWirelessClientTypes.Tag]?
}

extension CreateFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANFuotaTask.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let firmwareUpdateImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateImage)
        firmwareUpdateImage = firmwareUpdateImageDecoded
        let firmwareUpdateRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateRole)
        firmwareUpdateRole = firmwareUpdateRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFuotaTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateFuotaTaskOutputResponse: Swift.Equatable {
    /// The arn of a FUOTA task.
    public var arn: Swift.String?
    /// The ID of a FUOTA task.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateFuotaTaskOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateFuotaTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/multicast-groups"
    }
}

public struct CreateMulticastGroupInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the multicast group.
    public var description: Swift.String?
    /// The LoRaWAN information that is to be used with the multicast group.
    /// This member is required.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANMulticast?
    /// The name of the multicast group.
    public var name: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANMulticast? = nil,
        name: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateMulticastGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANMulticast?
    let tags: [IotWirelessClientTypes.Tag]?
}

extension CreateMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANMulticast.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMulticastGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateMulticastGroupOutputResponse: Swift.Equatable {
    /// The arn of the multicast group.
    public var arn: Swift.String?
    /// The ID of the multicast group.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateMulticastGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateMulticastGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateServiceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateServiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-profiles"
    }
}

public struct CreateServiceProfileInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The service profile information to use to create the service profile.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANServiceProfile?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new service profile. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANServiceProfile? = nil,
        name: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateServiceProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANServiceProfile?
    let tags: [IotWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateServiceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANServiceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateServiceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServiceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateServiceProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new service profile.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateServiceProfileOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateServiceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateWirelessDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationName = destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-devices"
    }
}

public struct CreateWirelessDeviceInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The name of the destination to assign to the new wireless device.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The device configuration information to use to create the wireless device.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANDevice?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new wireless device. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?
    /// The wireless device type.
    /// This member is required.
    public var type: IotWirelessClientTypes.WirelessDeviceType?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANDevice? = nil,
        name: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil,
        type: IotWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.destinationName = destinationName
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateWirelessDeviceInputBody: Swift.Equatable {
    let type: IotWirelessClientTypes.WirelessDeviceType?
    let name: Swift.String?
    let description: Swift.String?
    let destinationName: Swift.String?
    let clientRequestToken: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANDevice?
    let tags: [IotWirelessClientTypes.Tag]?
}

extension CreateWirelessDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessDeviceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new wireless device.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessDeviceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateWirelessDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateWirelessGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateWirelessGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-gateways"
    }
}

public struct CreateWirelessGatewayInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The gateway configuration information to use to create the wireless gateway.
    /// This member is required.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANGateway?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new wireless gateway. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANGateway? = nil,
        name: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateWirelessGatewayInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANGateway?
    let tags: [IotWirelessClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateWirelessGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateWirelessGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWirelessGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWirelessGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new wireless gateway.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessGatewayOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
}

extension CreateWirelessGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateWirelessGatewayTaskDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoCreateTasks = "AutoCreateTasks"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case tags = "Tags"
        case update = "Update"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoCreateTasks != false {
            try encodeContainer.encode(autoCreateTasks, forKey: .autoCreateTasks)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let update = update {
            try encodeContainer.encode(update, forKey: .update)
        }
    }
}

extension CreateWirelessGatewayTaskDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-gateway-task-definitions"
    }
}

public struct CreateWirelessGatewayTaskDefinitionInput: Swift.Equatable {
    /// Whether to automatically create tasks using this task definition for all gateways with the specified current version. If false, the task must me created by calling CreateWirelessGatewayTask.
    /// This member is required.
    public var autoCreateTasks: Swift.Bool
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?
    /// Information about the gateways to update.
    public var update: IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate?

    public init (
        autoCreateTasks: Swift.Bool = false,
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil,
        update: IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate? = nil
    )
    {
        self.autoCreateTasks = autoCreateTasks
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.tags = tags
        self.update = update
    }
}

struct CreateWirelessGatewayTaskDefinitionInputBody: Swift.Equatable {
    let autoCreateTasks: Swift.Bool
    let name: Swift.String?
    let update: IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate?
    let clientRequestToken: Swift.String?
    let tags: [IotWirelessClientTypes.Tag]?
}

extension CreateWirelessGatewayTaskDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoCreateTasks = "AutoCreateTasks"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case tags = "Tags"
        case update = "Update"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoCreateTasksDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoCreateTasks)
        autoCreateTasks = autoCreateTasksDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updateDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate.self, forKey: .update)
        update = updateDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWirelessGatewayTaskDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessGatewayTaskDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWirelessGatewayTaskDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessGatewayTaskDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWirelessGatewayTaskDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessGatewayTaskDefinitionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the new wireless gateway task definition.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension CreateWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateWirelessGatewayTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId {
            try encodeContainer.encode(wirelessGatewayTaskDefinitionId, forKey: .wirelessGatewayTaskDefinitionId)
        }
    }
}

extension CreateWirelessGatewayTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
    }
}

public struct CreateWirelessGatewayTaskInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the WirelessGatewayTaskDefinition.
    /// This member is required.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init (
        id: Swift.String? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct CreateWirelessGatewayTaskInputBody: Swift.Equatable {
    let wirelessGatewayTaskDefinitionId: Swift.String?
}

extension CreateWirelessGatewayTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
    }
}

extension CreateWirelessGatewayTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessGatewayTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWirelessGatewayTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessGatewayTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWirelessGatewayTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.wirelessGatewayTaskDefinitionId = output.wirelessGatewayTaskDefinitionId
        } else {
            self.status = nil
            self.wirelessGatewayTaskDefinitionId = nil
        }
    }
}

public struct CreateWirelessGatewayTaskOutputResponse: Swift.Equatable {
    /// The status of the request.
    public var status: IotWirelessClientTypes.WirelessGatewayTaskStatus?
    /// The ID of the WirelessGatewayTaskDefinition.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init (
        status: IotWirelessClientTypes.WirelessGatewayTaskStatus? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.status = status
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct CreateWirelessGatewayTaskOutputResponseBody: Swift.Equatable {
    let wirelessGatewayTaskDefinitionId: Swift.String?
    let status: IotWirelessClientTypes.WirelessGatewayTaskStatus?
}

extension CreateWirelessGatewayTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessGatewayTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

public struct DeleteDestinationInput: Swift.Equatable {
    /// The name of the resource to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDestinationInputBody: Swift.Equatable {
}

extension DeleteDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDestinationOutputResponse: Swift.Equatable {

}

extension DeleteDeviceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/device-profiles/\(id.urlPercentEncoding())"
    }
}

public struct DeleteDeviceProfileInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteDeviceProfileInputBody: Swift.Equatable {
}

extension DeleteDeviceProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeviceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeviceProfileOutputResponse: Swift.Equatable {

}

extension DeleteFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

public struct DeleteFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteFuotaTaskInputBody: Swift.Equatable {
}

extension DeleteFuotaTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFuotaTaskOutputResponse: Swift.Equatable {

}

extension DeleteMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())"
    }
}

public struct DeleteMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteMulticastGroupInputBody: Swift.Equatable {
}

extension DeleteMulticastGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMulticastGroupOutputResponse: Swift.Equatable {

}

extension DeleteServiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/service-profiles/\(id.urlPercentEncoding())"
    }
}

public struct DeleteServiceProfileInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteServiceProfileInputBody: Swift.Equatable {
}

extension DeleteServiceProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceProfileOutputResponse: Swift.Equatable {

}

extension DeleteWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWirelessDeviceInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessDeviceInputBody: Swift.Equatable {
}

extension DeleteWirelessDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessDeviceOutputResponse: Swift.Equatable {

}

extension DeleteWirelessGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWirelessGatewayInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayInputBody: Swift.Equatable {
}

extension DeleteWirelessGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWirelessGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessGatewayOutputResponse: Swift.Equatable {

}

extension DeleteWirelessGatewayTaskDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateway-task-definitions/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWirelessGatewayTaskDefinitionInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayTaskDefinitionInputBody: Swift.Equatable {
}

extension DeleteWirelessGatewayTaskDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessGatewayTaskDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWirelessGatewayTaskDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessGatewayTaskDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessGatewayTaskDefinitionOutputResponse: Swift.Equatable {

}

extension DeleteWirelessGatewayTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
    }
}

public struct DeleteWirelessGatewayTaskInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayTaskInputBody: Swift.Equatable {
}

extension DeleteWirelessGatewayTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessGatewayTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWirelessGatewayTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessGatewayTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessGatewayTaskOutputResponse: Swift.Equatable {

}

extension IotWirelessClientTypes.Destinations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IotWirelessClientTypes {
    /// Describes a destination.
    public struct Destinations: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The description of the resource.
        public var description: Swift.String?
        /// The rule name or topic rule to send messages to.
        public var expression: Swift.String?
        /// The type of value in Expression.
        public var expressionType: IotWirelessClientTypes.ExpressionType?
        /// The name of the resource.
        public var name: Swift.String?
        /// The ARN of the IAM Role that authorizes the destination.
        public var roleArn: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            expression: Swift.String? = nil,
            expressionType: IotWirelessClientTypes.ExpressionType? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.expression = expression
            self.expressionType = expressionType
            self.name = name
            self.roleArn = roleArn
        }
    }

}

extension IotWirelessClientTypes.DeviceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IotWirelessClientTypes {
    /// Describes a device profile.
    public struct DeviceProfile: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the device profile.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IotWirelessClientTypes.DeviceRegistrationStateEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkEventNotificationConfigurations.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IotWirelessClientTypes {
    /// Device registration state event configuration object for enabling and disabling relevant topics.
    public struct DeviceRegistrationStateEventConfiguration: Swift.Equatable {
        /// Device registration state event configuration object for enabling or disabling Sidewalk related event topics.
        public var sidewalk: IotWirelessClientTypes.SidewalkEventNotificationConfigurations?

        public init (
            sidewalk: IotWirelessClientTypes.SidewalkEventNotificationConfigurations? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }

}

extension IotWirelessClientTypes {
    /// Device state defines the device status of sidewalk device.
    public enum DeviceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case provisioned
        case registerednotseen
        case registeredreachable
        case registeredunreachable
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceState] {
            return [
                .provisioned,
                .registerednotseen,
                .registeredreachable,
                .registeredunreachable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .provisioned: return "Provisioned"
            case .registerednotseen: return "RegisteredNotSeen"
            case .registeredreachable: return "RegisteredReachable"
            case .registeredunreachable: return "RegisteredUnreachable"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceState(rawValue: rawValue) ?? DeviceState.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateAwsAccountFromPartnerAccountInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let partnerType = partnerType {
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
        }
        return items
    }
}

extension DisassociateAwsAccountFromPartnerAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let partnerAccountId = partnerAccountId else {
            return nil
        }
        return "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
    }
}

public struct DisassociateAwsAccountFromPartnerAccountInput: Swift.Equatable {
    /// The partner account ID to disassociate from the AWS account.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IotWirelessClientTypes.PartnerType?

    public init (
        partnerAccountId: Swift.String? = nil,
        partnerType: IotWirelessClientTypes.PartnerType? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
    }
}

struct DisassociateAwsAccountFromPartnerAccountInputBody: Swift.Equatable {
}

extension DisassociateAwsAccountFromPartnerAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateAwsAccountFromPartnerAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAwsAccountFromPartnerAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateAwsAccountFromPartnerAccountOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAwsAccountFromPartnerAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateAwsAccountFromPartnerAccountOutputResponse: Swift.Equatable {

}

extension DisassociateMulticastGroupFromFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        guard let multicastGroupId = multicastGroupId else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/multicast-groups/\(multicastGroupId.urlPercentEncoding())"
    }
}

public struct DisassociateMulticastGroupFromFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the multicast group.
    /// This member is required.
    public var multicastGroupId: Swift.String?

    public init (
        id: Swift.String? = nil,
        multicastGroupId: Swift.String? = nil
    )
    {
        self.id = id
        self.multicastGroupId = multicastGroupId
    }
}

struct DisassociateMulticastGroupFromFuotaTaskInputBody: Swift.Equatable {
}

extension DisassociateMulticastGroupFromFuotaTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateMulticastGroupFromFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMulticastGroupFromFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMulticastGroupFromFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMulticastGroupFromFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMulticastGroupFromFuotaTaskOutputResponse: Swift.Equatable {

}

extension DisassociateWirelessDeviceFromFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        guard let wirelessDeviceId = wirelessDeviceId else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())"
    }
}

public struct DisassociateWirelessDeviceFromFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init (
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct DisassociateWirelessDeviceFromFuotaTaskInputBody: Swift.Equatable {
}

extension DisassociateWirelessDeviceFromFuotaTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessDeviceFromFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWirelessDeviceFromFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessDeviceFromFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessDeviceFromFuotaTaskOutputResponse: Swift.Equatable {

}

extension DisassociateWirelessDeviceFromMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        guard let wirelessDeviceId = wirelessDeviceId else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())"
    }
}

public struct DisassociateWirelessDeviceFromMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the wireless device.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init (
        id: Swift.String? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct DisassociateWirelessDeviceFromMulticastGroupInputBody: Swift.Equatable {
}

extension DisassociateWirelessDeviceFromMulticastGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessDeviceFromMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWirelessDeviceFromMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessDeviceFromMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessDeviceFromMulticastGroupOutputResponse: Swift.Equatable {

}

extension DisassociateWirelessDeviceFromThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/thing"
    }
}

public struct DisassociateWirelessDeviceFromThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessDeviceFromThingInputBody: Swift.Equatable {
}

extension DisassociateWirelessDeviceFromThingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessDeviceFromThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWirelessDeviceFromThingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessDeviceFromThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessDeviceFromThingOutputResponse: Swift.Equatable {

}

extension DisassociateWirelessGatewayFromCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
    }
}

public struct DisassociateWirelessGatewayFromCertificateInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessGatewayFromCertificateInputBody: Swift.Equatable {
}

extension DisassociateWirelessGatewayFromCertificateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessGatewayFromCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWirelessGatewayFromCertificateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessGatewayFromCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessGatewayFromCertificateOutputResponse: Swift.Equatable {

}

extension DisassociateWirelessGatewayFromThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/thing"
    }
}

public struct DisassociateWirelessGatewayFromThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessGatewayFromThingInputBody: Swift.Equatable {
}

extension DisassociateWirelessGatewayFromThingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessGatewayFromThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWirelessGatewayFromThingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessGatewayFromThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessGatewayFromThingOutputResponse: Swift.Equatable {

}

extension IotWirelessClientTypes {
    /// DlClass for LoRaWAM, valid values are ClassB and ClassC.
    public enum DlClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case classb
        case classc
        case sdkUnknown(Swift.String)

        public static var allCases: [DlClass] {
            return [
                .classb,
                .classc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .classb: return "ClassB"
            case .classc: return "ClassC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DlClass(rawValue: rawValue) ?? DlClass.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    /// Sidewalk device status notification.
    public enum Event: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ack
        case discovered
        case lost
        case nack
        case passthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [Event] {
            return [
                .ack,
                .discovered,
                .lost,
                .nack,
                .passthrough,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ack: return "ack"
            case .discovered: return "discovered"
            case .lost: return "lost"
            case .nack: return "nack"
            case .passthrough: return "passthrough"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Event(rawValue: rawValue) ?? Event.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    public enum EventNotificationPartnerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [EventNotificationPartnerType] {
            return [
                .sidewalk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventNotificationPartnerType(rawValue: rawValue) ?? EventNotificationPartnerType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    public enum EventNotificationTopicStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EventNotificationTopicStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventNotificationTopicStatus(rawValue: rawValue) ?? EventNotificationTopicStatus.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    public enum ExpressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mqtttopic
        case rulename
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpressionType] {
            return [
                .mqtttopic,
                .rulename,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mqtttopic: return "MqttTopic"
            case .rulename: return "RuleName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpressionType(rawValue: rawValue) ?? ExpressionType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.FPorts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clockSync = "ClockSync"
        case fuota = "Fuota"
        case multicast = "Multicast"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clockSync = clockSync {
            try encodeContainer.encode(clockSync, forKey: .clockSync)
        }
        if let fuota = fuota {
            try encodeContainer.encode(fuota, forKey: .fuota)
        }
        if let multicast = multicast {
            try encodeContainer.encode(multicast, forKey: .multicast)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fuotaDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fuota)
        fuota = fuotaDecoded
        let multicastDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .multicast)
        multicast = multicastDecoded
        let clockSyncDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clockSync)
        clockSync = clockSyncDecoded
    }
}

extension IotWirelessClientTypes {
    /// List of FPort assigned for different LoRaWAN application packages to use
    public struct FPorts: Swift.Equatable {
        /// The Fport value.
        public var clockSync: Swift.Int?
        /// The Fport value.
        public var fuota: Swift.Int?
        /// The Fport value.
        public var multicast: Swift.Int?

        public init (
            clockSync: Swift.Int? = nil,
            fuota: Swift.Int? = nil,
            multicast: Swift.Int? = nil
        )
        {
            self.clockSync = clockSync
            self.fuota = fuota
            self.multicast = multicast
        }
    }

}

extension IotWirelessClientTypes {
    /// The status of a wireless device in a FUOTA task.
    public enum FuotaDeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fragalgoUnsupported
        case fragindexUnsupported
        case initial
        case micerror
        case memoryerror
        case missingfrag
        case notEnoughMemory
        case packageNotSupported
        case sessioncntReplay
        case successful
        case wrongDescriptor
        case sdkUnknown(Swift.String)

        public static var allCases: [FuotaDeviceStatus] {
            return [
                .fragalgoUnsupported,
                .fragindexUnsupported,
                .initial,
                .micerror,
                .memoryerror,
                .missingfrag,
                .notEnoughMemory,
                .packageNotSupported,
                .sessioncntReplay,
                .successful,
                .wrongDescriptor,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fragalgoUnsupported: return "FragAlgo_unsupported"
            case .fragindexUnsupported: return "FragIndex_unsupported"
            case .initial: return "Initial"
            case .micerror: return "MICError"
            case .memoryerror: return "MemoryError"
            case .missingfrag: return "MissingFrag"
            case .notEnoughMemory: return "Not_enough_memory"
            case .packageNotSupported: return "Package_Not_Supported"
            case .sessioncntReplay: return "SessionCnt_replay"
            case .successful: return "Successful"
            case .wrongDescriptor: return "Wrong_descriptor"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FuotaDeviceStatus(rawValue: rawValue) ?? FuotaDeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.FuotaTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IotWirelessClientTypes {
    /// A FUOTA task.
    public struct FuotaTask: Swift.Equatable {
        /// The arn of a FUOTA task.
        public var arn: Swift.String?
        /// The ID of a FUOTA task.
        public var id: Swift.String?
        /// The name of a FUOTA task.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IotWirelessClientTypes {
    /// The status of a FUOTA task.
    public enum FuotaTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteWaiting
        case fuotadone
        case fuotasessionWaiting
        case inFuotasession
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [FuotaTaskStatus] {
            return [
                .deleteWaiting,
                .fuotadone,
                .fuotasessionWaiting,
                .inFuotasession,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteWaiting: return "Delete_Waiting"
            case .fuotadone: return "FuotaDone"
            case .fuotasessionWaiting: return "FuotaSession_Waiting"
            case .inFuotasession: return "In_FuotaSession"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FuotaTaskStatus(rawValue: rawValue) ?? FuotaTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

public struct GetDestinationInput: Swift.Equatable {
    /// The name of the resource to get.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetDestinationInputBody: Swift.Equatable {
}

extension GetDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.expression = output.expression
            self.expressionType = output.expressionType
            self.name = output.name
            self.roleArn = output.roleArn
        } else {
            self.arn = nil
            self.description = nil
            self.expression = nil
            self.expressionType = nil
            self.name = nil
            self.roleArn = nil
        }
    }
}

public struct GetDestinationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The rule name or topic rule to send messages to.
    public var expression: Swift.String?
    /// The type of value in Expression.
    public var expressionType: IotWirelessClientTypes.ExpressionType?
    /// The name of the resource.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    public var roleArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IotWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

struct GetDestinationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let expression: Swift.String?
    let expressionType: IotWirelessClientTypes.ExpressionType?
    let description: Swift.String?
    let roleArn: Swift.String?
}

extension GetDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension GetDeviceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/device-profiles/\(id.urlPercentEncoding())"
    }
}

public struct GetDeviceProfileInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDeviceProfileInputBody: Swift.Equatable {
}

extension GetDeviceProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeviceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
        }
    }
}

public struct GetDeviceProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the device profile.
    public var id: Swift.String?
    /// Information about the device profile.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANDeviceProfile?
    /// The name of the resource.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANDeviceProfile? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct GetDeviceProfileOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let id: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANDeviceProfile?
}

extension GetDeviceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANDeviceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

public struct GetFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFuotaTaskInputBody: Swift.Equatable {
}

extension GetFuotaTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFuotaTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.firmwareUpdateImage = output.firmwareUpdateImage
            self.firmwareUpdateRole = output.firmwareUpdateRole
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.firmwareUpdateImage = nil
            self.firmwareUpdateRole = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct GetFuotaTaskOutputResponse: Swift.Equatable {
    /// The arn of a FUOTA task.
    public var arn: Swift.String?
    /// Created at timestamp for the resource.
    public var createdAt: ClientRuntime.Date?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The S3 URI points to a firmware update image that is to be used with a FUOTA task.
    public var firmwareUpdateImage: Swift.String?
    /// The firmware update role that is to be used with a FUOTA task.
    public var firmwareUpdateRole: Swift.String?
    /// The ID of a FUOTA task.
    public var id: Swift.String?
    /// The LoRaWAN information returned from getting a FUOTA task.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANFuotaTaskGetInfo?
    /// The name of a FUOTA task.
    public var name: Swift.String?
    /// The status of a FUOTA task.
    public var status: IotWirelessClientTypes.FuotaTaskStatus?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        firmwareUpdateImage: Swift.String? = nil,
        firmwareUpdateRole: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANFuotaTaskGetInfo? = nil,
        name: Swift.String? = nil,
        status: IotWirelessClientTypes.FuotaTaskStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.firmwareUpdateImage = firmwareUpdateImage
        self.firmwareUpdateRole = firmwareUpdateRole
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.status = status
    }
}

struct GetFuotaTaskOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let status: IotWirelessClientTypes.FuotaTaskStatus?
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANFuotaTaskGetInfo?
    let firmwareUpdateImage: Swift.String?
    let firmwareUpdateRole: Swift.String?
    let createdAt: ClientRuntime.Date?
}

extension GetFuotaTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.FuotaTaskStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANFuotaTaskGetInfo.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let firmwareUpdateImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateImage)
        firmwareUpdateImage = firmwareUpdateImageDecoded
        let firmwareUpdateRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateRole)
        firmwareUpdateRole = firmwareUpdateRoleDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension GetLogLevelsByResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/log-levels"
    }
}

public struct GetLogLevelsByResourceTypesInput: Swift.Equatable {

}

struct GetLogLevelsByResourceTypesInputBody: Swift.Equatable {
}

extension GetLogLevelsByResourceTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLogLevelsByResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLogLevelsByResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLogLevelsByResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLogLevelsByResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLogLevelsByResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.defaultLogLevel = output.defaultLogLevel
            self.wirelessDeviceLogOptions = output.wirelessDeviceLogOptions
            self.wirelessGatewayLogOptions = output.wirelessGatewayLogOptions
        } else {
            self.defaultLogLevel = nil
            self.wirelessDeviceLogOptions = nil
            self.wirelessGatewayLogOptions = nil
        }
    }
}

public struct GetLogLevelsByResourceTypesOutputResponse: Swift.Equatable {
    /// The log level for a log message.
    public var defaultLogLevel: IotWirelessClientTypes.LogLevel?
    /// The list of wireless device log options.
    public var wirelessDeviceLogOptions: [IotWirelessClientTypes.WirelessDeviceLogOption]?
    /// The list of wireless gateway log options.
    public var wirelessGatewayLogOptions: [IotWirelessClientTypes.WirelessGatewayLogOption]?

    public init (
        defaultLogLevel: IotWirelessClientTypes.LogLevel? = nil,
        wirelessDeviceLogOptions: [IotWirelessClientTypes.WirelessDeviceLogOption]? = nil,
        wirelessGatewayLogOptions: [IotWirelessClientTypes.WirelessGatewayLogOption]? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
        self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
    }
}

struct GetLogLevelsByResourceTypesOutputResponseBody: Swift.Equatable {
    let defaultLogLevel: IotWirelessClientTypes.LogLevel?
    let wirelessGatewayLogOptions: [IotWirelessClientTypes.WirelessGatewayLogOption]?
    let wirelessDeviceLogOptions: [IotWirelessClientTypes.WirelessDeviceLogOption]?
}

extension GetLogLevelsByResourceTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let wirelessGatewayLogOptionsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessGatewayLogOption?].self, forKey: .wirelessGatewayLogOptions)
        var wirelessGatewayLogOptionsDecoded0:[IotWirelessClientTypes.WirelessGatewayLogOption]? = nil
        if let wirelessGatewayLogOptionsContainer = wirelessGatewayLogOptionsContainer {
            wirelessGatewayLogOptionsDecoded0 = [IotWirelessClientTypes.WirelessGatewayLogOption]()
            for structure0 in wirelessGatewayLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessGatewayLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayLogOptions = wirelessGatewayLogOptionsDecoded0
        let wirelessDeviceLogOptionsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessDeviceLogOption?].self, forKey: .wirelessDeviceLogOptions)
        var wirelessDeviceLogOptionsDecoded0:[IotWirelessClientTypes.WirelessDeviceLogOption]? = nil
        if let wirelessDeviceLogOptionsContainer = wirelessDeviceLogOptionsContainer {
            wirelessDeviceLogOptionsDecoded0 = [IotWirelessClientTypes.WirelessDeviceLogOption]()
            for structure0 in wirelessDeviceLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessDeviceLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceLogOptions = wirelessDeviceLogOptionsDecoded0
    }
}

extension GetMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())"
    }
}

public struct GetMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetMulticastGroupInputBody: Swift.Equatable {
}

extension GetMulticastGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMulticastGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct GetMulticastGroupOutputResponse: Swift.Equatable {
    /// The arn of the multicast group.
    public var arn: Swift.String?
    /// Created at timestamp for the resource.
    public var createdAt: ClientRuntime.Date?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The ID of the multicast group.
    public var id: Swift.String?
    /// The LoRaWAN information that is to be returned from getting multicast group information.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANMulticastGet?
    /// The name of the multicast group.
    public var name: Swift.String?
    /// The status of the multicast group.
    public var status: Swift.String?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANMulticastGet? = nil,
        name: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.status = status
    }
}

struct GetMulticastGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let status: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANMulticastGet?
    let createdAt: ClientRuntime.Date?
}

extension GetMulticastGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANMulticastGet.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension GetMulticastGroupSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/session"
    }
}

public struct GetMulticastGroupSessionInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetMulticastGroupSessionInputBody: Swift.Equatable {
}

extension GetMulticastGroupSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMulticastGroupSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMulticastGroupSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMulticastGroupSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMulticastGroupSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMulticastGroupSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loRaWAN = output.loRaWAN
        } else {
            self.loRaWAN = nil
        }
    }
}

public struct GetMulticastGroupSessionOutputResponse: Swift.Equatable {
    /// The LoRaWAN information used with the multicast session.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANMulticastSession?

    public init (
        loRaWAN: IotWirelessClientTypes.LoRaWANMulticastSession? = nil
    )
    {
        self.loRaWAN = loRaWAN
    }
}

struct GetMulticastGroupSessionOutputResponseBody: Swift.Equatable {
    let loRaWAN: IotWirelessClientTypes.LoRaWANMulticastSession?
}

extension GetMulticastGroupSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANMulticastSession.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetNetworkAnalyzerConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationName = configurationName else {
            return nil
        }
        return "/network-analyzer-configurations/\(configurationName.urlPercentEncoding())"
    }
}

public struct GetNetworkAnalyzerConfigurationInput: Swift.Equatable {
    /// NetworkAnalyzer configuration name.
    /// This member is required.
    public var configurationName: Swift.String?

    public init (
        configurationName: Swift.String? = nil
    )
    {
        self.configurationName = configurationName
    }
}

struct GetNetworkAnalyzerConfigurationInputBody: Swift.Equatable {
}

extension GetNetworkAnalyzerConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkAnalyzerConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkAnalyzerConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNetworkAnalyzerConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkAnalyzerConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNetworkAnalyzerConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.traceContent = output.traceContent
            self.wirelessDevices = output.wirelessDevices
            self.wirelessGateways = output.wirelessGateways
        } else {
            self.traceContent = nil
            self.wirelessDevices = nil
            self.wirelessGateways = nil
        }
    }
}

public struct GetNetworkAnalyzerConfigurationOutputResponse: Swift.Equatable {
    /// Trace Content for resources.
    public var traceContent: IotWirelessClientTypes.TraceContent?
    /// List of WirelessDevices in the NetworkAnalyzerConfiguration.
    public var wirelessDevices: [Swift.String]?
    /// List of WirelessGateways in the NetworkAnalyzerConfiguration.
    public var wirelessGateways: [Swift.String]?

    public init (
        traceContent: IotWirelessClientTypes.TraceContent? = nil,
        wirelessDevices: [Swift.String]? = nil,
        wirelessGateways: [Swift.String]? = nil
    )
    {
        self.traceContent = traceContent
        self.wirelessDevices = wirelessDevices
        self.wirelessGateways = wirelessGateways
    }
}

struct GetNetworkAnalyzerConfigurationOutputResponseBody: Swift.Equatable {
    let traceContent: IotWirelessClientTypes.TraceContent?
    let wirelessDevices: [Swift.String]?
    let wirelessGateways: [Swift.String]?
}

extension GetNetworkAnalyzerConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case traceContent = "TraceContent"
        case wirelessDevices = "WirelessDevices"
        case wirelessGateways = "WirelessGateways"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceContentDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.TraceContent.self, forKey: .traceContent)
        traceContent = traceContentDecoded
        let wirelessDevicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessDevices)
        var wirelessDevicesDecoded0:[Swift.String]? = nil
        if let wirelessDevicesContainer = wirelessDevicesContainer {
            wirelessDevicesDecoded0 = [Swift.String]()
            for string0 in wirelessDevicesContainer {
                if let string0 = string0 {
                    wirelessDevicesDecoded0?.append(string0)
                }
            }
        }
        wirelessDevices = wirelessDevicesDecoded0
        let wirelessGatewaysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessGateways)
        var wirelessGatewaysDecoded0:[Swift.String]? = nil
        if let wirelessGatewaysContainer = wirelessGatewaysContainer {
            wirelessGatewaysDecoded0 = [Swift.String]()
            for string0 in wirelessGatewaysContainer {
                if let string0 = string0 {
                    wirelessGatewaysDecoded0?.append(string0)
                }
            }
        }
        wirelessGateways = wirelessGatewaysDecoded0
    }
}

extension GetPartnerAccountInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let partnerType = partnerType {
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
        }
        return items
    }
}

extension GetPartnerAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let partnerAccountId = partnerAccountId else {
            return nil
        }
        return "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
    }
}

public struct GetPartnerAccountInput: Swift.Equatable {
    /// The partner account ID to disassociate from the AWS account.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IotWirelessClientTypes.PartnerType?

    public init (
        partnerAccountId: Swift.String? = nil,
        partnerType: IotWirelessClientTypes.PartnerType? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
    }
}

struct GetPartnerAccountInputBody: Swift.Equatable {
}

extension GetPartnerAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPartnerAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPartnerAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPartnerAccountOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPartnerAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPartnerAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountLinked = output.accountLinked
            self.sidewalk = output.sidewalk
        } else {
            self.accountLinked = false
            self.sidewalk = nil
        }
    }
}

public struct GetPartnerAccountOutputResponse: Swift.Equatable {
    /// Whether the partner account is linked to the AWS account.
    public var accountLinked: Swift.Bool
    /// The Sidewalk account credentials.
    public var sidewalk: IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint?

    public init (
        accountLinked: Swift.Bool = false,
        sidewalk: IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint? = nil
    )
    {
        self.accountLinked = accountLinked
        self.sidewalk = sidewalk
    }
}

struct GetPartnerAccountOutputResponseBody: Swift.Equatable {
    let sidewalk: IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint?
    let accountLinked: Swift.Bool
}

extension GetPartnerAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLinked = "AccountLinked"
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let accountLinkedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .accountLinked)
        accountLinked = accountLinkedDecoded
    }
}

extension GetResourceEventConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let partnerType = partnerType {
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
        }
        if let identifierType = identifierType {
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            items.append(identifierTypeQueryItem)
        }
        return items
    }
}

extension GetResourceEventConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/event-configurations/\(identifier.urlPercentEncoding())"
    }
}

public struct GetResourceEventConfigurationInput: Swift.Equatable {
    /// Resource identifier to opt in for event messaging.
    /// This member is required.
    public var identifier: Swift.String?
    /// Identifier type of the particular resource identifier for event configuration.
    /// This member is required.
    public var identifierType: IotWirelessClientTypes.IdentifierType?
    /// Partner type of the resource if the identifier type is PartnerAccountId.
    public var partnerType: IotWirelessClientTypes.EventNotificationPartnerType?

    public init (
        identifier: Swift.String? = nil,
        identifierType: IotWirelessClientTypes.IdentifierType? = nil,
        partnerType: IotWirelessClientTypes.EventNotificationPartnerType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
        self.partnerType = partnerType
    }
}

struct GetResourceEventConfigurationInputBody: Swift.Equatable {
}

extension GetResourceEventConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceEventConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceEventConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceEventConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceEventConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceEventConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceRegistrationState = output.deviceRegistrationState
            self.proximity = output.proximity
        } else {
            self.deviceRegistrationState = nil
            self.proximity = nil
        }
    }
}

public struct GetResourceEventConfigurationOutputResponse: Swift.Equatable {
    /// Event configuration for the device registration state event
    public var deviceRegistrationState: IotWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    /// Event configuration for the Proximity event
    public var proximity: IotWirelessClientTypes.ProximityEventConfiguration?

    public init (
        deviceRegistrationState: IotWirelessClientTypes.DeviceRegistrationStateEventConfiguration? = nil,
        proximity: IotWirelessClientTypes.ProximityEventConfiguration? = nil
    )
    {
        self.deviceRegistrationState = deviceRegistrationState
        self.proximity = proximity
    }
}

struct GetResourceEventConfigurationOutputResponseBody: Swift.Equatable {
    let deviceRegistrationState: IotWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    let proximity: IotWirelessClientTypes.ProximityEventConfiguration?
}

extension GetResourceEventConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceRegistrationState = "DeviceRegistrationState"
        case proximity = "Proximity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationStateDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.DeviceRegistrationStateEventConfiguration.self, forKey: .deviceRegistrationState)
        deviceRegistrationState = deviceRegistrationStateDecoded
        let proximityDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.ProximityEventConfiguration.self, forKey: .proximity)
        proximity = proximityDecoded
    }
}

extension GetResourceLogLevelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceType = resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension GetResourceLogLevelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct GetResourceLogLevelInput: Swift.Equatable {
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway, it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct GetResourceLogLevelInputBody: Swift.Equatable {
}

extension GetResourceLogLevelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceLogLevelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceLogLevelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceLogLevelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceLogLevelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceLogLevelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logLevel = output.logLevel
        } else {
            self.logLevel = nil
        }
    }
}

public struct GetResourceLogLevelOutputResponse: Swift.Equatable {
    /// The log level for a log message.
    public var logLevel: IotWirelessClientTypes.LogLevel?

    public init (
        logLevel: IotWirelessClientTypes.LogLevel? = nil
    )
    {
        self.logLevel = logLevel
    }
}

struct GetResourceLogLevelOutputResponseBody: Swift.Equatable {
    let logLevel: IotWirelessClientTypes.LogLevel?
}

extension GetResourceLogLevelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension GetServiceEndpointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let serviceType = serviceType {
            let serviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "serviceType".urlPercentEncoding(), value: Swift.String(serviceType.rawValue).urlPercentEncoding())
            items.append(serviceTypeQueryItem)
        }
        return items
    }
}

extension GetServiceEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-endpoint"
    }
}

public struct GetServiceEndpointInput: Swift.Equatable {
    /// The service type for which to get endpoint information about. Can be CUPS for the Configuration and Update Server endpoint, or LNS for the LoRaWAN Network Server endpoint.
    public var serviceType: IotWirelessClientTypes.WirelessGatewayServiceType?

    public init (
        serviceType: IotWirelessClientTypes.WirelessGatewayServiceType? = nil
    )
    {
        self.serviceType = serviceType
    }
}

struct GetServiceEndpointInputBody: Swift.Equatable {
}

extension GetServiceEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverTrust = output.serverTrust
            self.serviceEndpoint = output.serviceEndpoint
            self.serviceType = output.serviceType
        } else {
            self.serverTrust = nil
            self.serviceEndpoint = nil
            self.serviceType = nil
        }
    }
}

public struct GetServiceEndpointOutputResponse: Swift.Equatable {
    /// The Root CA of the server trust certificate.
    public var serverTrust: Swift.String?
    /// The service endpoint value.
    public var serviceEndpoint: Swift.String?
    /// The endpoint's service type.
    public var serviceType: IotWirelessClientTypes.WirelessGatewayServiceType?

    public init (
        serverTrust: Swift.String? = nil,
        serviceEndpoint: Swift.String? = nil,
        serviceType: IotWirelessClientTypes.WirelessGatewayServiceType? = nil
    )
    {
        self.serverTrust = serverTrust
        self.serviceEndpoint = serviceEndpoint
        self.serviceType = serviceType
    }
}

struct GetServiceEndpointOutputResponseBody: Swift.Equatable {
    let serviceType: IotWirelessClientTypes.WirelessGatewayServiceType?
    let serviceEndpoint: Swift.String?
    let serverTrust: Swift.String?
}

extension GetServiceEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverTrust = "ServerTrust"
        case serviceEndpoint = "ServiceEndpoint"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessGatewayServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let serviceEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceEndpoint)
        serviceEndpoint = serviceEndpointDecoded
        let serverTrustDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverTrust)
        serverTrust = serverTrustDecoded
    }
}

extension GetServiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/service-profiles/\(id.urlPercentEncoding())"
    }
}

public struct GetServiceProfileInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetServiceProfileInputBody: Swift.Equatable {
}

extension GetServiceProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
        }
    }
}

public struct GetServiceProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the service profile.
    public var id: Swift.String?
    /// Information about the service profile.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANGetServiceProfileInfo?
    /// The name of the resource.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANGetServiceProfileInfo? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct GetServiceProfileOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let id: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANGetServiceProfileInfo?
}

extension GetServiceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGetServiceProfileInfo.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetWirelessDeviceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let identifierType = identifierType {
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            items.append(identifierTypeQueryItem)
        }
        return items
    }
}

extension GetWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/wireless-devices/\(identifier.urlPercentEncoding())"
    }
}

public struct GetWirelessDeviceInput: Swift.Equatable {
    /// The identifier of the wireless device to get.
    /// This member is required.
    public var identifier: Swift.String?
    /// The type of identifier used in identifier.
    /// This member is required.
    public var identifierType: IotWirelessClientTypes.WirelessDeviceIdType?

    public init (
        identifier: Swift.String? = nil,
        identifierType: IotWirelessClientTypes.WirelessDeviceIdType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
    }
}

struct GetWirelessDeviceInputBody: Swift.Equatable {
}

extension GetWirelessDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.destinationName = output.destinationName
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.sidewalk = output.sidewalk
            self.thingArn = output.thingArn
            self.thingName = output.thingName
            self.type = output.type
        } else {
            self.arn = nil
            self.description = nil
            self.destinationName = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.sidewalk = nil
            self.thingArn = nil
            self.thingName = nil
            self.type = nil
        }
    }
}

public struct GetWirelessDeviceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The name of the destination to which the device is assigned.
    public var destinationName: Swift.String?
    /// The ID of the wireless device.
    public var id: Swift.String?
    /// Information about the wireless device.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANDevice?
    /// The name of the resource.
    public var name: Swift.String?
    /// Sidewalk device object.
    public var sidewalk: IotWirelessClientTypes.SidewalkDevice?
    /// The ARN of the thing associated with the wireless device.
    public var thingArn: Swift.String?
    /// The name of the thing associated with the wireless device. The value is empty if a thing isn't associated with the device.
    public var thingName: Swift.String?
    /// The wireless device type.
    public var type: IotWirelessClientTypes.WirelessDeviceType?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANDevice? = nil,
        name: Swift.String? = nil,
        sidewalk: IotWirelessClientTypes.SidewalkDevice? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil,
        type: IotWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.destinationName = destinationName
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.sidewalk = sidewalk
        self.thingArn = thingArn
        self.thingName = thingName
        self.type = type
    }
}

struct GetWirelessDeviceOutputResponseBody: Swift.Equatable {
    let type: IotWirelessClientTypes.WirelessDeviceType?
    let name: Swift.String?
    let description: Swift.String?
    let destinationName: Swift.String?
    let id: Swift.String?
    let arn: Swift.String?
    let thingName: Swift.String?
    let thingArn: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANDevice?
    let sidewalk: IotWirelessClientTypes.SidewalkDevice?
}

extension GetWirelessDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case destinationName = "DestinationName"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case sidewalk = "Sidewalk"
        case thingArn = "ThingArn"
        case thingName = "ThingName"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension GetWirelessDeviceStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let wirelessDeviceId = wirelessDeviceId else {
            return nil
        }
        return "/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())/statistics"
    }
}

public struct GetWirelessDeviceStatisticsInput: Swift.Equatable {
    /// The ID of the wireless device for which to get the data.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init (
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct GetWirelessDeviceStatisticsInputBody: Swift.Equatable {
}

extension GetWirelessDeviceStatisticsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessDeviceStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessDeviceStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessDeviceStatisticsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessDeviceStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessDeviceStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.loRaWAN = output.loRaWAN
            self.sidewalk = output.sidewalk
            self.wirelessDeviceId = output.wirelessDeviceId
        } else {
            self.lastUplinkReceivedAt = nil
            self.loRaWAN = nil
            self.sidewalk = nil
            self.wirelessDeviceId = nil
        }
    }
}

public struct GetWirelessDeviceStatisticsOutputResponse: Swift.Equatable {
    /// The date and time when the most recent uplink was received.
    public var lastUplinkReceivedAt: Swift.String?
    /// Information about the wireless device's operations.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANDeviceMetadata?
    /// MetaData for Sidewalk device.
    public var sidewalk: IotWirelessClientTypes.SidewalkDeviceMetadata?
    /// The ID of the wireless device.
    public var wirelessDeviceId: Swift.String?

    public init (
        lastUplinkReceivedAt: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANDeviceMetadata? = nil,
        sidewalk: IotWirelessClientTypes.SidewalkDeviceMetadata? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.loRaWAN = loRaWAN
        self.sidewalk = sidewalk
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct GetWirelessDeviceStatisticsOutputResponseBody: Swift.Equatable {
    let wirelessDeviceId: Swift.String?
    let lastUplinkReceivedAt: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANDeviceMetadata?
    let sidewalk: IotWirelessClientTypes.SidewalkDeviceMetadata?
}

extension GetWirelessDeviceStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case sidewalk = "Sidewalk"
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessDeviceId)
        wirelessDeviceId = wirelessDeviceIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANDeviceMetadata.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkDeviceMetadata.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension GetWirelessGatewayCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
    }
}

public struct GetWirelessGatewayCertificateInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayCertificateInputBody: Swift.Equatable {
}

extension GetWirelessGatewayCertificateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayCertificateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessGatewayCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iotCertificateId = output.iotCertificateId
            self.loRaWANNetworkServerCertificateId = output.loRaWANNetworkServerCertificateId
        } else {
            self.iotCertificateId = nil
            self.loRaWANNetworkServerCertificateId = nil
        }
    }
}

public struct GetWirelessGatewayCertificateOutputResponse: Swift.Equatable {
    /// The ID of the certificate associated with the wireless gateway.
    public var iotCertificateId: Swift.String?
    /// The ID of the certificate that is associated with the wireless gateway and used for the LoRaWANNetworkServer endpoint.
    public var loRaWANNetworkServerCertificateId: Swift.String?

    public init (
        iotCertificateId: Swift.String? = nil,
        loRaWANNetworkServerCertificateId: Swift.String? = nil
    )
    {
        self.iotCertificateId = iotCertificateId
        self.loRaWANNetworkServerCertificateId = loRaWANNetworkServerCertificateId
    }
}

struct GetWirelessGatewayCertificateOutputResponseBody: Swift.Equatable {
    let iotCertificateId: Swift.String?
    let loRaWANNetworkServerCertificateId: Swift.String?
}

extension GetWirelessGatewayCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
        case loRaWANNetworkServerCertificateId = "LoRaWANNetworkServerCertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
        let loRaWANNetworkServerCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loRaWANNetworkServerCertificateId)
        loRaWANNetworkServerCertificateId = loRaWANNetworkServerCertificateIdDecoded
    }
}

extension GetWirelessGatewayFirmwareInformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/firmware-information"
    }
}

public struct GetWirelessGatewayFirmwareInformationInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayFirmwareInformationInputBody: Swift.Equatable {
}

extension GetWirelessGatewayFirmwareInformationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayFirmwareInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayFirmwareInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayFirmwareInformationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayFirmwareInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessGatewayFirmwareInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loRaWAN = output.loRaWAN
        } else {
            self.loRaWAN = nil
        }
    }
}

public struct GetWirelessGatewayFirmwareInformationOutputResponse: Swift.Equatable {
    /// Information about the wireless gateway's firmware.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANGatewayCurrentVersion?

    public init (
        loRaWAN: IotWirelessClientTypes.LoRaWANGatewayCurrentVersion? = nil
    )
    {
        self.loRaWAN = loRaWAN
    }
}

struct GetWirelessGatewayFirmwareInformationOutputResponseBody: Swift.Equatable {
    let loRaWAN: IotWirelessClientTypes.LoRaWANGatewayCurrentVersion?
}

extension GetWirelessGatewayFirmwareInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGatewayCurrentVersion.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetWirelessGatewayInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let identifierType = identifierType {
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            items.append(identifierTypeQueryItem)
        }
        return items
    }
}

extension GetWirelessGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/wireless-gateways/\(identifier.urlPercentEncoding())"
    }
}

public struct GetWirelessGatewayInput: Swift.Equatable {
    /// The identifier of the wireless gateway to get.
    /// This member is required.
    public var identifier: Swift.String?
    /// The type of identifier used in identifier.
    /// This member is required.
    public var identifierType: IotWirelessClientTypes.WirelessGatewayIdType?

    public init (
        identifier: Swift.String? = nil,
        identifierType: IotWirelessClientTypes.WirelessGatewayIdType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
    }
}

struct GetWirelessGatewayInputBody: Swift.Equatable {
}

extension GetWirelessGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.thingArn = output.thingArn
            self.thingName = output.thingName
        } else {
            self.arn = nil
            self.description = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.thingArn = nil
            self.thingName = nil
        }
    }
}

public struct GetWirelessGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The ID of the wireless gateway.
    public var id: Swift.String?
    /// Information about the wireless gateway.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANGateway?
    /// The name of the resource.
    public var name: Swift.String?
    /// The ARN of the thing associated with the wireless gateway.
    public var thingArn: Swift.String?
    /// The name of the thing associated with the wireless gateway. The value is empty if a thing isn't associated with the gateway.
    public var thingName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANGateway? = nil,
        name: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

struct GetWirelessGatewayOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let id: Swift.String?
    let description: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANGateway?
    let arn: Swift.String?
    let thingName: Swift.String?
    let thingArn: Swift.String?
}

extension GetWirelessGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case thingArn = "ThingArn"
        case thingName = "ThingName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension GetWirelessGatewayStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let wirelessGatewayId = wirelessGatewayId else {
            return nil
        }
        return "/wireless-gateways/\(wirelessGatewayId.urlPercentEncoding())/statistics"
    }
}

public struct GetWirelessGatewayStatisticsInput: Swift.Equatable {
    /// The ID of the wireless gateway for which to get the data.
    /// This member is required.
    public var wirelessGatewayId: Swift.String?

    public init (
        wirelessGatewayId: Swift.String? = nil
    )
    {
        self.wirelessGatewayId = wirelessGatewayId
    }
}

struct GetWirelessGatewayStatisticsInputBody: Swift.Equatable {
}

extension GetWirelessGatewayStatisticsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayStatisticsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessGatewayStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionStatus = output.connectionStatus
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.wirelessGatewayId = output.wirelessGatewayId
        } else {
            self.connectionStatus = nil
            self.lastUplinkReceivedAt = nil
            self.wirelessGatewayId = nil
        }
    }
}

public struct GetWirelessGatewayStatisticsOutputResponse: Swift.Equatable {
    /// The connection status of the wireless gateway.
    public var connectionStatus: IotWirelessClientTypes.ConnectionStatus?
    /// The date and time when the most recent uplink was received.
    public var lastUplinkReceivedAt: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayId: Swift.String?

    public init (
        connectionStatus: IotWirelessClientTypes.ConnectionStatus? = nil,
        lastUplinkReceivedAt: Swift.String? = nil,
        wirelessGatewayId: Swift.String? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.wirelessGatewayId = wirelessGatewayId
    }
}

struct GetWirelessGatewayStatisticsOutputResponseBody: Swift.Equatable {
    let wirelessGatewayId: Swift.String?
    let lastUplinkReceivedAt: Swift.String?
    let connectionStatus: IotWirelessClientTypes.ConnectionStatus?
}

extension GetWirelessGatewayStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case wirelessGatewayId = "WirelessGatewayId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayId)
        wirelessGatewayId = wirelessGatewayIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.ConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
    }
}

extension GetWirelessGatewayTaskDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateway-task-definitions/\(id.urlPercentEncoding())"
    }
}

public struct GetWirelessGatewayTaskDefinitionInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayTaskDefinitionInputBody: Swift.Equatable {
}

extension GetWirelessGatewayTaskDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayTaskDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayTaskDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayTaskDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayTaskDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessGatewayTaskDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.autoCreateTasks = output.autoCreateTasks
            self.name = output.name
            self.update = output.update
        } else {
            self.arn = nil
            self.autoCreateTasks = false
            self.name = nil
            self.update = nil
        }
    }
}

public struct GetWirelessGatewayTaskDefinitionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// Whether to automatically create tasks using this task definition for all gateways with the specified current version. If false, the task must me created by calling CreateWirelessGatewayTask.
    public var autoCreateTasks: Swift.Bool
    /// The name of the resource.
    public var name: Swift.String?
    /// Information about the gateways to update.
    public var update: IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate?

    public init (
        arn: Swift.String? = nil,
        autoCreateTasks: Swift.Bool = false,
        name: Swift.String? = nil,
        update: IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate? = nil
    )
    {
        self.arn = arn
        self.autoCreateTasks = autoCreateTasks
        self.name = name
        self.update = update
    }
}

struct GetWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Equatable {
    let autoCreateTasks: Swift.Bool
    let name: Swift.String?
    let update: IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate?
    let arn: Swift.String?
}

extension GetWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case autoCreateTasks = "AutoCreateTasks"
        case name = "Name"
        case update = "Update"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoCreateTasksDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoCreateTasks)
        autoCreateTasks = autoCreateTasksDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updateDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate.self, forKey: .update)
        update = updateDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetWirelessGatewayTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
    }
}

public struct GetWirelessGatewayTaskInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayTaskInputBody: Swift.Equatable {
}

extension GetWirelessGatewayTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessGatewayTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.status = output.status
            self.taskCreatedAt = output.taskCreatedAt
            self.wirelessGatewayId = output.wirelessGatewayId
            self.wirelessGatewayTaskDefinitionId = output.wirelessGatewayTaskDefinitionId
        } else {
            self.lastUplinkReceivedAt = nil
            self.status = nil
            self.taskCreatedAt = nil
            self.wirelessGatewayId = nil
            self.wirelessGatewayTaskDefinitionId = nil
        }
    }
}

public struct GetWirelessGatewayTaskOutputResponse: Swift.Equatable {
    /// The date and time when the most recent uplink was received.
    public var lastUplinkReceivedAt: Swift.String?
    /// The status of the request.
    public var status: IotWirelessClientTypes.WirelessGatewayTaskStatus?
    /// The date and time when the task was created.
    public var taskCreatedAt: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayId: Swift.String?
    /// The ID of the WirelessGatewayTask.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init (
        lastUplinkReceivedAt: Swift.String? = nil,
        status: IotWirelessClientTypes.WirelessGatewayTaskStatus? = nil,
        taskCreatedAt: Swift.String? = nil,
        wirelessGatewayId: Swift.String? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.status = status
        self.taskCreatedAt = taskCreatedAt
        self.wirelessGatewayId = wirelessGatewayId
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct GetWirelessGatewayTaskOutputResponseBody: Swift.Equatable {
    let wirelessGatewayId: Swift.String?
    let wirelessGatewayTaskDefinitionId: Swift.String?
    let lastUplinkReceivedAt: Swift.String?
    let taskCreatedAt: Swift.String?
    let status: IotWirelessClientTypes.WirelessGatewayTaskStatus?
}

extension GetWirelessGatewayTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case status = "Status"
        case taskCreatedAt = "TaskCreatedAt"
        case wirelessGatewayId = "WirelessGatewayId"
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayId)
        wirelessGatewayId = wirelessGatewayIdDecoded
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let taskCreatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskCreatedAt)
        taskCreatedAt = taskCreatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessGatewayTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IotWirelessClientTypes {
    public enum IdentifierType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case partneraccountid
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentifierType] {
            return [
                .partneraccountid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .partneraccountid: return "PartnerAccountId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentifierType(rawValue: rawValue) ?? IdentifierType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred while processing a request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDestinationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/destinations"
    }
}

public struct ListDestinationsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDestinationsInputBody: Swift.Equatable {
}

extension ListDestinationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDestinationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDestinationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDestinationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDestinationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationList = output.destinationList
            self.nextToken = output.nextToken
        } else {
            self.destinationList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDestinationsOutputResponse: Swift.Equatable {
    /// The list of destinations.
    public var destinationList: [IotWirelessClientTypes.Destinations]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        destinationList: [IotWirelessClientTypes.Destinations]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationList = destinationList
        self.nextToken = nextToken
    }
}

struct ListDestinationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let destinationList: [IotWirelessClientTypes.Destinations]?
}

extension ListDestinationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationList = "DestinationList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let destinationListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Destinations?].self, forKey: .destinationList)
        var destinationListDecoded0:[IotWirelessClientTypes.Destinations]? = nil
        if let destinationListContainer = destinationListContainer {
            destinationListDecoded0 = [IotWirelessClientTypes.Destinations]()
            for structure0 in destinationListContainer {
                if let structure0 = structure0 {
                    destinationListDecoded0?.append(structure0)
                }
            }
        }
        destinationList = destinationListDecoded0
    }
}

extension ListDeviceProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeviceProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/device-profiles"
    }
}

public struct ListDeviceProfilesInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceProfilesInputBody: Swift.Equatable {
}

extension ListDeviceProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeviceProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeviceProfilesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeviceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceProfileList = output.deviceProfileList
            self.nextToken = output.nextToken
        } else {
            self.deviceProfileList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceProfilesOutputResponse: Swift.Equatable {
    /// The list of device profiles.
    public var deviceProfileList: [IotWirelessClientTypes.DeviceProfile]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        deviceProfileList: [IotWirelessClientTypes.DeviceProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceProfileList = deviceProfileList
        self.nextToken = nextToken
    }
}

struct ListDeviceProfilesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let deviceProfileList: [IotWirelessClientTypes.DeviceProfile]?
}

extension ListDeviceProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceProfileList = "DeviceProfileList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let deviceProfileListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.DeviceProfile?].self, forKey: .deviceProfileList)
        var deviceProfileListDecoded0:[IotWirelessClientTypes.DeviceProfile]? = nil
        if let deviceProfileListContainer = deviceProfileListContainer {
            deviceProfileListDecoded0 = [IotWirelessClientTypes.DeviceProfile]()
            for structure0 in deviceProfileListContainer {
                if let structure0 = structure0 {
                    deviceProfileListDecoded0?.append(structure0)
                }
            }
        }
        deviceProfileList = deviceProfileListDecoded0
    }
}

extension ListFuotaTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFuotaTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/fuota-tasks"
    }
}

public struct ListFuotaTasksInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFuotaTasksInputBody: Swift.Equatable {
}

extension ListFuotaTasksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFuotaTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFuotaTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFuotaTasksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFuotaTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFuotaTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fuotaTaskList = output.fuotaTaskList
            self.nextToken = output.nextToken
        } else {
            self.fuotaTaskList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFuotaTasksOutputResponse: Swift.Equatable {
    /// Lists the FUOTA tasks registered to your AWS account.
    public var fuotaTaskList: [IotWirelessClientTypes.FuotaTask]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        fuotaTaskList: [IotWirelessClientTypes.FuotaTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fuotaTaskList = fuotaTaskList
        self.nextToken = nextToken
    }
}

struct ListFuotaTasksOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let fuotaTaskList: [IotWirelessClientTypes.FuotaTask]?
}

extension ListFuotaTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fuotaTaskList = "FuotaTaskList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let fuotaTaskListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.FuotaTask?].self, forKey: .fuotaTaskList)
        var fuotaTaskListDecoded0:[IotWirelessClientTypes.FuotaTask]? = nil
        if let fuotaTaskListContainer = fuotaTaskListContainer {
            fuotaTaskListDecoded0 = [IotWirelessClientTypes.FuotaTask]()
            for structure0 in fuotaTaskListContainer {
                if let structure0 = structure0 {
                    fuotaTaskListDecoded0?.append(structure0)
                }
            }
        }
        fuotaTaskList = fuotaTaskListDecoded0
    }
}

extension ListMulticastGroupsByFuotaTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMulticastGroupsByFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())/multicast-groups"
    }
}

public struct ListMulticastGroupsByFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        id: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMulticastGroupsByFuotaTaskInputBody: Swift.Equatable {
}

extension ListMulticastGroupsByFuotaTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMulticastGroupsByFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMulticastGroupsByFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMulticastGroupsByFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMulticastGroupsByFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMulticastGroupsByFuotaTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.multicastGroupList = output.multicastGroupList
            self.nextToken = output.nextToken
        } else {
            self.multicastGroupList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMulticastGroupsByFuotaTaskOutputResponse: Swift.Equatable {
    /// List of multicast groups associated with a FUOTA task.
    public var multicastGroupList: [IotWirelessClientTypes.MulticastGroupByFuotaTask]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        multicastGroupList: [IotWirelessClientTypes.MulticastGroupByFuotaTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.multicastGroupList = multicastGroupList
        self.nextToken = nextToken
    }
}

struct ListMulticastGroupsByFuotaTaskOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let multicastGroupList: [IotWirelessClientTypes.MulticastGroupByFuotaTask]?
}

extension ListMulticastGroupsByFuotaTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastGroupList = "MulticastGroupList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let multicastGroupListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.MulticastGroupByFuotaTask?].self, forKey: .multicastGroupList)
        var multicastGroupListDecoded0:[IotWirelessClientTypes.MulticastGroupByFuotaTask]? = nil
        if let multicastGroupListContainer = multicastGroupListContainer {
            multicastGroupListDecoded0 = [IotWirelessClientTypes.MulticastGroupByFuotaTask]()
            for structure0 in multicastGroupListContainer {
                if let structure0 = structure0 {
                    multicastGroupListDecoded0?.append(structure0)
                }
            }
        }
        multicastGroupList = multicastGroupListDecoded0
    }
}

extension ListMulticastGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMulticastGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/multicast-groups"
    }
}

public struct ListMulticastGroupsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMulticastGroupsInputBody: Swift.Equatable {
}

extension ListMulticastGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMulticastGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMulticastGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMulticastGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMulticastGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMulticastGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.multicastGroupList = output.multicastGroupList
            self.nextToken = output.nextToken
        } else {
            self.multicastGroupList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMulticastGroupsOutputResponse: Swift.Equatable {
    /// List of multicast groups.
    public var multicastGroupList: [IotWirelessClientTypes.MulticastGroup]?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        multicastGroupList: [IotWirelessClientTypes.MulticastGroup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.multicastGroupList = multicastGroupList
        self.nextToken = nextToken
    }
}

struct ListMulticastGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let multicastGroupList: [IotWirelessClientTypes.MulticastGroup]?
}

extension ListMulticastGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multicastGroupList = "MulticastGroupList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let multicastGroupListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.MulticastGroup?].self, forKey: .multicastGroupList)
        var multicastGroupListDecoded0:[IotWirelessClientTypes.MulticastGroup]? = nil
        if let multicastGroupListContainer = multicastGroupListContainer {
            multicastGroupListDecoded0 = [IotWirelessClientTypes.MulticastGroup]()
            for structure0 in multicastGroupListContainer {
                if let structure0 = structure0 {
                    multicastGroupListDecoded0?.append(structure0)
                }
            }
        }
        multicastGroupList = multicastGroupListDecoded0
    }
}

extension ListPartnerAccountsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPartnerAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/partner-accounts"
    }
}

public struct ListPartnerAccountsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPartnerAccountsInputBody: Swift.Equatable {
}

extension ListPartnerAccountsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPartnerAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartnerAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPartnerAccountsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartnerAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPartnerAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sidewalk = output.sidewalk
        } else {
            self.nextToken = nil
            self.sidewalk = nil
        }
    }
}

public struct ListPartnerAccountsOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The Sidewalk account credentials.
    public var sidewalk: [IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint]?

    public init (
        nextToken: Swift.String? = nil,
        sidewalk: [IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint]? = nil
    )
    {
        self.nextToken = nextToken
        self.sidewalk = sidewalk
    }
}

struct ListPartnerAccountsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sidewalk: [IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint]?
}

extension ListPartnerAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sidewalkContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint?].self, forKey: .sidewalk)
        var sidewalkDecoded0:[IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint]? = nil
        if let sidewalkContainer = sidewalkContainer {
            sidewalkDecoded0 = [IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint]()
            for structure0 in sidewalkContainer {
                if let structure0 = structure0 {
                    sidewalkDecoded0?.append(structure0)
                }
            }
        }
        sidewalk = sidewalkDecoded0
    }
}

extension ListServiceProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListServiceProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-profiles"
    }
}

public struct ListServiceProfilesInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServiceProfilesInputBody: Swift.Equatable {
}

extension ListServiceProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListServiceProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceProfilesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServiceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceProfileList = output.serviceProfileList
        } else {
            self.nextToken = nil
            self.serviceProfileList = nil
        }
    }
}

public struct ListServiceProfilesOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of service profiles.
    public var serviceProfileList: [IotWirelessClientTypes.ServiceProfile]?

    public init (
        nextToken: Swift.String? = nil,
        serviceProfileList: [IotWirelessClientTypes.ServiceProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceProfileList = serviceProfileList
    }
}

struct ListServiceProfilesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serviceProfileList: [IotWirelessClientTypes.ServiceProfile]?
}

extension ListServiceProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceProfileList = "ServiceProfileList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serviceProfileListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.ServiceProfile?].self, forKey: .serviceProfileList)
        var serviceProfileListDecoded0:[IotWirelessClientTypes.ServiceProfile]? = nil
        if let serviceProfileListContainer = serviceProfileListContainer {
            serviceProfileListDecoded0 = [IotWirelessClientTypes.ServiceProfile]()
            for structure0 in serviceProfileListContainer {
                if let structure0 = structure0 {
                    serviceProfileListDecoded0?.append(structure0)
                }
            }
        }
        serviceProfileList = serviceProfileListDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceArn = resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource for which you want to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [IotWirelessClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWirelessDevicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let fuotaTaskId = fuotaTaskId {
            let fuotaTaskIdQueryItem = ClientRuntime.URLQueryItem(name: "fuotaTaskId".urlPercentEncoding(), value: Swift.String(fuotaTaskId).urlPercentEncoding())
            items.append(fuotaTaskIdQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let deviceProfileId = deviceProfileId {
            let deviceProfileIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceProfileId".urlPercentEncoding(), value: Swift.String(deviceProfileId).urlPercentEncoding())
            items.append(deviceProfileIdQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let multicastGroupId = multicastGroupId {
            let multicastGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "multicastGroupId".urlPercentEncoding(), value: Swift.String(multicastGroupId).urlPercentEncoding())
            items.append(multicastGroupIdQueryItem)
        }
        if let destinationName = destinationName {
            let destinationNameQueryItem = ClientRuntime.URLQueryItem(name: "destinationName".urlPercentEncoding(), value: Swift.String(destinationName).urlPercentEncoding())
            items.append(destinationNameQueryItem)
        }
        if let wirelessDeviceType = wirelessDeviceType {
            let wirelessDeviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "wirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
            items.append(wirelessDeviceTypeQueryItem)
        }
        if let serviceProfileId = serviceProfileId {
            let serviceProfileIdQueryItem = ClientRuntime.URLQueryItem(name: "serviceProfileId".urlPercentEncoding(), value: Swift.String(serviceProfileId).urlPercentEncoding())
            items.append(serviceProfileIdQueryItem)
        }
        return items
    }
}

extension ListWirelessDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-devices"
    }
}

public struct ListWirelessDevicesInput: Swift.Equatable {
    /// A filter to list only the wireless devices that use this destination.
    public var destinationName: Swift.String?
    /// A filter to list only the wireless devices that use this device profile.
    public var deviceProfileId: Swift.String?
    /// The ID of a FUOTA task.
    public var fuotaTaskId: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// The ID of the multicast group.
    public var multicastGroupId: Swift.String?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// A filter to list only the wireless devices that use this service profile.
    public var serviceProfileId: Swift.String?
    /// A filter to list only the wireless devices that use this wireless device type.
    public var wirelessDeviceType: IotWirelessClientTypes.WirelessDeviceType?

    public init (
        destinationName: Swift.String? = nil,
        deviceProfileId: Swift.String? = nil,
        fuotaTaskId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        multicastGroupId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceProfileId: Swift.String? = nil,
        wirelessDeviceType: IotWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.destinationName = destinationName
        self.deviceProfileId = deviceProfileId
        self.fuotaTaskId = fuotaTaskId
        self.maxResults = maxResults
        self.multicastGroupId = multicastGroupId
        self.nextToken = nextToken
        self.serviceProfileId = serviceProfileId
        self.wirelessDeviceType = wirelessDeviceType
    }
}

struct ListWirelessDevicesInputBody: Swift.Equatable {
}

extension ListWirelessDevicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWirelessDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWirelessDevicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWirelessDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWirelessDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.wirelessDeviceList = output.wirelessDeviceList
        } else {
            self.nextToken = nil
            self.wirelessDeviceList = nil
        }
    }
}

public struct ListWirelessDevicesOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the wireless device.
    public var wirelessDeviceList: [IotWirelessClientTypes.WirelessDeviceStatistics]?

    public init (
        nextToken: Swift.String? = nil,
        wirelessDeviceList: [IotWirelessClientTypes.WirelessDeviceStatistics]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessDeviceList = wirelessDeviceList
    }
}

struct ListWirelessDevicesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let wirelessDeviceList: [IotWirelessClientTypes.WirelessDeviceStatistics]?
}

extension ListWirelessDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case wirelessDeviceList = "WirelessDeviceList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let wirelessDeviceListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessDeviceStatistics?].self, forKey: .wirelessDeviceList)
        var wirelessDeviceListDecoded0:[IotWirelessClientTypes.WirelessDeviceStatistics]? = nil
        if let wirelessDeviceListContainer = wirelessDeviceListContainer {
            wirelessDeviceListDecoded0 = [IotWirelessClientTypes.WirelessDeviceStatistics]()
            for structure0 in wirelessDeviceListContainer {
                if let structure0 = structure0 {
                    wirelessDeviceListDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceList = wirelessDeviceListDecoded0
    }
}

extension ListWirelessGatewayTaskDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let taskDefinitionType = taskDefinitionType {
            let taskDefinitionTypeQueryItem = ClientRuntime.URLQueryItem(name: "taskDefinitionType".urlPercentEncoding(), value: Swift.String(taskDefinitionType.rawValue).urlPercentEncoding())
            items.append(taskDefinitionTypeQueryItem)
        }
        return items
    }
}

extension ListWirelessGatewayTaskDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-gateway-task-definitions"
    }
}

public struct ListWirelessGatewayTaskDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// A filter to list only the wireless gateway task definitions that use this task definition type.
    public var taskDefinitionType: IotWirelessClientTypes.WirelessGatewayTaskDefinitionType?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        taskDefinitionType: IotWirelessClientTypes.WirelessGatewayTaskDefinitionType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskDefinitionType = taskDefinitionType
    }
}

struct ListWirelessGatewayTaskDefinitionsInputBody: Swift.Equatable {
}

extension ListWirelessGatewayTaskDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessGatewayTaskDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWirelessGatewayTaskDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWirelessGatewayTaskDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWirelessGatewayTaskDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWirelessGatewayTaskDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.taskDefinitions = output.taskDefinitions
        } else {
            self.nextToken = nil
            self.taskDefinitions = nil
        }
    }
}

public struct ListWirelessGatewayTaskDefinitionsOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of task definitions.
    public var taskDefinitions: [IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry]?

    public init (
        nextToken: Swift.String? = nil,
        taskDefinitions: [IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskDefinitions = taskDefinitions
    }
}

struct ListWirelessGatewayTaskDefinitionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let taskDefinitions: [IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry]?
}

extension ListWirelessGatewayTaskDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case taskDefinitions = "TaskDefinitions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let taskDefinitionsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry?].self, forKey: .taskDefinitions)
        var taskDefinitionsDecoded0:[IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry]? = nil
        if let taskDefinitionsContainer = taskDefinitionsContainer {
            taskDefinitionsDecoded0 = [IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry]()
            for structure0 in taskDefinitionsContainer {
                if let structure0 = structure0 {
                    taskDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        taskDefinitions = taskDefinitionsDecoded0
    }
}

extension ListWirelessGatewaysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListWirelessGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/wireless-gateways"
    }
}

public struct ListWirelessGatewaysInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWirelessGatewaysInputBody: Swift.Equatable {
}

extension ListWirelessGatewaysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessGatewaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWirelessGatewaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWirelessGatewaysOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWirelessGatewaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWirelessGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.wirelessGatewayList = output.wirelessGatewayList
        } else {
            self.nextToken = nil
            self.wirelessGatewayList = nil
        }
    }
}

public struct ListWirelessGatewaysOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayList: [IotWirelessClientTypes.WirelessGatewayStatistics]?

    public init (
        nextToken: Swift.String? = nil,
        wirelessGatewayList: [IotWirelessClientTypes.WirelessGatewayStatistics]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessGatewayList = wirelessGatewayList
    }
}

struct ListWirelessGatewaysOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let wirelessGatewayList: [IotWirelessClientTypes.WirelessGatewayStatistics]?
}

extension ListWirelessGatewaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case wirelessGatewayList = "WirelessGatewayList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let wirelessGatewayListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessGatewayStatistics?].self, forKey: .wirelessGatewayList)
        var wirelessGatewayListDecoded0:[IotWirelessClientTypes.WirelessGatewayStatistics]? = nil
        if let wirelessGatewayListContainer = wirelessGatewayListContainer {
            wirelessGatewayListDecoded0 = [IotWirelessClientTypes.WirelessGatewayStatistics]()
            for structure0 in wirelessGatewayListContainer {
                if let structure0 = structure0 {
                    wirelessGatewayListDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayList = wirelessGatewayListDecoded0
    }
}

extension IotWirelessClientTypes.LoRaWANDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abpV1_0_x = "AbpV1_0_x"
        case abpV1_1 = "AbpV1_1"
        case devEui = "DevEui"
        case deviceProfileId = "DeviceProfileId"
        case fPorts = "FPorts"
        case otaaV1_0_x = "OtaaV1_0_x"
        case otaaV1_1 = "OtaaV1_1"
        case serviceProfileId = "ServiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abpV1_0_x = abpV1_0_x {
            try encodeContainer.encode(abpV1_0_x, forKey: .abpV1_0_x)
        }
        if let abpV1_1 = abpV1_1 {
            try encodeContainer.encode(abpV1_1, forKey: .abpV1_1)
        }
        if let devEui = devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
        if let deviceProfileId = deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
        if let fPorts = fPorts {
            try encodeContainer.encode(fPorts, forKey: .fPorts)
        }
        if let otaaV1_0_x = otaaV1_0_x {
            try encodeContainer.encode(otaaV1_0_x, forKey: .otaaV1_0_x)
        }
        if let otaaV1_1 = otaaV1_1 {
            try encodeContainer.encode(otaaV1_1, forKey: .otaaV1_1)
        }
        if let serviceProfileId = serviceProfileId {
            try encodeContainer.encode(serviceProfileId, forKey: .serviceProfileId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEui)
        devEui = devEuiDecoded
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
        let serviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProfileId)
        serviceProfileId = serviceProfileIdDecoded
        let otaaV1_1Decoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.OtaaV1_1.self, forKey: .otaaV1_1)
        otaaV1_1 = otaaV1_1Decoded
        let otaaV1_0_xDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.OtaaV1_0_x.self, forKey: .otaaV1_0_x)
        otaaV1_0_x = otaaV1_0_xDecoded
        let abpV1_1Decoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.AbpV1_1.self, forKey: .abpV1_1)
        abpV1_1 = abpV1_1Decoded
        let abpV1_0_xDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.AbpV1_0_x.self, forKey: .abpV1_0_x)
        abpV1_0_x = abpV1_0_xDecoded
        let fPortsDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.FPorts.self, forKey: .fPorts)
        fPorts = fPortsDecoded
    }
}

extension IotWirelessClientTypes {
    /// LoRaWAN object for create functions.
    public struct LoRaWANDevice: Swift.Equatable {
        /// LoRaWAN object for create APIs
        public var abpV1_0_x: IotWirelessClientTypes.AbpV1_0_x?
        /// ABP device object for create APIs for v1.1
        public var abpV1_1: IotWirelessClientTypes.AbpV1_1?
        /// The DevEUI value.
        public var devEui: Swift.String?
        /// The ID of the device profile for the new wireless device.
        public var deviceProfileId: Swift.String?
        /// List of FPort assigned for different LoRaWAN application packages to use
        public var fPorts: IotWirelessClientTypes.FPorts?
        /// OTAA device object for create APIs for v1.0.x
        public var otaaV1_0_x: IotWirelessClientTypes.OtaaV1_0_x?
        /// OTAA device object for v1.1 for create APIs
        public var otaaV1_1: IotWirelessClientTypes.OtaaV1_1?
        /// The ID of the service profile.
        public var serviceProfileId: Swift.String?

        public init (
            abpV1_0_x: IotWirelessClientTypes.AbpV1_0_x? = nil,
            abpV1_1: IotWirelessClientTypes.AbpV1_1? = nil,
            devEui: Swift.String? = nil,
            deviceProfileId: Swift.String? = nil,
            fPorts: IotWirelessClientTypes.FPorts? = nil,
            otaaV1_0_x: IotWirelessClientTypes.OtaaV1_0_x? = nil,
            otaaV1_1: IotWirelessClientTypes.OtaaV1_1? = nil,
            serviceProfileId: Swift.String? = nil
        )
        {
            self.abpV1_0_x = abpV1_0_x
            self.abpV1_1 = abpV1_1
            self.devEui = devEui
            self.deviceProfileId = deviceProfileId
            self.fPorts = fPorts
            self.otaaV1_0_x = otaaV1_0_x
            self.otaaV1_1 = otaaV1_1
            self.serviceProfileId = serviceProfileId
        }
    }

}

extension IotWirelessClientTypes.LoRaWANDeviceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRate = "DataRate"
        case devEui = "DevEui"
        case fPort = "FPort"
        case frequency = "Frequency"
        case gateways = "Gateways"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRate = dataRate {
            try encodeContainer.encode(dataRate, forKey: .dataRate)
        }
        if let devEui = devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
        if let fPort = fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let gateways = gateways {
            var gatewaysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gateways)
            for lorawangatewaymetadatalist0 in gateways {
                try gatewaysContainer.encode(lorawangatewaymetadatalist0)
            }
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEui)
        devEui = devEuiDecoded
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
        let dataRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRate)
        dataRate = dataRateDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let gatewaysContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.LoRaWANGatewayMetadata?].self, forKey: .gateways)
        var gatewaysDecoded0:[IotWirelessClientTypes.LoRaWANGatewayMetadata]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [IotWirelessClientTypes.LoRaWANGatewayMetadata]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
    }
}

extension IotWirelessClientTypes {
    /// LoRaWAN device metatdata.
    public struct LoRaWANDeviceMetadata: Swift.Equatable {
        /// The DataRate value.
        public var dataRate: Swift.Int?
        /// The DevEUI value.
        public var devEui: Swift.String?
        /// The FPort value.
        public var fPort: Swift.Int?
        /// The device's channel frequency in Hz.
        public var frequency: Swift.Int?
        /// Information about the gateways accessed by the device.
        public var gateways: [IotWirelessClientTypes.LoRaWANGatewayMetadata]?
        /// The date and time of the metadata.
        public var timestamp: Swift.String?

        public init (
            dataRate: Swift.Int? = nil,
            devEui: Swift.String? = nil,
            fPort: Swift.Int? = nil,
            frequency: Swift.Int? = nil,
            gateways: [IotWirelessClientTypes.LoRaWANGatewayMetadata]? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.dataRate = dataRate
            self.devEui = devEui
            self.fPort = fPort
            self.frequency = frequency
            self.gateways = gateways
            self.timestamp = timestamp
        }
    }

}

extension IotWirelessClientTypes.LoRaWANDeviceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classBTimeout = "ClassBTimeout"
        case classCTimeout = "ClassCTimeout"
        case factoryPresetFreqsList = "FactoryPresetFreqsList"
        case macVersion = "MacVersion"
        case maxDutyCycle = "MaxDutyCycle"
        case maxEirp = "MaxEirp"
        case pingSlotDr = "PingSlotDr"
        case pingSlotFreq = "PingSlotFreq"
        case pingSlotPeriod = "PingSlotPeriod"
        case regParamsRevision = "RegParamsRevision"
        case rfRegion = "RfRegion"
        case rxDataRate2 = "RxDataRate2"
        case rxDelay1 = "RxDelay1"
        case rxDrOffset1 = "RxDrOffset1"
        case rxFreq2 = "RxFreq2"
        case supports32BitFCnt = "Supports32BitFCnt"
        case supportsClassB = "SupportsClassB"
        case supportsClassC = "SupportsClassC"
        case supportsJoin = "SupportsJoin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classBTimeout = classBTimeout {
            try encodeContainer.encode(classBTimeout, forKey: .classBTimeout)
        }
        if let classCTimeout = classCTimeout {
            try encodeContainer.encode(classCTimeout, forKey: .classCTimeout)
        }
        if let factoryPresetFreqsList = factoryPresetFreqsList {
            var factoryPresetFreqsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .factoryPresetFreqsList)
            for factorypresetfreqslist0 in factoryPresetFreqsList {
                try factoryPresetFreqsListContainer.encode(factorypresetfreqslist0)
            }
        }
        if let macVersion = macVersion {
            try encodeContainer.encode(macVersion, forKey: .macVersion)
        }
        if let maxDutyCycle = maxDutyCycle {
            try encodeContainer.encode(maxDutyCycle, forKey: .maxDutyCycle)
        }
        if let maxEirp = maxEirp {
            try encodeContainer.encode(maxEirp, forKey: .maxEirp)
        }
        if let pingSlotDr = pingSlotDr {
            try encodeContainer.encode(pingSlotDr, forKey: .pingSlotDr)
        }
        if let pingSlotFreq = pingSlotFreq {
            try encodeContainer.encode(pingSlotFreq, forKey: .pingSlotFreq)
        }
        if let pingSlotPeriod = pingSlotPeriod {
            try encodeContainer.encode(pingSlotPeriod, forKey: .pingSlotPeriod)
        }
        if let regParamsRevision = regParamsRevision {
            try encodeContainer.encode(regParamsRevision, forKey: .regParamsRevision)
        }
        if let rfRegion = rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let rxDataRate2 = rxDataRate2 {
            try encodeContainer.encode(rxDataRate2, forKey: .rxDataRate2)
        }
        if let rxDelay1 = rxDelay1 {
            try encodeContainer.encode(rxDelay1, forKey: .rxDelay1)
        }
        if let rxDrOffset1 = rxDrOffset1 {
            try encodeContainer.encode(rxDrOffset1, forKey: .rxDrOffset1)
        }
        if let rxFreq2 = rxFreq2 {
            try encodeContainer.encode(rxFreq2, forKey: .rxFreq2)
        }
        if supports32BitFCnt != false {
            try encodeContainer.encode(supports32BitFCnt, forKey: .supports32BitFCnt)
        }
        if supportsClassB != false {
            try encodeContainer.encode(supportsClassB, forKey: .supportsClassB)
        }
        if supportsClassC != false {
            try encodeContainer.encode(supportsClassC, forKey: .supportsClassC)
        }
        if let supportsJoin = supportsJoin {
            try encodeContainer.encode(supportsJoin, forKey: .supportsJoin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportsClassBDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsClassB)
        supportsClassB = supportsClassBDecoded
        let classBTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classBTimeout)
        classBTimeout = classBTimeoutDecoded
        let pingSlotPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotPeriod)
        pingSlotPeriod = pingSlotPeriodDecoded
        let pingSlotDrDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotDr)
        pingSlotDr = pingSlotDrDecoded
        let pingSlotFreqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotFreq)
        pingSlotFreq = pingSlotFreqDecoded
        let supportsClassCDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsClassC)
        supportsClassC = supportsClassCDecoded
        let classCTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classCTimeout)
        classCTimeout = classCTimeoutDecoded
        let macVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macVersion)
        macVersion = macVersionDecoded
        let regParamsRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regParamsRevision)
        regParamsRevision = regParamsRevisionDecoded
        let rxDelay1Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxDelay1)
        rxDelay1 = rxDelay1Decoded
        let rxDrOffset1Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxDrOffset1)
        rxDrOffset1 = rxDrOffset1Decoded
        let rxDataRate2Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxDataRate2)
        rxDataRate2 = rxDataRate2Decoded
        let rxFreq2Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxFreq2)
        rxFreq2 = rxFreq2Decoded
        let factoryPresetFreqsListContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .factoryPresetFreqsList)
        var factoryPresetFreqsListDecoded0:[Swift.Int]? = nil
        if let factoryPresetFreqsListContainer = factoryPresetFreqsListContainer {
            factoryPresetFreqsListDecoded0 = [Swift.Int]()
            for integer0 in factoryPresetFreqsListContainer {
                if let integer0 = integer0 {
                    factoryPresetFreqsListDecoded0?.append(integer0)
                }
            }
        }
        factoryPresetFreqsList = factoryPresetFreqsListDecoded0
        let maxEirpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxEirp)
        maxEirp = maxEirpDecoded
        let maxDutyCycleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDutyCycle)
        maxDutyCycle = maxDutyCycleDecoded
        let rfRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let supportsJoinDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsJoin)
        supportsJoin = supportsJoinDecoded
        let supports32BitFCntDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supports32BitFCnt)
        supports32BitFCnt = supports32BitFCntDecoded
    }
}

extension IotWirelessClientTypes {
    /// LoRaWANDeviceProfile object.
    public struct LoRaWANDeviceProfile: Swift.Equatable {
        /// The ClassBTimeout value.
        public var classBTimeout: Swift.Int?
        /// The ClassCTimeout value.
        public var classCTimeout: Swift.Int?
        /// The list of values that make up the FactoryPresetFreqs value.
        public var factoryPresetFreqsList: [Swift.Int]?
        /// The MAC version (such as OTAA 1.1 or OTAA 1.0.3) to use with this device profile.
        public var macVersion: Swift.String?
        /// The MaxDutyCycle value.
        public var maxDutyCycle: Swift.Int?
        /// The MaxEIRP value.
        public var maxEirp: Swift.Int?
        /// The PingSlotDR value.
        public var pingSlotDr: Swift.Int?
        /// The PingSlotFreq value.
        public var pingSlotFreq: Swift.Int?
        /// The PingSlotPeriod value.
        public var pingSlotPeriod: Swift.Int?
        /// The version of regional parameters.
        public var regParamsRevision: Swift.String?
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// The RXDataRate2 value.
        public var rxDataRate2: Swift.Int?
        /// The RXDelay1 value.
        public var rxDelay1: Swift.Int?
        /// The RXDROffset1 value.
        public var rxDrOffset1: Swift.Int?
        /// The RXFreq2 value.
        public var rxFreq2: Swift.Int?
        /// The Supports32BitFCnt value.
        public var supports32BitFCnt: Swift.Bool
        /// The SupportsClassB value.
        public var supportsClassB: Swift.Bool
        /// The SupportsClassC value.
        public var supportsClassC: Swift.Bool
        /// The SupportsJoin value.
        public var supportsJoin: Swift.Bool?

        public init (
            classBTimeout: Swift.Int? = nil,
            classCTimeout: Swift.Int? = nil,
            factoryPresetFreqsList: [Swift.Int]? = nil,
            macVersion: Swift.String? = nil,
            maxDutyCycle: Swift.Int? = nil,
            maxEirp: Swift.Int? = nil,
            pingSlotDr: Swift.Int? = nil,
            pingSlotFreq: Swift.Int? = nil,
            pingSlotPeriod: Swift.Int? = nil,
            regParamsRevision: Swift.String? = nil,
            rfRegion: Swift.String? = nil,
            rxDataRate2: Swift.Int? = nil,
            rxDelay1: Swift.Int? = nil,
            rxDrOffset1: Swift.Int? = nil,
            rxFreq2: Swift.Int? = nil,
            supports32BitFCnt: Swift.Bool = false,
            supportsClassB: Swift.Bool = false,
            supportsClassC: Swift.Bool = false,
            supportsJoin: Swift.Bool? = nil
        )
        {
            self.classBTimeout = classBTimeout
            self.classCTimeout = classCTimeout
            self.factoryPresetFreqsList = factoryPresetFreqsList
            self.macVersion = macVersion
            self.maxDutyCycle = maxDutyCycle
            self.maxEirp = maxEirp
            self.pingSlotDr = pingSlotDr
            self.pingSlotFreq = pingSlotFreq
            self.pingSlotPeriod = pingSlotPeriod
            self.regParamsRevision = regParamsRevision
            self.rfRegion = rfRegion
            self.rxDataRate2 = rxDataRate2
            self.rxDelay1 = rxDelay1
            self.rxDrOffset1 = rxDrOffset1
            self.rxFreq2 = rxFreq2
            self.supports32BitFCnt = supports32BitFCnt
            self.supportsClassB = supportsClassB
            self.supportsClassC = supportsClassC
            self.supportsJoin = supportsJoin
        }
    }

}

extension IotWirelessClientTypes.LoRaWANFuotaTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rfRegion = "RfRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rfRegion = rfRegion {
            try encodeContainer.encode(rfRegion.rawValue, forKey: .rfRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rfRegionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SupportedRfRegion.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
    }
}

extension IotWirelessClientTypes {
    /// The LoRaWAN information used with a FUOTA task.
    public struct LoRaWANFuotaTask: Swift.Equatable {
        /// Supported RfRegions
        public var rfRegion: IotWirelessClientTypes.SupportedRfRegion?

        public init (
            rfRegion: IotWirelessClientTypes.SupportedRfRegion? = nil
        )
        {
            self.rfRegion = rfRegion
        }
    }

}

extension IotWirelessClientTypes.LoRaWANFuotaTaskGetInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rfRegion = "RfRegion"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rfRegion = rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rfRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension IotWirelessClientTypes {
    /// The LoRaWAN information returned from getting a FUOTA task.
    public struct LoRaWANFuotaTaskGetInfo: Swift.Equatable {
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// Start time of a FUOTA task.
        public var startTime: ClientRuntime.Date?

        public init (
            rfRegion: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.rfRegion = rfRegion
            self.startTime = startTime
        }
    }

}

extension IotWirelessClientTypes.LoRaWANGateway: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayEui = "GatewayEui"
        case joinEuiFilters = "JoinEuiFilters"
        case netIdFilters = "NetIdFilters"
        case rfRegion = "RfRegion"
        case subBands = "SubBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayEui = gatewayEui {
            try encodeContainer.encode(gatewayEui, forKey: .gatewayEui)
        }
        if let joinEuiFilters = joinEuiFilters {
            var joinEuiFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .joinEuiFilters)
            for joineuifilters0 in joinEuiFilters {
                var joineuifilters0Container = joinEuiFiltersContainer.nestedUnkeyedContainer()
                for joineuirange1 in joineuifilters0 {
                    try joineuifilters0Container.encode(joineuirange1)
                }
            }
        }
        if let netIdFilters = netIdFilters {
            var netIdFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .netIdFilters)
            for netidfilters0 in netIdFilters {
                try netIdFiltersContainer.encode(netidfilters0)
            }
        }
        if let rfRegion = rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let subBands = subBands {
            var subBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subBands)
            for subbands0 in subBands {
                try subBandsContainer.encode(subbands0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayEui)
        gatewayEui = gatewayEuiDecoded
        let rfRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let joinEuiFiltersContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .joinEuiFilters)
        var joinEuiFiltersDecoded0:[[Swift.String]]? = nil
        if let joinEuiFiltersContainer = joinEuiFiltersContainer {
            joinEuiFiltersDecoded0 = [[Swift.String]]()
            for list0 in joinEuiFiltersContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    joinEuiFiltersDecoded0?.append(list0Decoded0)
                }
            }
        }
        joinEuiFilters = joinEuiFiltersDecoded0
        let netIdFiltersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .netIdFilters)
        var netIdFiltersDecoded0:[Swift.String]? = nil
        if let netIdFiltersContainer = netIdFiltersContainer {
            netIdFiltersDecoded0 = [Swift.String]()
            for string0 in netIdFiltersContainer {
                if let string0 = string0 {
                    netIdFiltersDecoded0?.append(string0)
                }
            }
        }
        netIdFilters = netIdFiltersDecoded0
        let subBandsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .subBands)
        var subBandsDecoded0:[Swift.Int]? = nil
        if let subBandsContainer = subBandsContainer {
            subBandsDecoded0 = [Swift.Int]()
            for integer0 in subBandsContainer {
                if let integer0 = integer0 {
                    subBandsDecoded0?.append(integer0)
                }
            }
        }
        subBands = subBandsDecoded0
    }
}

extension IotWirelessClientTypes {
    /// LoRaWANGateway object.
    public struct LoRaWANGateway: Swift.Equatable {
        /// The gateway's EUI value.
        public var gatewayEui: Swift.String?
        /// A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.
        public var joinEuiFilters: [[Swift.String]]?
        /// A list of NetId values that are used by LoRa gateways to filter the uplink frames.
        public var netIdFilters: [Swift.String]?
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// A list of integer indicating which sub bands are supported by LoRa gateway.
        public var subBands: [Swift.Int]?

        public init (
            gatewayEui: Swift.String? = nil,
            joinEuiFilters: [[Swift.String]]? = nil,
            netIdFilters: [Swift.String]? = nil,
            rfRegion: Swift.String? = nil,
            subBands: [Swift.Int]? = nil
        )
        {
            self.gatewayEui = gatewayEui
            self.joinEuiFilters = joinEuiFilters
            self.netIdFilters = netIdFilters
            self.rfRegion = rfRegion
            self.subBands = subBands
        }
    }

}

extension IotWirelessClientTypes.LoRaWANGatewayCurrentVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension IotWirelessClientTypes {
    /// LoRaWANGatewayCurrentVersion object.
    public struct LoRaWANGatewayCurrentVersion: Swift.Equatable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IotWirelessClientTypes.LoRaWANGatewayVersion?

        public init (
            currentVersion: IotWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
        }
    }

}

extension IotWirelessClientTypes.LoRaWANGatewayMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayEui = "GatewayEui"
        case rssi = "Rssi"
        case snr = "Snr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayEui = gatewayEui {
            try encodeContainer.encode(gatewayEui, forKey: .gatewayEui)
        }
        if let rssi = rssi {
            try encodeContainer.encode(rssi, forKey: .rssi)
        }
        if let snr = snr {
            try encodeContainer.encode(snr, forKey: .snr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayEui)
        gatewayEui = gatewayEuiDecoded
        let snrDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .snr)
        snr = snrDecoded
        let rssiDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rssi)
        rssi = rssiDecoded
    }
}

extension IotWirelessClientTypes {
    /// LoRaWAN gateway metatdata.
    public struct LoRaWANGatewayMetadata: Swift.Equatable {
        /// The gateway's EUI value.
        public var gatewayEui: Swift.String?
        /// The RSSI value.
        public var rssi: Swift.Double?
        /// The SNR value.
        public var snr: Swift.Double?

        public init (
            gatewayEui: Swift.String? = nil,
            rssi: Swift.Double? = nil,
            snr: Swift.Double? = nil
        )
        {
            self.gatewayEui = gatewayEui
            self.rssi = rssi
            self.snr = snr
        }
    }

}

extension IotWirelessClientTypes.LoRaWANGatewayVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case model = "Model"
        case packageVersion = "PackageVersion"
        case station = "Station"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let packageVersion = packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
        if let station = station {
            try encodeContainer.encode(station, forKey: .station)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let stationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .station)
        station = stationDecoded
    }
}

extension IotWirelessClientTypes {
    /// LoRaWANGatewayVersion object.
    public struct LoRaWANGatewayVersion: Swift.Equatable {
        /// The model number of the wireless gateway.
        public var model: Swift.String?
        /// The version of the wireless gateway firmware.
        public var packageVersion: Swift.String?
        /// The basic station version of the wireless gateway.
        public var station: Swift.String?

        public init (
            model: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            station: Swift.String? = nil
        )
        {
            self.model = model
            self.packageVersion = packageVersion
            self.station = station
        }
    }

}

extension IotWirelessClientTypes.LoRaWANGetServiceProfileInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addGwMetadata = "AddGwMetadata"
        case channelMask = "ChannelMask"
        case devStatusReqFreq = "DevStatusReqFreq"
        case dlBucketSize = "DlBucketSize"
        case dlRate = "DlRate"
        case dlRatePolicy = "DlRatePolicy"
        case drMax = "DrMax"
        case drMin = "DrMin"
        case hrAllowed = "HrAllowed"
        case minGwDiversity = "MinGwDiversity"
        case nwkGeoLoc = "NwkGeoLoc"
        case prAllowed = "PrAllowed"
        case raAllowed = "RaAllowed"
        case reportDevStatusBattery = "ReportDevStatusBattery"
        case reportDevStatusMargin = "ReportDevStatusMargin"
        case targetPer = "TargetPer"
        case ulBucketSize = "UlBucketSize"
        case ulRate = "UlRate"
        case ulRatePolicy = "UlRatePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGwMetadata != false {
            try encodeContainer.encode(addGwMetadata, forKey: .addGwMetadata)
        }
        if let channelMask = channelMask {
            try encodeContainer.encode(channelMask, forKey: .channelMask)
        }
        if let devStatusReqFreq = devStatusReqFreq {
            try encodeContainer.encode(devStatusReqFreq, forKey: .devStatusReqFreq)
        }
        if let dlBucketSize = dlBucketSize {
            try encodeContainer.encode(dlBucketSize, forKey: .dlBucketSize)
        }
        if let dlRate = dlRate {
            try encodeContainer.encode(dlRate, forKey: .dlRate)
        }
        if let dlRatePolicy = dlRatePolicy {
            try encodeContainer.encode(dlRatePolicy, forKey: .dlRatePolicy)
        }
        if drMax != 0 {
            try encodeContainer.encode(drMax, forKey: .drMax)
        }
        if drMin != 0 {
            try encodeContainer.encode(drMin, forKey: .drMin)
        }
        if hrAllowed != false {
            try encodeContainer.encode(hrAllowed, forKey: .hrAllowed)
        }
        if let minGwDiversity = minGwDiversity {
            try encodeContainer.encode(minGwDiversity, forKey: .minGwDiversity)
        }
        if nwkGeoLoc != false {
            try encodeContainer.encode(nwkGeoLoc, forKey: .nwkGeoLoc)
        }
        if prAllowed != false {
            try encodeContainer.encode(prAllowed, forKey: .prAllowed)
        }
        if raAllowed != false {
            try encodeContainer.encode(raAllowed, forKey: .raAllowed)
        }
        if reportDevStatusBattery != false {
            try encodeContainer.encode(reportDevStatusBattery, forKey: .reportDevStatusBattery)
        }
        if reportDevStatusMargin != false {
            try encodeContainer.encode(reportDevStatusMargin, forKey: .reportDevStatusMargin)
        }
        if targetPer != 0 {
            try encodeContainer.encode(targetPer, forKey: .targetPer)
        }
        if let ulBucketSize = ulBucketSize {
            try encodeContainer.encode(ulBucketSize, forKey: .ulBucketSize)
        }
        if let ulRate = ulRate {
            try encodeContainer.encode(ulRate, forKey: .ulRate)
        }
        if let ulRatePolicy = ulRatePolicy {
            try encodeContainer.encode(ulRatePolicy, forKey: .ulRatePolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ulRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ulRate)
        ulRate = ulRateDecoded
        let ulBucketSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ulBucketSize)
        ulBucketSize = ulBucketSizeDecoded
        let ulRatePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ulRatePolicy)
        ulRatePolicy = ulRatePolicyDecoded
        let dlRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlRate)
        dlRate = dlRateDecoded
        let dlBucketSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlBucketSize)
        dlBucketSize = dlBucketSizeDecoded
        let dlRatePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dlRatePolicy)
        dlRatePolicy = dlRatePolicyDecoded
        let addGwMetadataDecoded = try containerValues.decode(Swift.Bool.self, forKey: .addGwMetadata)
        addGwMetadata = addGwMetadataDecoded
        let devStatusReqFreqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .devStatusReqFreq)
        devStatusReqFreq = devStatusReqFreqDecoded
        let reportDevStatusBatteryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .reportDevStatusBattery)
        reportDevStatusBattery = reportDevStatusBatteryDecoded
        let reportDevStatusMarginDecoded = try containerValues.decode(Swift.Bool.self, forKey: .reportDevStatusMargin)
        reportDevStatusMargin = reportDevStatusMarginDecoded
        let drMinDecoded = try containerValues.decode(Swift.Int.self, forKey: .drMin)
        drMin = drMinDecoded
        let drMaxDecoded = try containerValues.decode(Swift.Int.self, forKey: .drMax)
        drMax = drMaxDecoded
        let channelMaskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelMask)
        channelMask = channelMaskDecoded
        let prAllowedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .prAllowed)
        prAllowed = prAllowedDecoded
        let hrAllowedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .hrAllowed)
        hrAllowed = hrAllowedDecoded
        let raAllowedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .raAllowed)
        raAllowed = raAllowedDecoded
        let nwkGeoLocDecoded = try containerValues.decode(Swift.Bool.self, forKey: .nwkGeoLoc)
        nwkGeoLoc = nwkGeoLocDecoded
        let targetPerDecoded = try containerValues.decode(Swift.Int.self, forKey: .targetPer)
        targetPer = targetPerDecoded
        let minGwDiversityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minGwDiversity)
        minGwDiversity = minGwDiversityDecoded
    }
}

extension IotWirelessClientTypes {
    /// LoRaWANGetServiceProfileInfo object.
    public struct LoRaWANGetServiceProfileInfo: Swift.Equatable {
        /// The AddGWMetaData value.
        public var addGwMetadata: Swift.Bool
        /// The ChannelMask value.
        public var channelMask: Swift.String?
        /// The DevStatusReqFreq value.
        public var devStatusReqFreq: Swift.Int?
        /// The DLBucketSize value.
        public var dlBucketSize: Swift.Int?
        /// The DLRate value.
        public var dlRate: Swift.Int?
        /// The DLRatePolicy value.
        public var dlRatePolicy: Swift.String?
        /// The DRMax value.
        public var drMax: Swift.Int
        /// The DRMin value.
        public var drMin: Swift.Int
        /// The HRAllowed value that describes whether handover roaming is allowed.
        public var hrAllowed: Swift.Bool
        /// The MinGwDiversity value.
        public var minGwDiversity: Swift.Int?
        /// The NwkGeoLoc value.
        public var nwkGeoLoc: Swift.Bool
        /// The PRAllowed value that describes whether passive roaming is allowed.
        public var prAllowed: Swift.Bool
        /// The RAAllowed value that describes whether roaming activation is allowed.
        public var raAllowed: Swift.Bool
        /// The ReportDevStatusBattery value.
        public var reportDevStatusBattery: Swift.Bool
        /// The ReportDevStatusMargin value.
        public var reportDevStatusMargin: Swift.Bool
        /// The TargetPER value.
        public var targetPer: Swift.Int
        /// The ULBucketSize value.
        public var ulBucketSize: Swift.Int?
        /// The ULRate value.
        public var ulRate: Swift.Int?
        /// The ULRatePolicy value.
        public var ulRatePolicy: Swift.String?

        public init (
            addGwMetadata: Swift.Bool = false,
            channelMask: Swift.String? = nil,
            devStatusReqFreq: Swift.Int? = nil,
            dlBucketSize: Swift.Int? = nil,
            dlRate: Swift.Int? = nil,
            dlRatePolicy: Swift.String? = nil,
            drMax: Swift.Int = 0,
            drMin: Swift.Int = 0,
            hrAllowed: Swift.Bool = false,
            minGwDiversity: Swift.Int? = nil,
            nwkGeoLoc: Swift.Bool = false,
            prAllowed: Swift.Bool = false,
            raAllowed: Swift.Bool = false,
            reportDevStatusBattery: Swift.Bool = false,
            reportDevStatusMargin: Swift.Bool = false,
            targetPer: Swift.Int = 0,
            ulBucketSize: Swift.Int? = nil,
            ulRate: Swift.Int? = nil,
            ulRatePolicy: Swift.String? = nil
        )
        {
            self.addGwMetadata = addGwMetadata
            self.channelMask = channelMask
            self.devStatusReqFreq = devStatusReqFreq
            self.dlBucketSize = dlBucketSize
            self.dlRate = dlRate
            self.dlRatePolicy = dlRatePolicy
            self.drMax = drMax
            self.drMin = drMin
            self.hrAllowed = hrAllowed
            self.minGwDiversity = minGwDiversity
            self.nwkGeoLoc = nwkGeoLoc
            self.prAllowed = prAllowed
            self.raAllowed = raAllowed
            self.reportDevStatusBattery = reportDevStatusBattery
            self.reportDevStatusMargin = reportDevStatusMargin
            self.targetPer = targetPer
            self.ulBucketSize = ulBucketSize
            self.ulRate = ulRate
            self.ulRatePolicy = ulRatePolicy
        }
    }

}

extension IotWirelessClientTypes.LoRaWANListDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devEui = "DevEui"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devEui = devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEui)
        devEui = devEuiDecoded
    }
}

extension IotWirelessClientTypes {
    /// LoRaWAN object for list functions.
    public struct LoRaWANListDevice: Swift.Equatable {
        /// The DevEUI value.
        public var devEui: Swift.String?

        public init (
            devEui: Swift.String? = nil
        )
        {
            self.devEui = devEui
        }
    }

}

extension IotWirelessClientTypes.LoRaWANMulticast: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dlClass = "DlClass"
        case rfRegion = "RfRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dlClass = dlClass {
            try encodeContainer.encode(dlClass.rawValue, forKey: .dlClass)
        }
        if let rfRegion = rfRegion {
            try encodeContainer.encode(rfRegion.rawValue, forKey: .rfRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rfRegionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SupportedRfRegion.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let dlClassDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.DlClass.self, forKey: .dlClass)
        dlClass = dlClassDecoded
    }
}

extension IotWirelessClientTypes {
    /// The LoRaWAN information that is to be used with the multicast group.
    public struct LoRaWANMulticast: Swift.Equatable {
        /// DlClass for LoRaWAM, valid values are ClassB and ClassC.
        public var dlClass: IotWirelessClientTypes.DlClass?
        /// Supported RfRegions
        public var rfRegion: IotWirelessClientTypes.SupportedRfRegion?

        public init (
            dlClass: IotWirelessClientTypes.DlClass? = nil,
            rfRegion: IotWirelessClientTypes.SupportedRfRegion? = nil
        )
        {
            self.dlClass = dlClass
            self.rfRegion = rfRegion
        }
    }

}

extension IotWirelessClientTypes.LoRaWANMulticastGet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dlClass = "DlClass"
        case numberOfDevicesInGroup = "NumberOfDevicesInGroup"
        case numberOfDevicesRequested = "NumberOfDevicesRequested"
        case rfRegion = "RfRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dlClass = dlClass {
            try encodeContainer.encode(dlClass.rawValue, forKey: .dlClass)
        }
        if let numberOfDevicesInGroup = numberOfDevicesInGroup {
            try encodeContainer.encode(numberOfDevicesInGroup, forKey: .numberOfDevicesInGroup)
        }
        if let numberOfDevicesRequested = numberOfDevicesRequested {
            try encodeContainer.encode(numberOfDevicesRequested, forKey: .numberOfDevicesRequested)
        }
        if let rfRegion = rfRegion {
            try encodeContainer.encode(rfRegion.rawValue, forKey: .rfRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rfRegionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SupportedRfRegion.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let dlClassDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.DlClass.self, forKey: .dlClass)
        dlClass = dlClassDecoded
        let numberOfDevicesRequestedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDevicesRequested)
        numberOfDevicesRequested = numberOfDevicesRequestedDecoded
        let numberOfDevicesInGroupDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDevicesInGroup)
        numberOfDevicesInGroup = numberOfDevicesInGroupDecoded
    }
}

extension IotWirelessClientTypes {
    /// The LoRaWAN information that is to be returned from getting multicast group information.
    public struct LoRaWANMulticastGet: Swift.Equatable {
        /// DlClass for LoRaWAM, valid values are ClassB and ClassC.
        public var dlClass: IotWirelessClientTypes.DlClass?
        /// Number of devices that are associated to the multicast group.
        public var numberOfDevicesInGroup: Swift.Int?
        /// Number of devices that are requested to be associated with the multicast group.
        public var numberOfDevicesRequested: Swift.Int?
        /// Supported RfRegions
        public var rfRegion: IotWirelessClientTypes.SupportedRfRegion?

        public init (
            dlClass: IotWirelessClientTypes.DlClass? = nil,
            numberOfDevicesInGroup: Swift.Int? = nil,
            numberOfDevicesRequested: Swift.Int? = nil,
            rfRegion: IotWirelessClientTypes.SupportedRfRegion? = nil
        )
        {
            self.dlClass = dlClass
            self.numberOfDevicesInGroup = numberOfDevicesInGroup
            self.numberOfDevicesRequested = numberOfDevicesRequested
            self.rfRegion = rfRegion
        }
    }

}

extension IotWirelessClientTypes.LoRaWANMulticastMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fPort = "FPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fPort = fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
    }
}

extension IotWirelessClientTypes {
    /// The metadata information of the LoRaWAN multicast group.
    public struct LoRaWANMulticastMetadata: Swift.Equatable {
        /// The Fport value.
        public var fPort: Swift.Int?

        public init (
            fPort: Swift.Int? = nil
        )
        {
            self.fPort = fPort
        }
    }

}

extension IotWirelessClientTypes.LoRaWANMulticastSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dlDr = "DlDr"
        case dlFreq = "DlFreq"
        case sessionStartTime = "SessionStartTime"
        case sessionTimeout = "SessionTimeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dlDr = dlDr {
            try encodeContainer.encode(dlDr, forKey: .dlDr)
        }
        if let dlFreq = dlFreq {
            try encodeContainer.encode(dlFreq, forKey: .dlFreq)
        }
        if let sessionStartTime = sessionStartTime {
            try encodeContainer.encode(sessionStartTime.timeIntervalSince1970, forKey: .sessionStartTime)
        }
        if let sessionTimeout = sessionTimeout {
            try encodeContainer.encode(sessionTimeout, forKey: .sessionTimeout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dlDrDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlDr)
        dlDr = dlDrDecoded
        let dlFreqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlFreq)
        dlFreq = dlFreqDecoded
        let sessionStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .sessionStartTime)
        sessionStartTime = sessionStartTimeDecoded
        let sessionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionTimeout)
        sessionTimeout = sessionTimeoutDecoded
    }
}

extension IotWirelessClientTypes {
    /// The LoRaWAN information used with the multicast session.
    public struct LoRaWANMulticastSession: Swift.Equatable {
        /// Downlink data rate.
        public var dlDr: Swift.Int?
        /// Downlink frequency.
        public var dlFreq: Swift.Int?
        /// Timestamp of when the multicast group session is to start.
        public var sessionStartTime: ClientRuntime.Date?
        /// How long before a multicast group session is to timeout.
        public var sessionTimeout: Swift.Int?

        public init (
            dlDr: Swift.Int? = nil,
            dlFreq: Swift.Int? = nil,
            sessionStartTime: ClientRuntime.Date? = nil,
            sessionTimeout: Swift.Int? = nil
        )
        {
            self.dlDr = dlDr
            self.dlFreq = dlFreq
            self.sessionStartTime = sessionStartTime
            self.sessionTimeout = sessionTimeout
        }
    }

}

extension IotWirelessClientTypes.LoRaWANSendDataToDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fPort = "FPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fPort = fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
    }
}

extension IotWirelessClientTypes {
    /// LoRaWAN router info.
    public struct LoRaWANSendDataToDevice: Swift.Equatable {
        /// The Fport value.
        public var fPort: Swift.Int?

        public init (
            fPort: Swift.Int? = nil
        )
        {
            self.fPort = fPort
        }
    }

}

extension IotWirelessClientTypes.LoRaWANServiceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addGwMetadata = "AddGwMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGwMetadata != false {
            try encodeContainer.encode(addGwMetadata, forKey: .addGwMetadata)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addGwMetadataDecoded = try containerValues.decode(Swift.Bool.self, forKey: .addGwMetadata)
        addGwMetadata = addGwMetadataDecoded
    }
}

extension IotWirelessClientTypes {
    /// LoRaWANServiceProfile object.
    public struct LoRaWANServiceProfile: Swift.Equatable {
        /// The AddGWMetaData value.
        public var addGwMetadata: Swift.Bool

        public init (
            addGwMetadata: Swift.Bool = false
        )
        {
            self.addGwMetadata = addGwMetadata
        }
    }

}

extension IotWirelessClientTypes.LoRaWANStartFuotaTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension IotWirelessClientTypes {
    /// The LoRaWAN information used to start a FUOTA task.
    public struct LoRaWANStartFuotaTask: Swift.Equatable {
        /// Start time of a FUOTA task.
        public var startTime: ClientRuntime.Date?

        public init (
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.startTime = startTime
        }
    }

}

extension IotWirelessClientTypes.LoRaWANUpdateDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceProfileId = "DeviceProfileId"
        case serviceProfileId = "ServiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceProfileId = deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
        if let serviceProfileId = serviceProfileId {
            try encodeContainer.encode(serviceProfileId, forKey: .serviceProfileId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
        let serviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProfileId)
        serviceProfileId = serviceProfileIdDecoded
    }
}

extension IotWirelessClientTypes {
    /// LoRaWAN object for update functions.
    public struct LoRaWANUpdateDevice: Swift.Equatable {
        /// The ID of the device profile for the wireless device.
        public var deviceProfileId: Swift.String?
        /// The ID of the service profile.
        public var serviceProfileId: Swift.String?

        public init (
            deviceProfileId: Swift.String? = nil,
            serviceProfileId: Swift.String? = nil
        )
        {
            self.deviceProfileId = deviceProfileId
            self.serviceProfileId = serviceProfileId
        }
    }

}

extension IotWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case sigKeyCrc = "SigKeyCrc"
        case updateSignature = "UpdateSignature"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let sigKeyCrc = sigKeyCrc {
            try encodeContainer.encode(sigKeyCrc, forKey: .sigKeyCrc)
        }
        if let updateSignature = updateSignature {
            try encodeContainer.encode(updateSignature, forKey: .updateSignature)
        }
        if let updateVersion = updateVersion {
            try encodeContainer.encode(updateVersion, forKey: .updateVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateSignature)
        updateSignature = updateSignatureDecoded
        let sigKeyCrcDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sigKeyCrc)
        sigKeyCrc = sigKeyCrcDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let updateVersionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
    }
}

extension IotWirelessClientTypes {
    /// LoRaWANUpdateGatewayTaskCreate object.
    public struct LoRaWANUpdateGatewayTaskCreate: Swift.Equatable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IotWirelessClientTypes.LoRaWANGatewayVersion?
        /// The CRC of the signature private key to check.
        public var sigKeyCrc: Swift.Int?
        /// The signature used to verify the update firmware.
        public var updateSignature: Swift.String?
        /// The firmware version to update the gateway to.
        public var updateVersion: IotWirelessClientTypes.LoRaWANGatewayVersion?

        public init (
            currentVersion: IotWirelessClientTypes.LoRaWANGatewayVersion? = nil,
            sigKeyCrc: Swift.Int? = nil,
            updateSignature: Swift.String? = nil,
            updateVersion: IotWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
            self.sigKeyCrc = sigKeyCrc
            self.updateSignature = updateSignature
            self.updateVersion = updateVersion
        }
    }

}

extension IotWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let updateVersion = updateVersion {
            try encodeContainer.encode(updateVersion, forKey: .updateVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let updateVersionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
    }
}

extension IotWirelessClientTypes {
    /// LoRaWANUpdateGatewayTaskEntry object.
    public struct LoRaWANUpdateGatewayTaskEntry: Swift.Equatable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IotWirelessClientTypes.LoRaWANGatewayVersion?
        /// The firmware version to update the gateway to.
        public var updateVersion: IotWirelessClientTypes.LoRaWANGatewayVersion?

        public init (
            currentVersion: IotWirelessClientTypes.LoRaWANGatewayVersion? = nil,
            updateVersion: IotWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
            self.updateVersion = updateVersion
        }
    }

}

extension IotWirelessClientTypes {
    /// The log level for a log message.
    public enum LogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case error
        case info
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .disabled,
                .error,
                .info,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .error: return "ERROR"
            case .info: return "INFO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    /// Sidewalk device message type. Default value is CUSTOM_COMMAND_ID_NOTIFY.
    public enum MessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customCommandIdGet
        case customCommandIdNotify
        case customCommandIdResp
        case customCommandIdSet
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .customCommandIdGet,
                .customCommandIdNotify,
                .customCommandIdResp,
                .customCommandIdSet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customCommandIdGet: return "CUSTOM_COMMAND_ID_GET"
            case .customCommandIdNotify: return "CUSTOM_COMMAND_ID_NOTIFY"
            case .customCommandIdResp: return "CUSTOM_COMMAND_ID_RESP"
            case .customCommandIdSet: return "CUSTOM_COMMAND_ID_SET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.MulticastGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IotWirelessClientTypes {
    /// A multicast group.
    public struct MulticastGroup: Swift.Equatable {
        /// The arn of the multicast group.
        public var arn: Swift.String?
        /// The ID of the multicast group.
        public var id: Swift.String?
        /// The name of the multicast group.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IotWirelessClientTypes.MulticastGroupByFuotaTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IotWirelessClientTypes {
    /// A multicast group that is associated with a FUOTA task.
    public struct MulticastGroupByFuotaTask: Swift.Equatable {
        /// The ID of the multicast group.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IotWirelessClientTypes.MulticastWirelessMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANMulticastMetadata.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IotWirelessClientTypes {
    /// Wireless metadata that is to be sent to multicast group.
    public struct MulticastWirelessMetadata: Swift.Equatable {
        /// The metadata information of the LoRaWAN multicast group.
        public var loRaWAN: IotWirelessClientTypes.LoRaWANMulticastMetadata?

        public init (
            loRaWAN: IotWirelessClientTypes.LoRaWANMulticastMetadata? = nil
        )
        {
            self.loRaWAN = loRaWAN
        }
    }

}

extension IotWirelessClientTypes.OtaaV1_0_x: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appEui = "AppEui"
        case appKey = "AppKey"
        case genAppKey = "GenAppKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appEui = appEui {
            try encodeContainer.encode(appEui, forKey: .appEui)
        }
        if let appKey = appKey {
            try encodeContainer.encode(appKey, forKey: .appKey)
        }
        if let genAppKey = genAppKey {
            try encodeContainer.encode(genAppKey, forKey: .genAppKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appKey)
        appKey = appKeyDecoded
        let appEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appEui)
        appEui = appEuiDecoded
        let genAppKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .genAppKey)
        genAppKey = genAppKeyDecoded
    }
}

extension IotWirelessClientTypes {
    /// OTAA device object for v1.0.x
    public struct OtaaV1_0_x: Swift.Equatable {
        /// The AppEUI value.
        public var appEui: Swift.String?
        /// The AppKey value.
        public var appKey: Swift.String?
        /// The GenAppKey value.
        public var genAppKey: Swift.String?

        public init (
            appEui: Swift.String? = nil,
            appKey: Swift.String? = nil,
            genAppKey: Swift.String? = nil
        )
        {
            self.appEui = appEui
            self.appKey = appKey
            self.genAppKey = genAppKey
        }
    }

}

extension IotWirelessClientTypes.OtaaV1_1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appKey = "AppKey"
        case joinEui = "JoinEui"
        case nwkKey = "NwkKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appKey = appKey {
            try encodeContainer.encode(appKey, forKey: .appKey)
        }
        if let joinEui = joinEui {
            try encodeContainer.encode(joinEui, forKey: .joinEui)
        }
        if let nwkKey = nwkKey {
            try encodeContainer.encode(nwkKey, forKey: .nwkKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appKey)
        appKey = appKeyDecoded
        let nwkKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nwkKey)
        nwkKey = nwkKeyDecoded
        let joinEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .joinEui)
        joinEui = joinEuiDecoded
    }
}

extension IotWirelessClientTypes {
    /// OTAA device object for v1.1
    public struct OtaaV1_1: Swift.Equatable {
        /// The AppKey value.
        public var appKey: Swift.String?
        /// The JoinEUI value.
        public var joinEui: Swift.String?
        /// The NwkKey value.
        public var nwkKey: Swift.String?

        public init (
            appKey: Swift.String? = nil,
            joinEui: Swift.String? = nil,
            nwkKey: Swift.String? = nil
        )
        {
            self.appKey = appKey
            self.joinEui = joinEui
            self.nwkKey = nwkKey
        }
    }

}

extension IotWirelessClientTypes {
    public enum PartnerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [PartnerType] {
            return [
                .sidewalk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PartnerType(rawValue: rawValue) ?? PartnerType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.ProximityEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkEventNotificationConfigurations.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IotWirelessClientTypes {
    /// Proximity event configuration object for enabling and disabling relevant topics.
    public struct ProximityEventConfiguration: Swift.Equatable {
        /// Proximity event configuration object for enabling or disabling Sidewalk related event topics.
        public var sidewalk: IotWirelessClientTypes.SidewalkEventNotificationConfigurations?

        public init (
            sidewalk: IotWirelessClientTypes.SidewalkEventNotificationConfigurations? = nil
        )
        {
            self.sidewalk = sidewalk
        }
    }

}

extension PutResourceLogLevelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }
}

extension PutResourceLogLevelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceType = resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension PutResourceLogLevelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct PutResourceLogLevelInput: Swift.Equatable {
    /// The log level for a log message.
    /// This member is required.
    public var logLevel: IotWirelessClientTypes.LogLevel?
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway, it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        logLevel: IotWirelessClientTypes.LogLevel? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.logLevel = logLevel
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct PutResourceLogLevelInputBody: Swift.Equatable {
    let logLevel: IotWirelessClientTypes.LogLevel?
}

extension PutResourceLogLevelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension PutResourceLogLevelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourceLogLevelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourceLogLevelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourceLogLevelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutResourceLogLevelOutputResponse: Swift.Equatable {

}

extension ResetAllResourceLogLevelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/log-levels"
    }
}

public struct ResetAllResourceLogLevelsInput: Swift.Equatable {

}

struct ResetAllResourceLogLevelsInputBody: Swift.Equatable {
}

extension ResetAllResourceLogLevelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResetAllResourceLogLevelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetAllResourceLogLevelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetAllResourceLogLevelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetAllResourceLogLevelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResetAllResourceLogLevelsOutputResponse: Swift.Equatable {

}

extension ResetResourceLogLevelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceType = resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension ResetResourceLogLevelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct ResetResourceLogLevelInput: Swift.Equatable {
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway, it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct ResetResourceLogLevelInputBody: Swift.Equatable {
}

extension ResetResourceLogLevelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResetResourceLogLevelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetResourceLogLevelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetResourceLogLevelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetResourceLogLevelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResetResourceLogLevelOutputResponse: Swift.Equatable {

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Resource does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Id of the not found resource.
    public var resourceId: Swift.String?
    /// Type of the font found resource.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SendDataToMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case wirelessMetadata = "WirelessMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payloadData = payloadData {
            try encodeContainer.encode(payloadData, forKey: .payloadData)
        }
        if let wirelessMetadata = wirelessMetadata {
            try encodeContainer.encode(wirelessMetadata, forKey: .wirelessMetadata)
        }
    }
}

extension SendDataToMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/data"
    }
}

public struct SendDataToMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The binary to be sent to the end device, encoded in base64.
    /// This member is required.
    public var payloadData: Swift.String?
    /// Wireless metadata that is to be sent to multicast group.
    /// This member is required.
    public var wirelessMetadata: IotWirelessClientTypes.MulticastWirelessMetadata?

    public init (
        id: Swift.String? = nil,
        payloadData: Swift.String? = nil,
        wirelessMetadata: IotWirelessClientTypes.MulticastWirelessMetadata? = nil
    )
    {
        self.id = id
        self.payloadData = payloadData
        self.wirelessMetadata = wirelessMetadata
    }
}

struct SendDataToMulticastGroupInputBody: Swift.Equatable {
    let payloadData: Swift.String?
    let wirelessMetadata: IotWirelessClientTypes.MulticastWirelessMetadata?
}

extension SendDataToMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case wirelessMetadata = "WirelessMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadData)
        payloadData = payloadDataDecoded
        let wirelessMetadataDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.MulticastWirelessMetadata.self, forKey: .wirelessMetadata)
        wirelessMetadata = wirelessMetadataDecoded
    }
}

extension SendDataToMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendDataToMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendDataToMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendDataToMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendDataToMulticastGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendDataToMulticastGroupOutputResponse: Swift.Equatable {
    /// ID of a multicast group message.
    public var messageId: Swift.String?

    public init (
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendDataToMulticastGroupOutputResponseBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendDataToMulticastGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension SendDataToWirelessDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case transmitMode = "TransmitMode"
        case wirelessMetadata = "WirelessMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payloadData = payloadData {
            try encodeContainer.encode(payloadData, forKey: .payloadData)
        }
        if let transmitMode = transmitMode {
            try encodeContainer.encode(transmitMode, forKey: .transmitMode)
        }
        if let wirelessMetadata = wirelessMetadata {
            try encodeContainer.encode(wirelessMetadata, forKey: .wirelessMetadata)
        }
    }
}

extension SendDataToWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/data"
    }
}

public struct SendDataToWirelessDeviceInput: Swift.Equatable {
    /// The ID of the wireless device to receive the data.
    /// This member is required.
    public var id: Swift.String?
    /// The binary to be sent to the end device, encoded in base64.
    /// This member is required.
    public var payloadData: Swift.String?
    /// The transmit mode to use to send data to the wireless device. Can be: 0 for UM (unacknowledge mode) or 1 for AM (acknowledge mode).
    /// This member is required.
    public var transmitMode: Swift.Int?
    /// Metadata about the message request.
    public var wirelessMetadata: IotWirelessClientTypes.WirelessMetadata?

    public init (
        id: Swift.String? = nil,
        payloadData: Swift.String? = nil,
        transmitMode: Swift.Int? = nil,
        wirelessMetadata: IotWirelessClientTypes.WirelessMetadata? = nil
    )
    {
        self.id = id
        self.payloadData = payloadData
        self.transmitMode = transmitMode
        self.wirelessMetadata = wirelessMetadata
    }
}

struct SendDataToWirelessDeviceInputBody: Swift.Equatable {
    let transmitMode: Swift.Int?
    let payloadData: Swift.String?
    let wirelessMetadata: IotWirelessClientTypes.WirelessMetadata?
}

extension SendDataToWirelessDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case transmitMode = "TransmitMode"
        case wirelessMetadata = "WirelessMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transmitModeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .transmitMode)
        transmitMode = transmitModeDecoded
        let payloadDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadData)
        payloadData = payloadDataDecoded
        let wirelessMetadataDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessMetadata.self, forKey: .wirelessMetadata)
        wirelessMetadata = wirelessMetadataDecoded
    }
}

extension SendDataToWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendDataToWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendDataToWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendDataToWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendDataToWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendDataToWirelessDeviceOutputResponse: Swift.Equatable {
    /// The ID of the message sent to the wireless device.
    public var messageId: Swift.String?

    public init (
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendDataToWirelessDeviceOutputResponseBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendDataToWirelessDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension IotWirelessClientTypes.ServiceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IotWirelessClientTypes {
    /// Information about a service profile.
    public struct ServiceProfile: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the service profile.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IotWirelessClientTypes.SessionKeysAbpV1_0_x: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSKey = "AppSKey"
        case nwkSKey = "NwkSKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSKey = appSKey {
            try encodeContainer.encode(appSKey, forKey: .appSKey)
        }
        if let nwkSKey = nwkSKey {
            try encodeContainer.encode(nwkSKey, forKey: .nwkSKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nwkSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nwkSKey)
        nwkSKey = nwkSKeyDecoded
        let appSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appSKey)
        appSKey = appSKeyDecoded
    }
}

extension IotWirelessClientTypes {
    /// Session keys for ABP v1.1
    public struct SessionKeysAbpV1_0_x: Swift.Equatable {
        /// The AppSKey value.
        public var appSKey: Swift.String?
        /// The NwkSKey value.
        public var nwkSKey: Swift.String?

        public init (
            appSKey: Swift.String? = nil,
            nwkSKey: Swift.String? = nil
        )
        {
            self.appSKey = appSKey
            self.nwkSKey = nwkSKey
        }
    }

}

extension IotWirelessClientTypes.SessionKeysAbpV1_1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSKey = "AppSKey"
        case fNwkSIntKey = "FNwkSIntKey"
        case nwkSEncKey = "NwkSEncKey"
        case sNwkSIntKey = "SNwkSIntKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSKey = appSKey {
            try encodeContainer.encode(appSKey, forKey: .appSKey)
        }
        if let fNwkSIntKey = fNwkSIntKey {
            try encodeContainer.encode(fNwkSIntKey, forKey: .fNwkSIntKey)
        }
        if let nwkSEncKey = nwkSEncKey {
            try encodeContainer.encode(nwkSEncKey, forKey: .nwkSEncKey)
        }
        if let sNwkSIntKey = sNwkSIntKey {
            try encodeContainer.encode(sNwkSIntKey, forKey: .sNwkSIntKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fNwkSIntKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fNwkSIntKey)
        fNwkSIntKey = fNwkSIntKeyDecoded
        let sNwkSIntKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sNwkSIntKey)
        sNwkSIntKey = sNwkSIntKeyDecoded
        let nwkSEncKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nwkSEncKey)
        nwkSEncKey = nwkSEncKeyDecoded
        let appSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appSKey)
        appSKey = appSKeyDecoded
    }
}

extension IotWirelessClientTypes {
    /// Session keys for ABP v1.1
    public struct SessionKeysAbpV1_1: Swift.Equatable {
        /// The AppSKey value.
        public var appSKey: Swift.String?
        /// The FNwkSIntKey value.
        public var fNwkSIntKey: Swift.String?
        /// The NwkSEncKey value.
        public var nwkSEncKey: Swift.String?
        /// The SNwkSIntKey value.
        public var sNwkSIntKey: Swift.String?

        public init (
            appSKey: Swift.String? = nil,
            fNwkSIntKey: Swift.String? = nil,
            nwkSEncKey: Swift.String? = nil,
            sNwkSIntKey: Swift.String? = nil
        )
        {
            self.appSKey = appSKey
            self.fNwkSIntKey = fNwkSIntKey
            self.nwkSEncKey = nwkSEncKey
            self.sNwkSIntKey = sNwkSIntKey
        }
    }

}

extension IotWirelessClientTypes.SidewalkAccountInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case appServerPrivateKey = "AppServerPrivateKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let appServerPrivateKey = appServerPrivateKey {
            try encodeContainer.encode(appServerPrivateKey, forKey: .appServerPrivateKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let appServerPrivateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appServerPrivateKey)
        appServerPrivateKey = appServerPrivateKeyDecoded
    }
}

extension IotWirelessClientTypes {
    /// Information about a Sidewalk account.
    public struct SidewalkAccountInfo: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The Sidewalk application server private key.
        public var appServerPrivateKey: Swift.String?

        public init (
            amazonId: Swift.String? = nil,
            appServerPrivateKey: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.appServerPrivateKey = appServerPrivateKey
        }
    }

}

extension IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case arn = "Arn"
        case fingerprint = "Fingerprint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let fingerprint = fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IotWirelessClientTypes {
    /// Information about a Sidewalk account.
    public struct SidewalkAccountInfoWithFingerprint: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The fingerprint of the Sidewalk application server private key.
        public var fingerprint: Swift.String?

        public init (
            amazonId: Swift.String? = nil,
            arn: Swift.String? = nil,
            fingerprint: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.arn = arn
            self.fingerprint = fingerprint
        }
    }

}

extension IotWirelessClientTypes.SidewalkDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case deviceCertificates = "DeviceCertificates"
        case sidewalkId = "SidewalkId"
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let deviceCertificates = deviceCertificates {
            var deviceCertificatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceCertificates)
            for devicecertificatelist0 in deviceCertificates {
                try deviceCertificatesContainer.encode(devicecertificatelist0)
            }
        }
        if let sidewalkId = sidewalkId {
            try encodeContainer.encode(sidewalkId, forKey: .sidewalkId)
        }
        if let sidewalkManufacturingSn = sidewalkManufacturingSn {
            try encodeContainer.encode(sidewalkManufacturingSn, forKey: .sidewalkManufacturingSn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let sidewalkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkId)
        sidewalkId = sidewalkIdDecoded
        let sidewalkManufacturingSnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkManufacturingSn)
        sidewalkManufacturingSn = sidewalkManufacturingSnDecoded
        let deviceCertificatesContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.CertificateList?].self, forKey: .deviceCertificates)
        var deviceCertificatesDecoded0:[IotWirelessClientTypes.CertificateList]? = nil
        if let deviceCertificatesContainer = deviceCertificatesContainer {
            deviceCertificatesDecoded0 = [IotWirelessClientTypes.CertificateList]()
            for structure0 in deviceCertificatesContainer {
                if let structure0 = structure0 {
                    deviceCertificatesDecoded0?.append(structure0)
                }
            }
        }
        deviceCertificates = deviceCertificatesDecoded0
    }
}

extension IotWirelessClientTypes {
    /// Sidewalk device object.
    public struct SidewalkDevice: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The sidewalk device certificates for Ed25519 and P256r1.
        public var deviceCertificates: [IotWirelessClientTypes.CertificateList]?
        /// The sidewalk device identification.
        public var sidewalkId: Swift.String?
        /// The Sidewalk manufacturing series number.
        public var sidewalkManufacturingSn: Swift.String?

        public init (
            amazonId: Swift.String? = nil,
            deviceCertificates: [IotWirelessClientTypes.CertificateList]? = nil,
            sidewalkId: Swift.String? = nil,
            sidewalkManufacturingSn: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.deviceCertificates = deviceCertificates
            self.sidewalkId = sidewalkId
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
        }
    }

}

extension IotWirelessClientTypes.SidewalkDeviceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batteryLevel = "BatteryLevel"
        case deviceState = "DeviceState"
        case event = "Event"
        case rssi = "Rssi"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batteryLevel = batteryLevel {
            try encodeContainer.encode(batteryLevel.rawValue, forKey: .batteryLevel)
        }
        if let deviceState = deviceState {
            try encodeContainer.encode(deviceState.rawValue, forKey: .deviceState)
        }
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let rssi = rssi {
            try encodeContainer.encode(rssi, forKey: .rssi)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rssiDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rssi)
        rssi = rssiDecoded
        let batteryLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.BatteryLevel.self, forKey: .batteryLevel)
        batteryLevel = batteryLevelDecoded
        let eventDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let deviceStateDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.DeviceState.self, forKey: .deviceState)
        deviceState = deviceStateDecoded
    }
}

extension IotWirelessClientTypes {
    /// MetaData for Sidewalk device.
    public struct SidewalkDeviceMetadata: Swift.Equatable {
        /// Sidewalk device battery level.
        public var batteryLevel: IotWirelessClientTypes.BatteryLevel?
        /// Device state defines the device status of sidewalk device.
        public var deviceState: IotWirelessClientTypes.DeviceState?
        /// Sidewalk device status notification.
        public var event: IotWirelessClientTypes.Event?
        /// The RSSI value.
        public var rssi: Swift.Int?

        public init (
            batteryLevel: IotWirelessClientTypes.BatteryLevel? = nil,
            deviceState: IotWirelessClientTypes.DeviceState? = nil,
            event: IotWirelessClientTypes.Event? = nil,
            rssi: Swift.Int? = nil
        )
        {
            self.batteryLevel = batteryLevel
            self.deviceState = deviceState
            self.event = event
            self.rssi = rssi
        }
    }

}

extension IotWirelessClientTypes.SidewalkEventNotificationConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonIdEventTopic = "AmazonIdEventTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonIdEventTopic = amazonIdEventTopic {
            try encodeContainer.encode(amazonIdEventTopic.rawValue, forKey: .amazonIdEventTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdEventTopicDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.EventNotificationTopicStatus.self, forKey: .amazonIdEventTopic)
        amazonIdEventTopic = amazonIdEventTopicDecoded
    }
}

extension IotWirelessClientTypes {
    /// SidewalkEventNotificationConfigurations object Event configuration object for Sidewalk related event topics.
    public struct SidewalkEventNotificationConfigurations: Swift.Equatable {
        /// Enum to denote whether amazon id event topic is enabled or disabled.
        public var amazonIdEventTopic: IotWirelessClientTypes.EventNotificationTopicStatus?

        public init (
            amazonIdEventTopic: IotWirelessClientTypes.EventNotificationTopicStatus? = nil
        )
        {
            self.amazonIdEventTopic = amazonIdEventTopic
        }
    }

}

extension IotWirelessClientTypes.SidewalkListDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case deviceCertificates = "DeviceCertificates"
        case sidewalkId = "SidewalkId"
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let deviceCertificates = deviceCertificates {
            var deviceCertificatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceCertificates)
            for devicecertificatelist0 in deviceCertificates {
                try deviceCertificatesContainer.encode(devicecertificatelist0)
            }
        }
        if let sidewalkId = sidewalkId {
            try encodeContainer.encode(sidewalkId, forKey: .sidewalkId)
        }
        if let sidewalkManufacturingSn = sidewalkManufacturingSn {
            try encodeContainer.encode(sidewalkManufacturingSn, forKey: .sidewalkManufacturingSn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let sidewalkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkId)
        sidewalkId = sidewalkIdDecoded
        let sidewalkManufacturingSnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkManufacturingSn)
        sidewalkManufacturingSn = sidewalkManufacturingSnDecoded
        let deviceCertificatesContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.CertificateList?].self, forKey: .deviceCertificates)
        var deviceCertificatesDecoded0:[IotWirelessClientTypes.CertificateList]? = nil
        if let deviceCertificatesContainer = deviceCertificatesContainer {
            deviceCertificatesDecoded0 = [IotWirelessClientTypes.CertificateList]()
            for structure0 in deviceCertificatesContainer {
                if let structure0 = structure0 {
                    deviceCertificatesDecoded0?.append(structure0)
                }
            }
        }
        deviceCertificates = deviceCertificatesDecoded0
    }
}

extension IotWirelessClientTypes {
    /// Sidewalk object used by list functions.
    public struct SidewalkListDevice: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The sidewalk device certificates for Ed25519 and P256r1.
        public var deviceCertificates: [IotWirelessClientTypes.CertificateList]?
        /// The sidewalk device identification.
        public var sidewalkId: Swift.String?
        /// The Sidewalk manufacturing series number.
        public var sidewalkManufacturingSn: Swift.String?

        public init (
            amazonId: Swift.String? = nil,
            deviceCertificates: [IotWirelessClientTypes.CertificateList]? = nil,
            sidewalkId: Swift.String? = nil,
            sidewalkManufacturingSn: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.deviceCertificates = deviceCertificates
            self.sidewalkId = sidewalkId
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
        }
    }

}

extension IotWirelessClientTypes.SidewalkSendDataToDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageType = "MessageType"
        case seq = "Seq"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageType = messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let seq = seq {
            try encodeContainer.encode(seq, forKey: .seq)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let seqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .seq)
        seq = seqDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
    }
}

extension IotWirelessClientTypes {
    /// Information about a Sidewalk router.
    public struct SidewalkSendDataToDevice: Swift.Equatable {
        /// Sidewalk device message type. Default value is CUSTOM_COMMAND_ID_NOTIFY.
        public var messageType: IotWirelessClientTypes.MessageType?
        /// The sequence number.
        public var seq: Swift.Int?

        public init (
            messageType: IotWirelessClientTypes.MessageType? = nil,
            seq: Swift.Int? = nil
        )
        {
            self.messageType = messageType
            self.seq = seq
        }
    }

}

extension IotWirelessClientTypes.SidewalkUpdateAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appServerPrivateKey = "AppServerPrivateKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appServerPrivateKey = appServerPrivateKey {
            try encodeContainer.encode(appServerPrivateKey, forKey: .appServerPrivateKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appServerPrivateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appServerPrivateKey)
        appServerPrivateKey = appServerPrivateKeyDecoded
    }
}

extension IotWirelessClientTypes {
    /// Sidewalk update.
    public struct SidewalkUpdateAccount: Swift.Equatable {
        /// The new Sidewalk application server private key.
        public var appServerPrivateKey: Swift.String?

        public init (
            appServerPrivateKey: Swift.String? = nil
        )
        {
            self.appServerPrivateKey = appServerPrivateKey
        }
    }

}

extension IotWirelessClientTypes {
    /// The certificate chain algorithm provided by sidewalk.
    public enum SigningAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ed25519
        case p256r1
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningAlg] {
            return [
                .ed25519,
                .p256r1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ed25519: return "Ed25519"
            case .p256r1: return "P256r1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SigningAlg(rawValue: rawValue) ?? SigningAlg.sdkUnknown(rawValue)
        }
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/bulk"
    }
}

public struct StartBulkAssociateWirelessDeviceWithMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// Query string used to search for wireless devices as part of the bulk associate and disassociate process.
    public var queryString: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        id: Swift.String? = nil,
        queryString: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.id = id
        self.queryString = queryString
        self.tags = tags
    }
}

struct StartBulkAssociateWirelessDeviceWithMulticastGroupInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let tags: [IotWirelessClientTypes.Tag]?
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartBulkAssociateWirelessDeviceWithMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBulkAssociateWirelessDeviceWithMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartBulkAssociateWirelessDeviceWithMulticastGroupOutputResponse: Swift.Equatable {

}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/bulk"
    }
}

public struct StartBulkDisassociateWirelessDeviceFromMulticastGroupInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// Query string used to search for wireless devices as part of the bulk associate and disassociate process.
    public var queryString: Swift.String?
    /// The tag to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        id: Swift.String? = nil,
        queryString: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.id = id
        self.queryString = queryString
        self.tags = tags
    }
}

struct StartBulkDisassociateWirelessDeviceFromMulticastGroupInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let tags: [IotWirelessClientTypes.Tag]?
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryString = "QueryString"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartBulkDisassociateWirelessDeviceFromMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBulkDisassociateWirelessDeviceFromMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartBulkDisassociateWirelessDeviceFromMulticastGroupOutputResponse: Swift.Equatable {

}

extension StartFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }
}

extension StartFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

public struct StartFuotaTaskInput: Swift.Equatable {
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information used to start a FUOTA task.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANStartFuotaTask?

    public init (
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANStartFuotaTask? = nil
    )
    {
        self.id = id
        self.loRaWAN = loRaWAN
    }
}

struct StartFuotaTaskInputBody: Swift.Equatable {
    let loRaWAN: IotWirelessClientTypes.LoRaWANStartFuotaTask?
}

extension StartFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANStartFuotaTask.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension StartFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartFuotaTaskOutputResponse: Swift.Equatable {

}

extension StartMulticastGroupSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }
}

extension StartMulticastGroupSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())/session"
    }
}

public struct StartMulticastGroupSessionInput: Swift.Equatable {
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information used with the multicast session.
    /// This member is required.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANMulticastSession?

    public init (
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANMulticastSession? = nil
    )
    {
        self.id = id
        self.loRaWAN = loRaWAN
    }
}

struct StartMulticastGroupSessionInputBody: Swift.Equatable {
    let loRaWAN: IotWirelessClientTypes.LoRaWANMulticastSession?
}

extension StartMulticastGroupSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANMulticastSession.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension StartMulticastGroupSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMulticastGroupSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMulticastGroupSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMulticastGroupSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartMulticastGroupSessionOutputResponse: Swift.Equatable {

}

extension IotWirelessClientTypes {
    /// Supported RfRegions
    public enum SupportedRfRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case as9231
        case au915
        case eu868
        case us915
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedRfRegion] {
            return [
                .as9231,
                .au915,
                .eu868,
                .us915,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .as9231: return "AS923-1"
            case .au915: return "AU915"
            case .eu868: return "EU868"
            case .us915: return "US915"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SupportedRfRegion(rawValue: rawValue) ?? SupportedRfRegion.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IotWirelessClientTypes {
    /// A simple label consisting of a customer-defined key-value pair
    public struct Tag: Swift.Equatable {
        /// The tag's key value.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceArn = resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
        }
        return items
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds to or modifies the tags of the given resource. Tags are metadata that you can use to manage a resource.
    /// This member is required.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [IotWirelessClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension TestWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())/test"
    }
}

public struct TestWirelessDeviceInput: Swift.Equatable {
    /// The ID of the wireless device to test.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct TestWirelessDeviceInputBody: Swift.Equatable {
}

extension TestWirelessDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TestWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TestWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = nil
        }
    }
}

public struct TestWirelessDeviceOutputResponse: Swift.Equatable {
    /// The result returned by the test.
    public var result: Swift.String?

    public init (
        result: Swift.String? = nil
    )
    {
        self.result = result
    }
}

struct TestWirelessDeviceOutputResponseBody: Swift.Equatable {
    let result: Swift.String?
}

extension TestWirelessDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result = "Result"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because it exceeded the allowed API request rate.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because the resource can't have any more tags.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Name of the resource that exceeds maximum number of tags allowed.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension IotWirelessClientTypes.TraceContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
        case wirelessDeviceFrameInfo = "WirelessDeviceFrameInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let wirelessDeviceFrameInfo = wirelessDeviceFrameInfo {
            try encodeContainer.encode(wirelessDeviceFrameInfo.rawValue, forKey: .wirelessDeviceFrameInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceFrameInfoDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessDeviceFrameInfo.self, forKey: .wirelessDeviceFrameInfo)
        wirelessDeviceFrameInfo = wirelessDeviceFrameInfoDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IotWirelessClientTypes {
    /// Trace Content for resources.
    public struct TraceContent: Swift.Equatable {
        /// The log level for a log message.
        public var logLevel: IotWirelessClientTypes.LogLevel?
        /// WirelessDevice FrameInfo for trace content.
        public var wirelessDeviceFrameInfo: IotWirelessClientTypes.WirelessDeviceFrameInfo?

        public init (
            logLevel: IotWirelessClientTypes.LogLevel? = nil,
            wirelessDeviceFrameInfo: IotWirelessClientTypes.WirelessDeviceFrameInfo? = nil
        )
        {
            self.logLevel = logLevel
            self.wirelessDeviceFrameInfo = wirelessDeviceFrameInfo
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceArn = resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
        }
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

public struct UpdateDestinationInput: Swift.Equatable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The new rule name or topic rule to send messages to.
    public var expression: Swift.String?
    /// The type of value in Expression.
    public var expressionType: IotWirelessClientTypes.ExpressionType?
    /// The new name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    public var roleArn: Swift.String?

    public init (
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IotWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

struct UpdateDestinationInputBody: Swift.Equatable {
    let expressionType: IotWirelessClientTypes.ExpressionType?
    let expression: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
}

extension UpdateDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDestinationOutputResponse: Swift.Equatable {

}

extension UpdateFuotaTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firmwareUpdateImage = firmwareUpdateImage {
            try encodeContainer.encode(firmwareUpdateImage, forKey: .firmwareUpdateImage)
        }
        if let firmwareUpdateRole = firmwareUpdateRole {
            try encodeContainer.encode(firmwareUpdateRole, forKey: .firmwareUpdateRole)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateFuotaTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/fuota-tasks/\(id.urlPercentEncoding())"
    }
}

public struct UpdateFuotaTaskInput: Swift.Equatable {
    /// The description of the new resource.
    public var description: Swift.String?
    /// The S3 URI points to a firmware update image that is to be used with a FUOTA task.
    public var firmwareUpdateImage: Swift.String?
    /// The firmware update role that is to be used with a FUOTA task.
    public var firmwareUpdateRole: Swift.String?
    /// The ID of a FUOTA task.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information used with a FUOTA task.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANFuotaTask?
    /// The name of a FUOTA task.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        firmwareUpdateImage: Swift.String? = nil,
        firmwareUpdateRole: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANFuotaTask? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.firmwareUpdateImage = firmwareUpdateImage
        self.firmwareUpdateRole = firmwareUpdateRole
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct UpdateFuotaTaskInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANFuotaTask?
    let firmwareUpdateImage: Swift.String?
    let firmwareUpdateRole: Swift.String?
}

extension UpdateFuotaTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case firmwareUpdateImage = "FirmwareUpdateImage"
        case firmwareUpdateRole = "FirmwareUpdateRole"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANFuotaTask.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let firmwareUpdateImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateImage)
        firmwareUpdateImage = firmwareUpdateImageDecoded
        let firmwareUpdateRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firmwareUpdateRole)
        firmwareUpdateRole = firmwareUpdateRoleDecoded
    }
}

extension UpdateFuotaTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFuotaTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFuotaTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFuotaTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFuotaTaskOutputResponse: Swift.Equatable {

}

extension UpdateLogLevelsByResourceTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultLogLevel = defaultLogLevel {
            try encodeContainer.encode(defaultLogLevel.rawValue, forKey: .defaultLogLevel)
        }
        if let wirelessDeviceLogOptions = wirelessDeviceLogOptions {
            var wirelessDeviceLogOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDeviceLogOptions)
            for wirelessdevicelogoptionlist0 in wirelessDeviceLogOptions {
                try wirelessDeviceLogOptionsContainer.encode(wirelessdevicelogoptionlist0)
            }
        }
        if let wirelessGatewayLogOptions = wirelessGatewayLogOptions {
            var wirelessGatewayLogOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGatewayLogOptions)
            for wirelessgatewaylogoptionlist0 in wirelessGatewayLogOptions {
                try wirelessGatewayLogOptionsContainer.encode(wirelessgatewaylogoptionlist0)
            }
        }
    }
}

extension UpdateLogLevelsByResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/log-levels"
    }
}

public struct UpdateLogLevelsByResourceTypesInput: Swift.Equatable {
    /// The log level for a log message.
    public var defaultLogLevel: IotWirelessClientTypes.LogLevel?
    /// The list of wireless device log options.
    public var wirelessDeviceLogOptions: [IotWirelessClientTypes.WirelessDeviceLogOption]?
    /// The list of wireless gateway log options.
    public var wirelessGatewayLogOptions: [IotWirelessClientTypes.WirelessGatewayLogOption]?

    public init (
        defaultLogLevel: IotWirelessClientTypes.LogLevel? = nil,
        wirelessDeviceLogOptions: [IotWirelessClientTypes.WirelessDeviceLogOption]? = nil,
        wirelessGatewayLogOptions: [IotWirelessClientTypes.WirelessGatewayLogOption]? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
        self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
    }
}

struct UpdateLogLevelsByResourceTypesInputBody: Swift.Equatable {
    let defaultLogLevel: IotWirelessClientTypes.LogLevel?
    let wirelessDeviceLogOptions: [IotWirelessClientTypes.WirelessDeviceLogOption]?
    let wirelessGatewayLogOptions: [IotWirelessClientTypes.WirelessGatewayLogOption]?
}

extension UpdateLogLevelsByResourceTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let wirelessDeviceLogOptionsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessDeviceLogOption?].self, forKey: .wirelessDeviceLogOptions)
        var wirelessDeviceLogOptionsDecoded0:[IotWirelessClientTypes.WirelessDeviceLogOption]? = nil
        if let wirelessDeviceLogOptionsContainer = wirelessDeviceLogOptionsContainer {
            wirelessDeviceLogOptionsDecoded0 = [IotWirelessClientTypes.WirelessDeviceLogOption]()
            for structure0 in wirelessDeviceLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessDeviceLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceLogOptions = wirelessDeviceLogOptionsDecoded0
        let wirelessGatewayLogOptionsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessGatewayLogOption?].self, forKey: .wirelessGatewayLogOptions)
        var wirelessGatewayLogOptionsDecoded0:[IotWirelessClientTypes.WirelessGatewayLogOption]? = nil
        if let wirelessGatewayLogOptionsContainer = wirelessGatewayLogOptionsContainer {
            wirelessGatewayLogOptionsDecoded0 = [IotWirelessClientTypes.WirelessGatewayLogOption]()
            for structure0 in wirelessGatewayLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessGatewayLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayLogOptions = wirelessGatewayLogOptionsDecoded0
    }
}

extension UpdateLogLevelsByResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLogLevelsByResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLogLevelsByResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLogLevelsByResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLogLevelsByResourceTypesOutputResponse: Swift.Equatable {

}

extension UpdateMulticastGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateMulticastGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/multicast-groups/\(id.urlPercentEncoding())"
    }
}

public struct UpdateMulticastGroupInput: Swift.Equatable {
    /// The description of the new resource.
    public var description: Swift.String?
    /// The ID of the multicast group.
    /// This member is required.
    public var id: Swift.String?
    /// The LoRaWAN information that is to be used with the multicast group.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANMulticast?
    /// The name of the multicast group.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANMulticast? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct UpdateMulticastGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANMulticast?
}

extension UpdateMulticastGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANMulticast.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension UpdateMulticastGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMulticastGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMulticastGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMulticastGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMulticastGroupOutputResponse: Swift.Equatable {

}

extension UpdateNetworkAnalyzerConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case traceContent = "TraceContent"
        case wirelessDevicesToAdd = "WirelessDevicesToAdd"
        case wirelessDevicesToRemove = "WirelessDevicesToRemove"
        case wirelessGatewaysToAdd = "WirelessGatewaysToAdd"
        case wirelessGatewaysToRemove = "WirelessGatewaysToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let traceContent = traceContent {
            try encodeContainer.encode(traceContent, forKey: .traceContent)
        }
        if let wirelessDevicesToAdd = wirelessDevicesToAdd {
            var wirelessDevicesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDevicesToAdd)
            for wirelessdevicelist0 in wirelessDevicesToAdd {
                try wirelessDevicesToAddContainer.encode(wirelessdevicelist0)
            }
        }
        if let wirelessDevicesToRemove = wirelessDevicesToRemove {
            var wirelessDevicesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDevicesToRemove)
            for wirelessdevicelist0 in wirelessDevicesToRemove {
                try wirelessDevicesToRemoveContainer.encode(wirelessdevicelist0)
            }
        }
        if let wirelessGatewaysToAdd = wirelessGatewaysToAdd {
            var wirelessGatewaysToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGatewaysToAdd)
            for wirelessgatewaylist0 in wirelessGatewaysToAdd {
                try wirelessGatewaysToAddContainer.encode(wirelessgatewaylist0)
            }
        }
        if let wirelessGatewaysToRemove = wirelessGatewaysToRemove {
            var wirelessGatewaysToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGatewaysToRemove)
            for wirelessgatewaylist0 in wirelessGatewaysToRemove {
                try wirelessGatewaysToRemoveContainer.encode(wirelessgatewaylist0)
            }
        }
    }
}

extension UpdateNetworkAnalyzerConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationName = configurationName else {
            return nil
        }
        return "/network-analyzer-configurations/\(configurationName.urlPercentEncoding())"
    }
}

public struct UpdateNetworkAnalyzerConfigurationInput: Swift.Equatable {
    /// NetworkAnalyzer configuration name.
    /// This member is required.
    public var configurationName: Swift.String?
    /// Trace Content for resources.
    public var traceContent: IotWirelessClientTypes.TraceContent?
    /// WirelessDevices to add into NetworkAnalyzerConfiguration.
    public var wirelessDevicesToAdd: [Swift.String]?
    /// WirelessDevices to remove from NetworkAnalyzerConfiguration.
    public var wirelessDevicesToRemove: [Swift.String]?
    /// WirelessGateways to add into NetworkAnalyzerConfiguration.
    public var wirelessGatewaysToAdd: [Swift.String]?
    /// WirelessGateways to remove from NetworkAnalyzerConfiguration.
    public var wirelessGatewaysToRemove: [Swift.String]?

    public init (
        configurationName: Swift.String? = nil,
        traceContent: IotWirelessClientTypes.TraceContent? = nil,
        wirelessDevicesToAdd: [Swift.String]? = nil,
        wirelessDevicesToRemove: [Swift.String]? = nil,
        wirelessGatewaysToAdd: [Swift.String]? = nil,
        wirelessGatewaysToRemove: [Swift.String]? = nil
    )
    {
        self.configurationName = configurationName
        self.traceContent = traceContent
        self.wirelessDevicesToAdd = wirelessDevicesToAdd
        self.wirelessDevicesToRemove = wirelessDevicesToRemove
        self.wirelessGatewaysToAdd = wirelessGatewaysToAdd
        self.wirelessGatewaysToRemove = wirelessGatewaysToRemove
    }
}

struct UpdateNetworkAnalyzerConfigurationInputBody: Swift.Equatable {
    let traceContent: IotWirelessClientTypes.TraceContent?
    let wirelessDevicesToAdd: [Swift.String]?
    let wirelessDevicesToRemove: [Swift.String]?
    let wirelessGatewaysToAdd: [Swift.String]?
    let wirelessGatewaysToRemove: [Swift.String]?
}

extension UpdateNetworkAnalyzerConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case traceContent = "TraceContent"
        case wirelessDevicesToAdd = "WirelessDevicesToAdd"
        case wirelessDevicesToRemove = "WirelessDevicesToRemove"
        case wirelessGatewaysToAdd = "WirelessGatewaysToAdd"
        case wirelessGatewaysToRemove = "WirelessGatewaysToRemove"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceContentDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.TraceContent.self, forKey: .traceContent)
        traceContent = traceContentDecoded
        let wirelessDevicesToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessDevicesToAdd)
        var wirelessDevicesToAddDecoded0:[Swift.String]? = nil
        if let wirelessDevicesToAddContainer = wirelessDevicesToAddContainer {
            wirelessDevicesToAddDecoded0 = [Swift.String]()
            for string0 in wirelessDevicesToAddContainer {
                if let string0 = string0 {
                    wirelessDevicesToAddDecoded0?.append(string0)
                }
            }
        }
        wirelessDevicesToAdd = wirelessDevicesToAddDecoded0
        let wirelessDevicesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessDevicesToRemove)
        var wirelessDevicesToRemoveDecoded0:[Swift.String]? = nil
        if let wirelessDevicesToRemoveContainer = wirelessDevicesToRemoveContainer {
            wirelessDevicesToRemoveDecoded0 = [Swift.String]()
            for string0 in wirelessDevicesToRemoveContainer {
                if let string0 = string0 {
                    wirelessDevicesToRemoveDecoded0?.append(string0)
                }
            }
        }
        wirelessDevicesToRemove = wirelessDevicesToRemoveDecoded0
        let wirelessGatewaysToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessGatewaysToAdd)
        var wirelessGatewaysToAddDecoded0:[Swift.String]? = nil
        if let wirelessGatewaysToAddContainer = wirelessGatewaysToAddContainer {
            wirelessGatewaysToAddDecoded0 = [Swift.String]()
            for string0 in wirelessGatewaysToAddContainer {
                if let string0 = string0 {
                    wirelessGatewaysToAddDecoded0?.append(string0)
                }
            }
        }
        wirelessGatewaysToAdd = wirelessGatewaysToAddDecoded0
        let wirelessGatewaysToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .wirelessGatewaysToRemove)
        var wirelessGatewaysToRemoveDecoded0:[Swift.String]? = nil
        if let wirelessGatewaysToRemoveContainer = wirelessGatewaysToRemoveContainer {
            wirelessGatewaysToRemoveDecoded0 = [Swift.String]()
            for string0 in wirelessGatewaysToRemoveContainer {
                if let string0 = string0 {
                    wirelessGatewaysToRemoveDecoded0?.append(string0)
                }
            }
        }
        wirelessGatewaysToRemove = wirelessGatewaysToRemoveDecoded0
    }
}

extension UpdateNetworkAnalyzerConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkAnalyzerConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNetworkAnalyzerConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkAnalyzerConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNetworkAnalyzerConfigurationOutputResponse: Swift.Equatable {

}

extension UpdatePartnerAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }
}

extension UpdatePartnerAccountInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let partnerType = partnerType {
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
        }
        return items
    }
}

extension UpdatePartnerAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let partnerAccountId = partnerAccountId else {
            return nil
        }
        return "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
    }
}

public struct UpdatePartnerAccountInput: Swift.Equatable {
    /// The ID of the partner account to update.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IotWirelessClientTypes.PartnerType?
    /// The Sidewalk account credentials.
    /// This member is required.
    public var sidewalk: IotWirelessClientTypes.SidewalkUpdateAccount?

    public init (
        partnerAccountId: Swift.String? = nil,
        partnerType: IotWirelessClientTypes.PartnerType? = nil,
        sidewalk: IotWirelessClientTypes.SidewalkUpdateAccount? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
        self.sidewalk = sidewalk
    }
}

struct UpdatePartnerAccountInputBody: Swift.Equatable {
    let sidewalk: IotWirelessClientTypes.SidewalkUpdateAccount?
}

extension UpdatePartnerAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkUpdateAccount.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension UpdatePartnerAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePartnerAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePartnerAccountOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePartnerAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePartnerAccountOutputResponse: Swift.Equatable {

}

extension UpdateResourceEventConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceRegistrationState = "DeviceRegistrationState"
        case proximity = "Proximity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceRegistrationState = deviceRegistrationState {
            try encodeContainer.encode(deviceRegistrationState, forKey: .deviceRegistrationState)
        }
        if let proximity = proximity {
            try encodeContainer.encode(proximity, forKey: .proximity)
        }
    }
}

extension UpdateResourceEventConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let partnerType = partnerType {
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            items.append(partnerTypeQueryItem)
        }
        if let identifierType = identifierType {
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            items.append(identifierTypeQueryItem)
        }
        return items
    }
}

extension UpdateResourceEventConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/event-configurations/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateResourceEventConfigurationInput: Swift.Equatable {
    /// Event configuration for the device registration state event
    public var deviceRegistrationState: IotWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    /// Resource identifier to opt in for event messaging.
    /// This member is required.
    public var identifier: Swift.String?
    /// Identifier type of the particular resource identifier for event configuration.
    /// This member is required.
    public var identifierType: IotWirelessClientTypes.IdentifierType?
    /// Partner type of the resource if the identifier type is PartnerAccountId
    public var partnerType: IotWirelessClientTypes.EventNotificationPartnerType?
    /// Event configuration for the Proximity event
    public var proximity: IotWirelessClientTypes.ProximityEventConfiguration?

    public init (
        deviceRegistrationState: IotWirelessClientTypes.DeviceRegistrationStateEventConfiguration? = nil,
        identifier: Swift.String? = nil,
        identifierType: IotWirelessClientTypes.IdentifierType? = nil,
        partnerType: IotWirelessClientTypes.EventNotificationPartnerType? = nil,
        proximity: IotWirelessClientTypes.ProximityEventConfiguration? = nil
    )
    {
        self.deviceRegistrationState = deviceRegistrationState
        self.identifier = identifier
        self.identifierType = identifierType
        self.partnerType = partnerType
        self.proximity = proximity
    }
}

struct UpdateResourceEventConfigurationInputBody: Swift.Equatable {
    let deviceRegistrationState: IotWirelessClientTypes.DeviceRegistrationStateEventConfiguration?
    let proximity: IotWirelessClientTypes.ProximityEventConfiguration?
}

extension UpdateResourceEventConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceRegistrationState = "DeviceRegistrationState"
        case proximity = "Proximity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceRegistrationStateDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.DeviceRegistrationStateEventConfiguration.self, forKey: .deviceRegistrationState)
        deviceRegistrationState = deviceRegistrationStateDecoded
        let proximityDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.ProximityEventConfiguration.self, forKey: .proximity)
        proximity = proximityDecoded
    }
}

extension UpdateResourceEventConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceEventConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceEventConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceEventConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceEventConfigurationOutputResponse: Swift.Equatable {

}

extension UpdateWirelessDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationName = destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateWirelessDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-devices/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWirelessDeviceInput: Swift.Equatable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The name of the new destination for the device.
    public var destinationName: Swift.String?
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The updated wireless device's configuration.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANUpdateDevice?
    /// The new name of the resource.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANUpdateDevice? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.destinationName = destinationName
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct UpdateWirelessDeviceInputBody: Swift.Equatable {
    let destinationName: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let loRaWAN: IotWirelessClientTypes.LoRaWANUpdateDevice?
}

extension UpdateWirelessDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANUpdateDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension UpdateWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWirelessDeviceOutputResponse: Swift.Equatable {

}

extension UpdateWirelessGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case joinEuiFilters = "JoinEuiFilters"
        case name = "Name"
        case netIdFilters = "NetIdFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let joinEuiFilters = joinEuiFilters {
            var joinEuiFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .joinEuiFilters)
            for joineuifilters0 in joinEuiFilters {
                var joineuifilters0Container = joinEuiFiltersContainer.nestedUnkeyedContainer()
                for joineuirange1 in joineuifilters0 {
                    try joineuifilters0Container.encode(joineuirange1)
                }
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let netIdFilters = netIdFilters {
            var netIdFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .netIdFilters)
            for netidfilters0 in netIdFilters {
                try netIdFiltersContainer.encode(netidfilters0)
            }
        }
    }
}

extension UpdateWirelessGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/wireless-gateways/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWirelessGatewayInput: Swift.Equatable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.
    public var joinEuiFilters: [[Swift.String]]?
    /// The new name of the resource.
    public var name: Swift.String?
    /// A list of NetId values that are used by LoRa gateways to filter the uplink frames.
    public var netIdFilters: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        joinEuiFilters: [[Swift.String]]? = nil,
        name: Swift.String? = nil,
        netIdFilters: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.joinEuiFilters = joinEuiFilters
        self.name = name
        self.netIdFilters = netIdFilters
    }
}

struct UpdateWirelessGatewayInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let joinEuiFilters: [[Swift.String]]?
    let netIdFilters: [Swift.String]?
}

extension UpdateWirelessGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case joinEuiFilters = "JoinEuiFilters"
        case name = "Name"
        case netIdFilters = "NetIdFilters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let joinEuiFiltersContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .joinEuiFilters)
        var joinEuiFiltersDecoded0:[[Swift.String]]? = nil
        if let joinEuiFiltersContainer = joinEuiFiltersContainer {
            joinEuiFiltersDecoded0 = [[Swift.String]]()
            for list0 in joinEuiFiltersContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    joinEuiFiltersDecoded0?.append(list0Decoded0)
                }
            }
        }
        joinEuiFilters = joinEuiFiltersDecoded0
        let netIdFiltersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .netIdFilters)
        var netIdFiltersDecoded0:[Swift.String]? = nil
        if let netIdFiltersContainer = netIdFiltersContainer {
            netIdFiltersDecoded0 = [Swift.String]()
            for string0 in netIdFiltersContainer {
                if let string0 = string0 {
                    netIdFiltersDecoded0?.append(string0)
                }
            }
        }
        netIdFilters = netIdFiltersDecoded0
    }
}

extension UpdateWirelessGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWirelessGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWirelessGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWirelessGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWirelessGatewayOutputResponse: Swift.Equatable {

}

extension IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case updateDataRole = "UpdateDataRole"
        case updateDataSource = "UpdateDataSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let updateDataRole = updateDataRole {
            try encodeContainer.encode(updateDataRole, forKey: .updateDataRole)
        }
        if let updateDataSource = updateDataSource {
            try encodeContainer.encode(updateDataSource, forKey: .updateDataSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateDataSource)
        updateDataSource = updateDataSourceDecoded
        let updateDataRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateDataRole)
        updateDataRole = updateDataRoleDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IotWirelessClientTypes {
    /// UpdateWirelessGatewayTaskCreate object.
    public struct UpdateWirelessGatewayTaskCreate: Swift.Equatable {
        /// The properties that relate to the LoRaWAN wireless gateway.
        public var loRaWAN: IotWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate?
        /// The IAM role used to read data from the S3 bucket.
        public var updateDataRole: Swift.String?
        /// The link to the S3 bucket.
        public var updateDataSource: Swift.String?

        public init (
            loRaWAN: IotWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate? = nil,
            updateDataRole: Swift.String? = nil,
            updateDataSource: Swift.String? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.updateDataRole = updateDataRole
            self.updateDataSource = updateDataSource
        }
    }

}

extension IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IotWirelessClientTypes {
    /// UpdateWirelessGatewayTaskEntry object.
    public struct UpdateWirelessGatewayTaskEntry: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the new wireless gateway task entry.
        public var id: Swift.String?
        /// The properties that relate to the LoRaWAN wireless gateway.
        public var loRaWAN: IotWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            loRaWAN: IotWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.loRaWAN = loRaWAN
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input did not meet the specified constraints.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IotWirelessClientTypes {
    /// The event for a log message, if the log message is tied to a wireless device.
    public enum WirelessDeviceEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case downlinkData
        case join
        case registration
        case rejoin
        case uplinkData
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceEvent] {
            return [
                .downlinkData,
                .join,
                .registration,
                .rejoin,
                .uplinkData,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .downlinkData: return "Downlink_Data"
            case .join: return "Join"
            case .registration: return "Registration"
            case .rejoin: return "Rejoin"
            case .uplinkData: return "Uplink_Data"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceEvent(rawValue: rawValue) ?? WirelessDeviceEvent.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.WirelessDeviceEventLogOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event = "Event"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessDeviceEvent.self, forKey: .event)
        event = eventDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IotWirelessClientTypes {
    /// The log options for a wireless device event and can be used to set log levels for a specific wireless device event. For a LoRaWAN device, possible events for a log messsage are: Join, Rejoin, Downlink_Data, and Uplink_Data. For a Sidewalk device, possible events for a log message are Registration, Downlink_Data, and Uplink_Data.
    public struct WirelessDeviceEventLogOption: Swift.Equatable {
        /// The event for a log message, if the log message is tied to a wireless device.
        /// This member is required.
        public var event: IotWirelessClientTypes.WirelessDeviceEvent?
        /// The log level for a log message.
        /// This member is required.
        public var logLevel: IotWirelessClientTypes.LogLevel?

        public init (
            event: IotWirelessClientTypes.WirelessDeviceEvent? = nil,
            logLevel: IotWirelessClientTypes.LogLevel? = nil
        )
        {
            self.event = event
            self.logLevel = logLevel
        }
    }

}

extension IotWirelessClientTypes {
    /// WirelessDevice FrameInfo for trace content.
    public enum WirelessDeviceFrameInfo: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceFrameInfo] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceFrameInfo(rawValue: rawValue) ?? WirelessDeviceFrameInfo.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    public enum WirelessDeviceIdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deveui
        case sidewalkmanufacturingsn
        case thingname
        case wirelessdeviceid
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceIdType] {
            return [
                .deveui,
                .sidewalkmanufacturingsn,
                .thingname,
                .wirelessdeviceid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deveui: return "DevEui"
            case .sidewalkmanufacturingsn: return "SidewalkManufacturingSn"
            case .thingname: return "ThingName"
            case .wirelessdeviceid: return "WirelessDeviceId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceIdType(rawValue: rawValue) ?? WirelessDeviceIdType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.WirelessDeviceLogOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case logLevel = "LogLevel"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for wirelessdeviceeventlogoptionlist0 in events {
                try eventsContainer.encode(wirelessdeviceeventlogoptionlist0)
            }
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let eventsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessDeviceEventLogOption?].self, forKey: .events)
        var eventsDecoded0:[IotWirelessClientTypes.WirelessDeviceEventLogOption]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IotWirelessClientTypes.WirelessDeviceEventLogOption]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension IotWirelessClientTypes {
    /// The log options for wireless devices and can be used to set log levels for a specific type of wireless device.
    public struct WirelessDeviceLogOption: Swift.Equatable {
        /// The list of wireless device event log options.
        public var events: [IotWirelessClientTypes.WirelessDeviceEventLogOption]?
        /// The log level for a log message.
        /// This member is required.
        public var logLevel: IotWirelessClientTypes.LogLevel?
        /// The wireless device type.
        /// This member is required.
        public var type: IotWirelessClientTypes.WirelessDeviceType?

        public init (
            events: [IotWirelessClientTypes.WirelessDeviceEventLogOption]? = nil,
            logLevel: IotWirelessClientTypes.LogLevel? = nil,
            type: IotWirelessClientTypes.WirelessDeviceType? = nil
        )
        {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }
    }

}

extension IotWirelessClientTypes.WirelessDeviceStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case destinationName = "DestinationName"
        case fuotaDeviceStatus = "FuotaDeviceStatus"
        case id = "Id"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case mcGroupId = "McGroupId"
        case multicastDeviceStatus = "MulticastDeviceStatus"
        case name = "Name"
        case sidewalk = "Sidewalk"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationName = destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let fuotaDeviceStatus = fuotaDeviceStatus {
            try encodeContainer.encode(fuotaDeviceStatus.rawValue, forKey: .fuotaDeviceStatus)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUplinkReceivedAt = lastUplinkReceivedAt {
            try encodeContainer.encode(lastUplinkReceivedAt, forKey: .lastUplinkReceivedAt)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let mcGroupId = mcGroupId {
            try encodeContainer.encode(mcGroupId, forKey: .mcGroupId)
        }
        if let multicastDeviceStatus = multicastDeviceStatus {
            try encodeContainer.encode(multicastDeviceStatus, forKey: .multicastDeviceStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANListDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkListDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let fuotaDeviceStatusDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.FuotaDeviceStatus.self, forKey: .fuotaDeviceStatus)
        fuotaDeviceStatus = fuotaDeviceStatusDecoded
        let multicastDeviceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multicastDeviceStatus)
        multicastDeviceStatus = multicastDeviceStatusDecoded
        let mcGroupIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mcGroupId)
        mcGroupId = mcGroupIdDecoded
    }
}

extension IotWirelessClientTypes {
    /// Information about a wireless device's operation.
    public struct WirelessDeviceStatistics: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The name of the destination to which the device is assigned.
        public var destinationName: Swift.String?
        /// The status of a wireless device in a FUOTA task.
        public var fuotaDeviceStatus: IotWirelessClientTypes.FuotaDeviceStatus?
        /// The ID of the wireless device reporting the data.
        public var id: Swift.String?
        /// The date and time when the most recent uplink was received.
        public var lastUplinkReceivedAt: Swift.String?
        /// LoRaWAN device info.
        public var loRaWAN: IotWirelessClientTypes.LoRaWANListDevice?
        /// Id of the multicast group.
        public var mcGroupId: Swift.Int?
        /// The status of the wireless device in the multicast group.
        public var multicastDeviceStatus: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?
        /// The Sidewalk account credentials.
        public var sidewalk: IotWirelessClientTypes.SidewalkListDevice?
        /// The wireless device type.
        public var type: IotWirelessClientTypes.WirelessDeviceType?

        public init (
            arn: Swift.String? = nil,
            destinationName: Swift.String? = nil,
            fuotaDeviceStatus: IotWirelessClientTypes.FuotaDeviceStatus? = nil,
            id: Swift.String? = nil,
            lastUplinkReceivedAt: Swift.String? = nil,
            loRaWAN: IotWirelessClientTypes.LoRaWANListDevice? = nil,
            mcGroupId: Swift.Int? = nil,
            multicastDeviceStatus: Swift.String? = nil,
            name: Swift.String? = nil,
            sidewalk: IotWirelessClientTypes.SidewalkListDevice? = nil,
            type: IotWirelessClientTypes.WirelessDeviceType? = nil
        )
        {
            self.arn = arn
            self.destinationName = destinationName
            self.fuotaDeviceStatus = fuotaDeviceStatus
            self.id = id
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.mcGroupId = mcGroupId
            self.multicastDeviceStatus = multicastDeviceStatus
            self.name = name
            self.sidewalk = sidewalk
            self.type = type
        }
    }

}

extension IotWirelessClientTypes {
    public enum WirelessDeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lorawan
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceType] {
            return [
                .lorawan,
                .sidewalk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lorawan: return "LoRaWAN"
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceType(rawValue: rawValue) ?? WirelessDeviceType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    /// The event for a log message, if the log message is tied to a wireless gateway.
    public enum WirelessGatewayEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cupsRequest
        case certificate
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayEvent] {
            return [
                .cupsRequest,
                .certificate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cupsRequest: return "CUPS_Request"
            case .certificate: return "Certificate"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayEvent(rawValue: rawValue) ?? WirelessGatewayEvent.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.WirelessGatewayEventLogOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event = "Event"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessGatewayEvent.self, forKey: .event)
        event = eventDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IotWirelessClientTypes {
    /// The log options for a wireless gateway event and can be used to set log levels for a specific wireless gateway event. For a LoRaWAN gateway, possible events for a log message are CUPS_Request and Certificate.
    public struct WirelessGatewayEventLogOption: Swift.Equatable {
        /// The event for a log message, if the log message is tied to a wireless gateway.
        /// This member is required.
        public var event: IotWirelessClientTypes.WirelessGatewayEvent?
        /// The log level for a log message.
        /// This member is required.
        public var logLevel: IotWirelessClientTypes.LogLevel?

        public init (
            event: IotWirelessClientTypes.WirelessGatewayEvent? = nil,
            logLevel: IotWirelessClientTypes.LogLevel? = nil
        )
        {
            self.event = event
            self.logLevel = logLevel
        }
    }

}

extension IotWirelessClientTypes {
    public enum WirelessGatewayIdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gatewayeui
        case thingname
        case wirelessgatewayid
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayIdType] {
            return [
                .gatewayeui,
                .thingname,
                .wirelessgatewayid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gatewayeui: return "GatewayEui"
            case .thingname: return "ThingName"
            case .wirelessgatewayid: return "WirelessGatewayId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayIdType(rawValue: rawValue) ?? WirelessGatewayIdType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.WirelessGatewayLogOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case logLevel = "LogLevel"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for wirelessgatewayeventlogoptionlist0 in events {
                try eventsContainer.encode(wirelessgatewayeventlogoptionlist0)
            }
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessGatewayType.self, forKey: .type)
        type = typeDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let eventsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessGatewayEventLogOption?].self, forKey: .events)
        var eventsDecoded0:[IotWirelessClientTypes.WirelessGatewayEventLogOption]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IotWirelessClientTypes.WirelessGatewayEventLogOption]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension IotWirelessClientTypes {
    /// The log options for wireless gateways and can be used to set log levels for a specific type of wireless gateway.
    public struct WirelessGatewayLogOption: Swift.Equatable {
        /// The list of wireless gateway event log options.
        public var events: [IotWirelessClientTypes.WirelessGatewayEventLogOption]?
        /// The log level for a log message.
        /// This member is required.
        public var logLevel: IotWirelessClientTypes.LogLevel?
        /// The wireless gateway type.
        /// This member is required.
        public var type: IotWirelessClientTypes.WirelessGatewayType?

        public init (
            events: [IotWirelessClientTypes.WirelessGatewayEventLogOption]? = nil,
            logLevel: IotWirelessClientTypes.LogLevel? = nil,
            type: IotWirelessClientTypes.WirelessGatewayType? = nil
        )
        {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }
    }

}

extension IotWirelessClientTypes {
    public enum WirelessGatewayServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cups
        case lns
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayServiceType] {
            return [
                .cups,
                .lns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cups: return "CUPS"
            case .lns: return "LNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayServiceType(rawValue: rawValue) ?? WirelessGatewayServiceType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.WirelessGatewayStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUplinkReceivedAt = lastUplinkReceivedAt {
            try encodeContainer.encode(lastUplinkReceivedAt, forKey: .lastUplinkReceivedAt)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
    }
}

extension IotWirelessClientTypes {
    /// Information about a wireless gateway's operation.
    public struct WirelessGatewayStatistics: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The description of the resource.
        public var description: Swift.String?
        /// The ID of the wireless gateway reporting the data.
        public var id: Swift.String?
        /// The date and time when the most recent uplink was received.
        public var lastUplinkReceivedAt: Swift.String?
        /// LoRaWAN gateway info.
        public var loRaWAN: IotWirelessClientTypes.LoRaWANGateway?
        /// The name of the resource.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUplinkReceivedAt: Swift.String? = nil,
            loRaWAN: IotWirelessClientTypes.LoRaWANGateway? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.name = name
        }
    }

}

extension IotWirelessClientTypes {
    public enum WirelessGatewayTaskDefinitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayTaskDefinitionType] {
            return [
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayTaskDefinitionType(rawValue: rawValue) ?? WirelessGatewayTaskDefinitionType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    public enum WirelessGatewayTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case firstRetry
        case inProgress
        case pending
        case secondRetry
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayTaskStatus] {
            return [
                .completed,
                .failed,
                .firstRetry,
                .inProgress,
                .pending,
                .secondRetry,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .firstRetry: return "FIRST_RETRY"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .secondRetry: return "SECOND_RETRY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayTaskStatus(rawValue: rawValue) ?? WirelessGatewayTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    /// The wireless gateway type.
    public enum WirelessGatewayType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lorawan
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayType] {
            return [
                .lorawan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lorawan: return "LoRaWAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayType(rawValue: rawValue) ?? WirelessGatewayType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.WirelessMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANSendDataToDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkSendDataToDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IotWirelessClientTypes {
    /// WirelessMetadata object.
    public struct WirelessMetadata: Swift.Equatable {
        /// LoRaWAN device info.
        public var loRaWAN: IotWirelessClientTypes.LoRaWANSendDataToDevice?
        /// The Sidewalk account credentials.
        public var sidewalk: IotWirelessClientTypes.SidewalkSendDataToDevice?

        public init (
            loRaWAN: IotWirelessClientTypes.LoRaWANSendDataToDevice? = nil,
            sidewalk: IotWirelessClientTypes.SidewalkSendDataToDevice? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.sidewalk = sidewalk
        }
    }

}
