// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListAcceleratorsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAcceleratorsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAcceleratorsOutputResponse`
extension GlobalAcceleratorClient {
    public func listAcceleratorsPaginated(input: ListAcceleratorsInput) -> ClientRuntime.PaginatorSequence<ListAcceleratorsInput, ListAcceleratorsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAcceleratorsInput, ListAcceleratorsOutputResponse>(input: input, inputKey: \ListAcceleratorsInput.nextToken, outputKey: \ListAcceleratorsOutputResponse.nextToken, paginationFunction: self.listAccelerators(input:))
    }
}

extension ListAcceleratorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAcceleratorsInput {
        return ListAcceleratorsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListByoipCidrsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListByoipCidrsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListByoipCidrsOutputResponse`
extension GlobalAcceleratorClient {
    public func listByoipCidrsPaginated(input: ListByoipCidrsInput) -> ClientRuntime.PaginatorSequence<ListByoipCidrsInput, ListByoipCidrsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListByoipCidrsInput, ListByoipCidrsOutputResponse>(input: input, inputKey: \ListByoipCidrsInput.nextToken, outputKey: \ListByoipCidrsOutputResponse.nextToken, paginationFunction: self.listByoipCidrs(input:))
    }
}

extension ListByoipCidrsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListByoipCidrsInput {
        return ListByoipCidrsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListCustomRoutingAcceleratorsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCustomRoutingAcceleratorsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCustomRoutingAcceleratorsOutputResponse`
extension GlobalAcceleratorClient {
    public func listCustomRoutingAcceleratorsPaginated(input: ListCustomRoutingAcceleratorsInput) -> ClientRuntime.PaginatorSequence<ListCustomRoutingAcceleratorsInput, ListCustomRoutingAcceleratorsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCustomRoutingAcceleratorsInput, ListCustomRoutingAcceleratorsOutputResponse>(input: input, inputKey: \ListCustomRoutingAcceleratorsInput.nextToken, outputKey: \ListCustomRoutingAcceleratorsOutputResponse.nextToken, paginationFunction: self.listCustomRoutingAccelerators(input:))
    }
}

extension ListCustomRoutingAcceleratorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomRoutingAcceleratorsInput {
        return ListCustomRoutingAcceleratorsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListCustomRoutingEndpointGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCustomRoutingEndpointGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCustomRoutingEndpointGroupsOutputResponse`
extension GlobalAcceleratorClient {
    public func listCustomRoutingEndpointGroupsPaginated(input: ListCustomRoutingEndpointGroupsInput) -> ClientRuntime.PaginatorSequence<ListCustomRoutingEndpointGroupsInput, ListCustomRoutingEndpointGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCustomRoutingEndpointGroupsInput, ListCustomRoutingEndpointGroupsOutputResponse>(input: input, inputKey: \ListCustomRoutingEndpointGroupsInput.nextToken, outputKey: \ListCustomRoutingEndpointGroupsOutputResponse.nextToken, paginationFunction: self.listCustomRoutingEndpointGroups(input:))
    }
}

extension ListCustomRoutingEndpointGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomRoutingEndpointGroupsInput {
        return ListCustomRoutingEndpointGroupsInput(
            listenerArn: self.listenerArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListCustomRoutingListenersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCustomRoutingListenersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCustomRoutingListenersOutputResponse`
extension GlobalAcceleratorClient {
    public func listCustomRoutingListenersPaginated(input: ListCustomRoutingListenersInput) -> ClientRuntime.PaginatorSequence<ListCustomRoutingListenersInput, ListCustomRoutingListenersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCustomRoutingListenersInput, ListCustomRoutingListenersOutputResponse>(input: input, inputKey: \ListCustomRoutingListenersInput.nextToken, outputKey: \ListCustomRoutingListenersOutputResponse.nextToken, paginationFunction: self.listCustomRoutingListeners(input:))
    }
}

extension ListCustomRoutingListenersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomRoutingListenersInput {
        return ListCustomRoutingListenersInput(
            acceleratorArn: self.acceleratorArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListCustomRoutingPortMappingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCustomRoutingPortMappingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCustomRoutingPortMappingsOutputResponse`
extension GlobalAcceleratorClient {
    public func listCustomRoutingPortMappingsPaginated(input: ListCustomRoutingPortMappingsInput) -> ClientRuntime.PaginatorSequence<ListCustomRoutingPortMappingsInput, ListCustomRoutingPortMappingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCustomRoutingPortMappingsInput, ListCustomRoutingPortMappingsOutputResponse>(input: input, inputKey: \ListCustomRoutingPortMappingsInput.nextToken, outputKey: \ListCustomRoutingPortMappingsOutputResponse.nextToken, paginationFunction: self.listCustomRoutingPortMappings(input:))
    }
}

extension ListCustomRoutingPortMappingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomRoutingPortMappingsInput {
        return ListCustomRoutingPortMappingsInput(
            acceleratorArn: self.acceleratorArn,
            endpointGroupArn: self.endpointGroupArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListCustomRoutingPortMappingsByDestinationOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCustomRoutingPortMappingsByDestinationInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCustomRoutingPortMappingsByDestinationOutputResponse`
extension GlobalAcceleratorClient {
    public func listCustomRoutingPortMappingsByDestinationPaginated(input: ListCustomRoutingPortMappingsByDestinationInput) -> ClientRuntime.PaginatorSequence<ListCustomRoutingPortMappingsByDestinationInput, ListCustomRoutingPortMappingsByDestinationOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCustomRoutingPortMappingsByDestinationInput, ListCustomRoutingPortMappingsByDestinationOutputResponse>(input: input, inputKey: \ListCustomRoutingPortMappingsByDestinationInput.nextToken, outputKey: \ListCustomRoutingPortMappingsByDestinationOutputResponse.nextToken, paginationFunction: self.listCustomRoutingPortMappingsByDestination(input:))
    }
}

extension ListCustomRoutingPortMappingsByDestinationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomRoutingPortMappingsByDestinationInput {
        return ListCustomRoutingPortMappingsByDestinationInput(
            destinationAddress: self.destinationAddress,
            endpointId: self.endpointId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListEndpointGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListEndpointGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListEndpointGroupsOutputResponse`
extension GlobalAcceleratorClient {
    public func listEndpointGroupsPaginated(input: ListEndpointGroupsInput) -> ClientRuntime.PaginatorSequence<ListEndpointGroupsInput, ListEndpointGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEndpointGroupsInput, ListEndpointGroupsOutputResponse>(input: input, inputKey: \ListEndpointGroupsInput.nextToken, outputKey: \ListEndpointGroupsOutputResponse.nextToken, paginationFunction: self.listEndpointGroups(input:))
    }
}

extension ListEndpointGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEndpointGroupsInput {
        return ListEndpointGroupsInput(
            listenerArn: self.listenerArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListListenersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListListenersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListListenersOutputResponse`
extension GlobalAcceleratorClient {
    public func listListenersPaginated(input: ListListenersInput) -> ClientRuntime.PaginatorSequence<ListListenersInput, ListListenersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListListenersInput, ListListenersOutputResponse>(input: input, inputKey: \ListListenersInput.nextToken, outputKey: \ListListenersOutputResponse.nextToken, paginationFunction: self.listListeners(input:))
    }
}

extension ListListenersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListListenersInput {
        return ListListenersInput(
            acceleratorArn: self.acceleratorArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
