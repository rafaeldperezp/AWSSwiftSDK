// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension PiClientTypes.DataPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp = "Timestamp"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension PiClientTypes {
    /// A timestamp, and a single numerical value, which together represent a measurement at a particular point in time.
    public struct DataPoint: Swift.Equatable {
        /// The time, in epoch format, associated with a particular Value.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The actual value associated with a particular Timestamp.
        /// This member is required.
        public var value: Swift.Double?

        public init (
            timestamp: ClientRuntime.Date? = nil,
            value: Swift.Double? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension DescribeDimensionKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case filter = "Filter"
        case groupBy = "GroupBy"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metric = "Metric"
        case nextToken = "NextToken"
        case partitionBy = "PartitionBy"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, metricqueryfiltermap0) in filter {
                try filterContainer.encode(metricqueryfiltermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let groupBy = groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let partitionBy = partitionBy {
            try encodeContainer.encode(partitionBy, forKey: .partitionBy)
        }
        if let periodInSeconds = periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

extension DescribeDimensionKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDimensionKeysInput: Swift.Equatable {
    /// The date and time specifying the end of the requested time series data. The value specified is exclusive, which means that data points less than (but not equal to) EndTime are returned. The value for EndTime must be later than the value for StartTime.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// One or more filters to apply in the request. Restrictions:
    ///
    /// * Any number of filters by the same dimension, as specified in the GroupBy or Partition parameters.
    ///
    /// * A single filter for any other dimension in this dimension group.
    public var filter: [Swift.String:Swift.String]?
    /// A specification for how to aggregate the data points from a query result. You must specify a valid dimension group. Performance Insights returns all dimensions within this group, unless you provide the names of specific dimensions within this group. You can also request that Performance Insights return a limited number of values for a dimension.
    /// This member is required.
    public var groupBy: PiClientTypes.DimensionGroup?
    /// An immutable, AWS Region-unique identifier for a data source. Performance Insights gathers metrics from this data source. To use an Amazon RDS instance as a data source, you specify its DbiResourceId value. For example, specify db-FAIHNTYBKTGAUSUZQYPDS2GW4A
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxRecords value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The name of a Performance Insights metric to be measured. Valid values for Metric are:
    ///
    /// * db.load.avg - a scaled representation of the number of active sessions for the database engine.
    ///
    /// * db.sampledload.avg - the raw number of active sessions for the database engine.
    ///
    ///
    /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
    /// This member is required.
    public var metric: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// For each dimension specified in GroupBy, specify a secondary dimension to further subdivide the partition keys in the response.
    public var partitionBy: PiClientTypes.DimensionGroup?
    /// The granularity, in seconds, of the data points returned from Performance Insights. A period can be as short as one second, or as long as one day (86400 seconds). Valid values are:
    ///
    /// * 1 (one second)
    ///
    /// * 60 (one minute)
    ///
    /// * 300 (five minutes)
    ///
    /// * 3600 (one hour)
    ///
    /// * 86400 (twenty-four hours)
    ///
    ///
    /// If you don't specify PeriodInSeconds, then Performance Insights chooses a value for you, with a goal of returning roughly 100-200 data points in the response.
    public var periodInSeconds: Swift.Int?
    /// The AWS service for which Performance Insights will return metrics. The only valid value for ServiceType is RDS.
    /// This member is required.
    public var serviceType: PiClientTypes.ServiceType?
    /// The date and time specifying the beginning of the requested time series data. You must specify a StartTime within the past 7 days. The value specified is inclusive, which means that data points equal to or greater than StartTime are returned. The value for StartTime must be earlier than the value for EndTime.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        filter: [Swift.String:Swift.String]? = nil,
        groupBy: PiClientTypes.DimensionGroup? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metric: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        partitionBy: PiClientTypes.DimensionGroup? = nil,
        periodInSeconds: Swift.Int? = nil,
        serviceType: PiClientTypes.ServiceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.filter = filter
        self.groupBy = groupBy
        self.identifier = identifier
        self.maxResults = maxResults
        self.metric = metric
        self.nextToken = nextToken
        self.partitionBy = partitionBy
        self.periodInSeconds = periodInSeconds
        self.serviceType = serviceType
        self.startTime = startTime
    }
}

struct DescribeDimensionKeysInputBody: Swift.Equatable {
    let serviceType: PiClientTypes.ServiceType?
    let identifier: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let metric: Swift.String?
    let periodInSeconds: Swift.Int?
    let groupBy: PiClientTypes.DimensionGroup?
    let partitionBy: PiClientTypes.DimensionGroup?
    let filter: [Swift.String:Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeDimensionKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case filter = "Filter"
        case groupBy = "GroupBy"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metric = "Metric"
        case nextToken = "NextToken"
        case partitionBy = "PartitionBy"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PiClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(PiClientTypes.DimensionGroup.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let partitionByDecoded = try containerValues.decodeIfPresent(PiClientTypes.DimensionGroup.self, forKey: .partitionBy)
        partitionBy = partitionByDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:Swift.String]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in filterContainer {
                if let requeststring0 = requeststring0 {
                    filterDecoded0?[key0] = requeststring0
                }
            }
        }
        filter = filterDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDimensionKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDimensionKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDimensionKeysOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDimensionKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDimensionKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alignedEndTime = output.alignedEndTime
            self.alignedStartTime = output.alignedStartTime
            self.keys = output.keys
            self.nextToken = output.nextToken
            self.partitionKeys = output.partitionKeys
        } else {
            self.alignedEndTime = nil
            self.alignedStartTime = nil
            self.keys = nil
            self.nextToken = nil
            self.partitionKeys = nil
        }
    }
}

public struct DescribeDimensionKeysOutputResponse: Swift.Equatable {
    /// The end time for the returned dimension keys, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedEndTime will be greater than or equal to the value of the user-specified Endtime.
    public var alignedEndTime: ClientRuntime.Date?
    /// The start time for the returned dimension keys, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedStartTime will be less than or equal to the value of the user-specified StartTime.
    public var alignedStartTime: ClientRuntime.Date?
    /// The dimension keys that were requested.
    public var keys: [PiClientTypes.DimensionKeyDescription]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// If PartitionBy was present in the request, PartitionKeys contains the breakdown of dimension keys by the specified partitions.
    public var partitionKeys: [PiClientTypes.ResponsePartitionKey]?

    public init (
        alignedEndTime: ClientRuntime.Date? = nil,
        alignedStartTime: ClientRuntime.Date? = nil,
        keys: [PiClientTypes.DimensionKeyDescription]? = nil,
        nextToken: Swift.String? = nil,
        partitionKeys: [PiClientTypes.ResponsePartitionKey]? = nil
    )
    {
        self.alignedEndTime = alignedEndTime
        self.alignedStartTime = alignedStartTime
        self.keys = keys
        self.nextToken = nextToken
        self.partitionKeys = partitionKeys
    }
}

struct DescribeDimensionKeysOutputResponseBody: Swift.Equatable {
    let alignedStartTime: ClientRuntime.Date?
    let alignedEndTime: ClientRuntime.Date?
    let partitionKeys: [PiClientTypes.ResponsePartitionKey]?
    let keys: [PiClientTypes.DimensionKeyDescription]?
    let nextToken: Swift.String?
}

extension DescribeDimensionKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alignedEndTime = "AlignedEndTime"
        case alignedStartTime = "AlignedStartTime"
        case keys = "Keys"
        case nextToken = "NextToken"
        case partitionKeys = "PartitionKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alignedStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .alignedStartTime)
        alignedStartTime = alignedStartTimeDecoded
        let alignedEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .alignedEndTime)
        alignedEndTime = alignedEndTimeDecoded
        let partitionKeysContainer = try containerValues.decodeIfPresent([PiClientTypes.ResponsePartitionKey?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[PiClientTypes.ResponsePartitionKey]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [PiClientTypes.ResponsePartitionKey]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let keysContainer = try containerValues.decodeIfPresent([PiClientTypes.DimensionKeyDescription?].self, forKey: .keys)
        var keysDecoded0:[PiClientTypes.DimensionKeyDescription]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [PiClientTypes.DimensionKeyDescription]()
            for structure0 in keysContainer {
                if let structure0 = structure0 {
                    keysDecoded0?.append(structure0)
                }
            }
        }
        keys = keysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PiClientTypes {
    public enum DetailStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case processing
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [DetailStatus] {
            return [
                .available,
                .processing,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .processing: return "PROCESSING"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetailStatus(rawValue: rawValue) ?? DetailStatus.sdkUnknown(rawValue)
        }
    }
}

extension PiClientTypes.DimensionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case group = "Group"
        case limit = "Limit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for requeststringlist0 in dimensions {
                try dimensionsContainer.encode(requeststringlist0)
            }
        }
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0:[Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String]()
            for string0 in dimensionsContainer {
                if let string0 = string0 {
                    dimensionsDecoded0?.append(string0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension PiClientTypes {
    /// A logical grouping of Performance Insights metrics for a related subject area. For example, the db.sql dimension group consists of the following dimensions: db.sql.id, db.sql.db_id, db.sql.statement, and db.sql.tokenized_id. Each response element returns a maximum of 500 bytes. For larger elements, such as SQL statements, only the first 500 bytes are returned.
    public struct DimensionGroup: Swift.Equatable {
        /// A list of specific dimensions from a dimension group. If this parameter is not present, then it signifies that all of the dimensions in the group were requested, or are present in the response. Valid values for elements in the Dimensions array are:
        ///
        /// * db.application.name - The name of the application that is connected to the database (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.host.id - The host ID of the connected client (all engines)
        ///
        /// * db.host.name - The host name of the connected client (all engines)
        ///
        /// * db.name - The name of the database to which the client is connected (only Aurora PostgreSQL, RDS PostgreSQL, Aurora MySQL, RDS MySQL, and MariaDB)
        ///
        /// * db.session_type.name - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.sql.id - The SQL ID generated by Performance Insights (all engines)
        ///
        /// * db.sql.db_id - The SQL ID generated by the database (all engines)
        ///
        /// * db.sql.statement - The SQL text that is being executed (all engines)
        ///
        /// * db.sql.tokenized_id
        ///
        /// * db.sql_tokenized.id - The SQL digest ID generated by Performance Insights (all engines)
        ///
        /// * db.sql_tokenized.db_id - SQL digest ID generated by the database (all engines)
        ///
        /// * db.sql_tokenized.statement - The SQL digest text (all engines)
        ///
        /// * db.user.id - The ID of the user logged in to the database (all engines)
        ///
        /// * db.user.name - The name of the user logged in to the database (all engines)
        ///
        /// * db.wait_event.name - The event for which the backend is waiting (all engines)
        ///
        /// * db.wait_event.type - The type of event for which the backend is waiting (all engines)
        ///
        /// * db.wait_event_type.name - The name of the event type for which the backend is waiting (all engines)
        public var dimensions: [Swift.String]?
        /// The name of the dimension group. Valid values are:
        ///
        /// * db - The name of the database to which the client is connected (only Aurora PostgreSQL, RDS PostgreSQL, Aurora MySQL, RDS MySQL, and MariaDB)
        ///
        /// * db.application - The name of the application that is connected to the database (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.host - The host name of the connected client (all engines)
        ///
        /// * db.session_type - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.sql - The SQL that is currently executing (all engines)
        ///
        /// * db.sql_tokenized - The SQL digest (all engines)
        ///
        /// * db.wait_event - The event for which the database backend is waiting (all engines)
        ///
        /// * db.wait_event_type - The type of event for which the database backend is waiting (all engines)
        ///
        /// * db.user - The user logged in to the database (all engines)
        /// This member is required.
        public var group: Swift.String?
        /// The maximum number of items to fetch for this dimension group.
        public var limit: Swift.Int?

        public init (
            dimensions: [Swift.String]? = nil,
            group: Swift.String? = nil,
            limit: Swift.Int? = nil
        )
        {
            self.dimensions = dimensions
            self.group = group
            self.limit = limit
        }
    }

}

extension PiClientTypes.DimensionKeyDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case partitions = "Partitions"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionmap0) in dimensions {
                try dimensionsContainer.encode(dimensionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let partitions = partitions {
            var partitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitions)
            for metricvalueslist0 in partitions {
                try partitionsContainer.encode(metricvalueslist0)
            }
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .total)
        total = totalDecoded
        let partitionsContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .partitions)
        var partitionsDecoded0:[Swift.Double]? = nil
        if let partitionsContainer = partitionsContainer {
            partitionsDecoded0 = [Swift.Double]()
            for double0 in partitionsContainer {
                if let double0 = double0 {
                    partitionsDecoded0?.append(double0)
                }
            }
        }
        partitions = partitionsDecoded0
    }
}

extension PiClientTypes {
    /// An array of descriptions and aggregated values for each dimension within a dimension group.
    public struct DimensionKeyDescription: Swift.Equatable {
        /// A map of name-value pairs for the dimensions in the group.
        public var dimensions: [Swift.String:Swift.String]?
        /// If PartitionBy was specified, PartitionKeys contains the dimensions that were.
        public var partitions: [Swift.Double]?
        /// The aggregated metric value for the dimension(s), over the requested time range.
        public var total: Swift.Double?

        public init (
            dimensions: [Swift.String:Swift.String]? = nil,
            partitions: [Swift.Double]? = nil,
            total: Swift.Double? = nil
        )
        {
            self.dimensions = dimensions
            self.partitions = partitions
            self.total = total
        }
    }

}

extension PiClientTypes.DimensionKeyDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimension = "Dimension"
        case status = "Status"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimension = dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PiClientTypes.DetailStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension PiClientTypes {
    /// An object that describes the details for a specified dimension.
    public struct DimensionKeyDetail: Swift.Equatable {
        /// The full name of the dimension. The full name includes the group name and key name. The only valid value is db.sql.statement.
        public var dimension: Swift.String?
        /// The status of the dimension detail data. Possible values include the following:
        ///
        /// * AVAILABLE - The dimension detail data is ready to be retrieved.
        ///
        /// * PROCESSING - The dimension detail data isn't ready to be retrieved because more processing time is required. If the requested detail data for db.sql.statement has the status PROCESSING, Performance Insights returns the truncated query.
        ///
        /// * UNAVAILABLE - The dimension detail data could not be collected successfully.
        public var status: PiClientTypes.DetailStatus?
        /// The value of the dimension detail data. For the db.sql.statement dimension, this value is either the full or truncated SQL query, depending on the return status.
        public var value: Swift.String?

        public init (
            dimension: Swift.String? = nil,
            status: PiClientTypes.DetailStatus? = nil,
            value: Swift.String? = nil
        )
        {
            self.dimension = dimension
            self.status = status
            self.value = value
        }
    }

}

extension GetDimensionKeyDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case groupIdentifier = "GroupIdentifier"
        case identifier = "Identifier"
        case requestedDimensions = "RequestedDimensions"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let groupIdentifier = groupIdentifier {
            try encodeContainer.encode(groupIdentifier, forKey: .groupIdentifier)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let requestedDimensions = requestedDimensions {
            var requestedDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requestedDimensions)
            for requesteddimensionlist0 in requestedDimensions {
                try requestedDimensionsContainer.encode(requesteddimensionlist0)
            }
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

extension GetDimensionKeyDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDimensionKeyDetailsInput: Swift.Equatable {
    /// The name of the dimension group. The only valid value is db.sql. Performance Insights searches the specified group for the dimension group ID.
    /// This member is required.
    public var group: Swift.String?
    /// The ID of the dimension group from which to retrieve dimension details. For dimension group db.sql, the group ID is db.sql.id.
    /// This member is required.
    public var groupIdentifier: Swift.String?
    /// The ID for a data source from which to gather dimension data. This ID must be immutable and unique within an AWS Region. When a DB instance is the data source, specify its DbiResourceId value. For example, specify db-ABCDEFGHIJKLMNOPQRSTU1VW2X.
    /// This member is required.
    public var identifier: Swift.String?
    /// A list of dimensions to retrieve the detail data for within the given dimension group. For the dimension group db.sql, specify either the full dimension name db.sql.statement or the short dimension name statement. If you don't specify this parameter, Performance Insights returns all dimension data within the specified dimension group.
    public var requestedDimensions: [Swift.String]?
    /// The AWS service for which Performance Insights returns data. The only valid value is RDS.
    /// This member is required.
    public var serviceType: PiClientTypes.ServiceType?

    public init (
        group: Swift.String? = nil,
        groupIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        requestedDimensions: [Swift.String]? = nil,
        serviceType: PiClientTypes.ServiceType? = nil
    )
    {
        self.group = group
        self.groupIdentifier = groupIdentifier
        self.identifier = identifier
        self.requestedDimensions = requestedDimensions
        self.serviceType = serviceType
    }
}

struct GetDimensionKeyDetailsInputBody: Swift.Equatable {
    let serviceType: PiClientTypes.ServiceType?
    let identifier: Swift.String?
    let group: Swift.String?
    let groupIdentifier: Swift.String?
    let requestedDimensions: [Swift.String]?
}

extension GetDimensionKeyDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case groupIdentifier = "GroupIdentifier"
        case identifier = "Identifier"
        case requestedDimensions = "RequestedDimensions"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PiClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let groupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupIdentifier)
        groupIdentifier = groupIdentifierDecoded
        let requestedDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requestedDimensions)
        var requestedDimensionsDecoded0:[Swift.String]? = nil
        if let requestedDimensionsContainer = requestedDimensionsContainer {
            requestedDimensionsDecoded0 = [Swift.String]()
            for string0 in requestedDimensionsContainer {
                if let string0 = string0 {
                    requestedDimensionsDecoded0?.append(string0)
                }
            }
        }
        requestedDimensions = requestedDimensionsDecoded0
    }
}

extension GetDimensionKeyDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDimensionKeyDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDimensionKeyDetailsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDimensionKeyDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDimensionKeyDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dimensions = output.dimensions
        } else {
            self.dimensions = nil
        }
    }
}

public struct GetDimensionKeyDetailsOutputResponse: Swift.Equatable {
    /// The details for the requested dimensions.
    public var dimensions: [PiClientTypes.DimensionKeyDetail]?

    public init (
        dimensions: [PiClientTypes.DimensionKeyDetail]? = nil
    )
    {
        self.dimensions = dimensions
    }
}

struct GetDimensionKeyDetailsOutputResponseBody: Swift.Equatable {
    let dimensions: [PiClientTypes.DimensionKeyDetail]?
}

extension GetDimensionKeyDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([PiClientTypes.DimensionKeyDetail?].self, forKey: .dimensions)
        var dimensionsDecoded0:[PiClientTypes.DimensionKeyDetail]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [PiClientTypes.DimensionKeyDetail]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension GetResourceMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricQueries = "MetricQueries"
        case nextToken = "NextToken"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metricQueries = metricQueries {
            var metricQueriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricQueries)
            for metricquerylist0 in metricQueries {
                try metricQueriesContainer.encode(metricquerylist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let periodInSeconds = periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

extension GetResourceMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourceMetricsInput: Swift.Equatable {
    /// The date and time specifying the end of the requested time series data. The value specified is exclusive - data points less than (but not equal to) EndTime will be returned. The value for EndTime must be later than the value for StartTime.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// An immutable, AWS Region-unique identifier for a data source. Performance Insights gathers metrics from this data source. To use a DB instance as a data source, specify its DbiResourceId value. For example, specify db-FAIHNTYBKTGAUSUZQYPDS2GW4A.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of items to return in the response. If more items exist than the specified MaxRecords value, a pagination token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An array of one or more queries to perform. Each query must specify a Performance Insights metric, and can optionally specify aggregation and filtering criteria.
    /// This member is required.
    public var metricQueries: [PiClientTypes.MetricQuery]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?
    /// The granularity, in seconds, of the data points returned from Performance Insights. A period can be as short as one second, or as long as one day (86400 seconds). Valid values are:
    ///
    /// * 1 (one second)
    ///
    /// * 60 (one minute)
    ///
    /// * 300 (five minutes)
    ///
    /// * 3600 (one hour)
    ///
    /// * 86400 (twenty-four hours)
    ///
    ///
    /// If you don't specify PeriodInSeconds, then Performance Insights will choose a value for you, with a goal of returning roughly 100-200 data points in the response.
    public var periodInSeconds: Swift.Int?
    /// The AWS service for which Performance Insights returns metrics. The only valid value for ServiceType is RDS.
    /// This member is required.
    public var serviceType: PiClientTypes.ServiceType?
    /// The date and time specifying the beginning of the requested time series data. You can't specify a StartTime that's earlier than 7 days ago. The value specified is inclusive - data points equal to or greater than StartTime will be returned. The value for StartTime must be earlier than the value for EndTime.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metricQueries: [PiClientTypes.MetricQuery]? = nil,
        nextToken: Swift.String? = nil,
        periodInSeconds: Swift.Int? = nil,
        serviceType: PiClientTypes.ServiceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.identifier = identifier
        self.maxResults = maxResults
        self.metricQueries = metricQueries
        self.nextToken = nextToken
        self.periodInSeconds = periodInSeconds
        self.serviceType = serviceType
        self.startTime = startTime
    }
}

struct GetResourceMetricsInputBody: Swift.Equatable {
    let serviceType: PiClientTypes.ServiceType?
    let identifier: Swift.String?
    let metricQueries: [PiClientTypes.MetricQuery]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let periodInSeconds: Swift.Int?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetResourceMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricQueries = "MetricQueries"
        case nextToken = "NextToken"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(PiClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricQueriesContainer = try containerValues.decodeIfPresent([PiClientTypes.MetricQuery?].self, forKey: .metricQueries)
        var metricQueriesDecoded0:[PiClientTypes.MetricQuery]? = nil
        if let metricQueriesContainer = metricQueriesContainer {
            metricQueriesDecoded0 = [PiClientTypes.MetricQuery]()
            for structure0 in metricQueriesContainer {
                if let structure0 = structure0 {
                    metricQueriesDecoded0?.append(structure0)
                }
            }
        }
        metricQueries = metricQueriesDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceMetricsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceMetricsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceMetricsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alignedEndTime = output.alignedEndTime
            self.alignedStartTime = output.alignedStartTime
            self.identifier = output.identifier
            self.metricList = output.metricList
            self.nextToken = output.nextToken
        } else {
            self.alignedEndTime = nil
            self.alignedStartTime = nil
            self.identifier = nil
            self.metricList = nil
            self.nextToken = nil
        }
    }
}

public struct GetResourceMetricsOutputResponse: Swift.Equatable {
    /// The end time for the returned metrics, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedEndTime will be greater than or equal to the value of the user-specified Endtime.
    public var alignedEndTime: ClientRuntime.Date?
    /// The start time for the returned metrics, after alignment to a granular boundary (as specified by PeriodInSeconds). AlignedStartTime will be less than or equal to the value of the user-specified StartTime.
    public var alignedStartTime: ClientRuntime.Date?
    /// An immutable, AWS Region-unique identifier for a data source. Performance Insights gathers metrics from this data source. To use a DB instance as a data source, you specify its DbiResourceId value - for example: db-FAIHNTYBKTGAUSUZQYPDS2GW4A
    public var identifier: Swift.String?
    /// An array of metric results,, where each array element contains all of the data points for a particular dimension.
    public var metricList: [PiClientTypes.MetricKeyDataPoints]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the token, up to the value specified by MaxRecords.
    public var nextToken: Swift.String?

    public init (
        alignedEndTime: ClientRuntime.Date? = nil,
        alignedStartTime: ClientRuntime.Date? = nil,
        identifier: Swift.String? = nil,
        metricList: [PiClientTypes.MetricKeyDataPoints]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alignedEndTime = alignedEndTime
        self.alignedStartTime = alignedStartTime
        self.identifier = identifier
        self.metricList = metricList
        self.nextToken = nextToken
    }
}

struct GetResourceMetricsOutputResponseBody: Swift.Equatable {
    let alignedStartTime: ClientRuntime.Date?
    let alignedEndTime: ClientRuntime.Date?
    let identifier: Swift.String?
    let metricList: [PiClientTypes.MetricKeyDataPoints]?
    let nextToken: Swift.String?
}

extension GetResourceMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alignedEndTime = "AlignedEndTime"
        case alignedStartTime = "AlignedStartTime"
        case identifier = "Identifier"
        case metricList = "MetricList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alignedStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .alignedStartTime)
        alignedStartTime = alignedStartTimeDecoded
        let alignedEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .alignedEndTime)
        alignedEndTime = alignedEndTimeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricListContainer = try containerValues.decodeIfPresent([PiClientTypes.MetricKeyDataPoints?].self, forKey: .metricList)
        var metricListDecoded0:[PiClientTypes.MetricKeyDataPoints]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [PiClientTypes.MetricKeyDataPoints]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed due to an unknown error.
public struct InternalServiceError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the arguments provided is invalid for this request.
public struct InvalidArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PiClientTypes.MetricKeyDataPoints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPoints = "DataPoints"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPoints = dataPoints {
            var dataPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataPoints)
            for datapointslist0 in dataPoints {
                try dataPointsContainer.encode(datapointslist0)
            }
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(PiClientTypes.ResponseResourceMetricKey.self, forKey: .key)
        key = keyDecoded
        let dataPointsContainer = try containerValues.decodeIfPresent([PiClientTypes.DataPoint?].self, forKey: .dataPoints)
        var dataPointsDecoded0:[PiClientTypes.DataPoint]? = nil
        if let dataPointsContainer = dataPointsContainer {
            dataPointsDecoded0 = [PiClientTypes.DataPoint]()
            for structure0 in dataPointsContainer {
                if let structure0 = structure0 {
                    dataPointsDecoded0?.append(structure0)
                }
            }
        }
        dataPoints = dataPointsDecoded0
    }
}

extension PiClientTypes {
    /// A time-ordered series of data points, corresponding to a dimension of a Performance Insights metric.
    public struct MetricKeyDataPoints: Swift.Equatable {
        /// An array of timestamp-value pairs, representing measurements over a period of time.
        public var dataPoints: [PiClientTypes.DataPoint]?
        /// The dimension(s) to which the data points apply.
        public var key: PiClientTypes.ResponseResourceMetricKey?

        public init (
            dataPoints: [PiClientTypes.DataPoint]? = nil,
            key: PiClientTypes.ResponseResourceMetricKey? = nil
        )
        {
            self.dataPoints = dataPoints
            self.key = key
        }
    }

}

extension PiClientTypes.MetricQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case groupBy = "GroupBy"
        case metric = "Metric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, metricqueryfiltermap0) in filter {
                try filterContainer.encode(metricqueryfiltermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let groupBy = groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(PiClientTypes.DimensionGroup.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:Swift.String]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in filterContainer {
                if let requeststring0 = requeststring0 {
                    filterDecoded0?[key0] = requeststring0
                }
            }
        }
        filter = filterDecoded0
    }
}

extension PiClientTypes {
    /// A single query to be processed. You must provide the metric to query. If no other parameters are specified, Performance Insights returns all of the data points for that metric. You can optionally request that the data points be aggregated by dimension group ( GroupBy), and return only those data points that match your criteria (Filter).
    public struct MetricQuery: Swift.Equatable {
        /// One or more filters to apply in the request. Restrictions:
        ///
        /// * Any number of filters by the same dimension, as specified in the GroupBy parameter.
        ///
        /// * A single filter for any other dimension in this dimension group.
        public var filter: [Swift.String:Swift.String]?
        /// A specification for how to aggregate the data points from a query result. You must specify a valid dimension group. Performance Insights will return all of the dimensions within that group, unless you provide the names of specific dimensions within that group. You can also request that Performance Insights return a limited number of values for a dimension.
        public var groupBy: PiClientTypes.DimensionGroup?
        /// The name of a Performance Insights metric to be measured. Valid values for Metric are:
        ///
        /// * db.load.avg - a scaled representation of the number of active sessions for the database engine.
        ///
        /// * db.sampledload.avg - the raw number of active sessions for the database engine.
        ///
        ///
        /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
        /// This member is required.
        public var metric: Swift.String?

        public init (
            filter: [Swift.String:Swift.String]? = nil,
            groupBy: PiClientTypes.DimensionGroup? = nil,
            metric: Swift.String? = nil
        )
        {
            self.filter = filter
            self.groupBy = groupBy
            self.metric = metric
        }
    }

}

extension NotAuthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user is not authorized to perform this request.
public struct NotAuthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PiClientTypes.ResponsePartitionKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionmap0) in dimensions {
                try dimensionsContainer.encode(dimensionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension PiClientTypes {
    /// If PartitionBy was specified in a DescribeDimensionKeys request, the dimensions are returned in an array. Each element in the array specifies one dimension.
    public struct ResponsePartitionKey: Swift.Equatable {
        /// A dimension map that contains the dimension(s) for this partition.
        /// This member is required.
        public var dimensions: [Swift.String:Swift.String]?

        public init (
            dimensions: [Swift.String:Swift.String]? = nil
        )
        {
            self.dimensions = dimensions
        }
    }

}

extension PiClientTypes.ResponseResourceMetricKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case metric = "Metric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dimensions)
            for (dictKey0, dimensionmap0) in dimensions {
                try dimensionsContainer.encode(dimensionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension PiClientTypes {
    /// An object describing a Performance Insights metric and one or more dimensions for that metric.
    public struct ResponseResourceMetricKey: Swift.Equatable {
        /// The valid dimensions for the metric.
        public var dimensions: [Swift.String:Swift.String]?
        /// The name of a Performance Insights metric to be measured. Valid values for Metric are:
        ///
        /// * db.load.avg - a scaled representation of the number of active sessions for the database engine.
        ///
        /// * db.sampledload.avg - the raw number of active sessions for the database engine.
        ///
        ///
        /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
        /// This member is required.
        public var metric: Swift.String?

        public init (
            dimensions: [Swift.String:Swift.String]? = nil,
            metric: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.metric = metric
        }
    }

}

extension PiClientTypes {
    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rds
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .rds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rds: return "RDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
        }
    }
}
