// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ForecastClientTypes.AdditionalDataset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configuration)
            for (dictKey0, configuration0) in configuration {
                try configurationContainer.encode(configuration0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configurationContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .configuration)
        var configurationDecoded0: [Swift.String:[Swift.String]]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, values0) in configurationContainer {
                var values0Decoded0: [Swift.String]? = nil
                if let values0 = values0 {
                    values0Decoded0 = [Swift.String]()
                    for string1 in values0 {
                        if let string1 = string1 {
                            values0Decoded0?.append(string1)
                        }
                    }
                }
                configurationDecoded0?[key0] = values0Decoded0
            }
        }
        configuration = configurationDecoded0
    }
}

extension ForecastClientTypes {
    /// Describes an additional dataset. This object is part of the [DataConfig] object. Forecast supports the Weather Index and Holidays additional datasets. Weather Index The Amazon Forecast Weather Index is a built-in dataset that incorporates historical and projected weather information into your model. The Weather Index supplements your datasets with over two years of historical weather data and up to 14 days of projected weather data. For more information, see [Amazon Forecast Weather Index](https://docs.aws.amazon.com/forecast/latest/dg/weather.html). Holidays Holidays is a built-in dataset that incorporates national holiday information into your model. It provides native support for the holiday calendars of 66 countries. To view the holiday calendars, refer to the [Jollyday](http://jollyday.sourceforge.net/data.html) library. For more information, see [Holidays Featurization](https://docs.aws.amazon.com/forecast/latest/dg/holidays.html).
    public struct AdditionalDataset: Swift.Equatable {
        /// Weather Index To enable the Weather Index, do not specify a value for Configuration. Holidays To enable Holidays, specify a country with one of the following two-letter country codes:
        ///
        /// * "AL" - ALBANIA
        ///
        /// * "AR" - ARGENTINA
        ///
        /// * "AT" - AUSTRIA
        ///
        /// * "AU" - AUSTRALIA
        ///
        /// * "BA" - BOSNIA HERZEGOVINA
        ///
        /// * "BE" - BELGIUM
        ///
        /// * "BG" - BULGARIA
        ///
        /// * "BO" - BOLIVIA
        ///
        /// * "BR" - BRAZIL
        ///
        /// * "BY" - BELARUS
        ///
        /// * "CA" - CANADA
        ///
        /// * "CL" - CHILE
        ///
        /// * "CO" - COLOMBIA
        ///
        /// * "CR" - COSTA RICA
        ///
        /// * "HR" - CROATIA
        ///
        /// * "CZ" - CZECH REPUBLIC
        ///
        /// * "DK" - DENMARK
        ///
        /// * "EC" - ECUADOR
        ///
        /// * "EE" - ESTONIA
        ///
        /// * "ET" - ETHIOPIA
        ///
        /// * "FI" - FINLAND
        ///
        /// * "FR" - FRANCE
        ///
        /// * "DE" - GERMANY
        ///
        /// * "GR" - GREECE
        ///
        /// * "HU" - HUNGARY
        ///
        /// * "IS" - ICELAND
        ///
        /// * "IN" - INDIA
        ///
        /// * "IE" - IRELAND
        ///
        /// * "IT" - ITALY
        ///
        /// * "JP" - JAPAN
        ///
        /// * "KZ" - KAZAKHSTAN
        ///
        /// * "KR" - KOREA
        ///
        /// * "LV" - LATVIA
        ///
        /// * "LI" - LIECHTENSTEIN
        ///
        /// * "LT" - LITHUANIA
        ///
        /// * "LU" - LUXEMBOURG
        ///
        /// * "MK" - MACEDONIA
        ///
        /// * "MT" - MALTA
        ///
        /// * "MX" - MEXICO
        ///
        /// * "MD" - MOLDOVA
        ///
        /// * "ME" - MONTENEGRO
        ///
        /// * "NL" - NETHERLANDS
        ///
        /// * "NZ" - NEW ZEALAND
        ///
        /// * "NI" - NICARAGUA
        ///
        /// * "NG" - NIGERIA
        ///
        /// * "NO" - NORWAY
        ///
        /// * "PA" - PANAMA
        ///
        /// * "PY" - PARAGUAY
        ///
        /// * "PE" - PERU
        ///
        /// * "PL" - POLAND
        ///
        /// * "PT" - PORTUGAL
        ///
        /// * "RO" - ROMANIA
        ///
        /// * "RU" - RUSSIA
        ///
        /// * "RS" - SERBIA
        ///
        /// * "SK" - SLOVAKIA
        ///
        /// * "SI" - SLOVENIA
        ///
        /// * "ZA" - SOUTH AFRICA
        ///
        /// * "ES" - SPAIN
        ///
        /// * "SE" - SWEDEN
        ///
        /// * "CH" - SWITZERLAND
        ///
        /// * "UA" - UKRAINE
        ///
        /// * "AE" - UNITED ARAB EMIRATES
        ///
        /// * "US" - UNITED STATES
        ///
        /// * "UK" - UNITED KINGDOM
        ///
        /// * "UY" - URUGUAY
        ///
        /// * "VE" - VENEZUELA
        public var configuration: [Swift.String:[Swift.String]]?
        /// The name of the additional dataset. Valid names: "holiday" and "weather".
        /// This member is required.
        public var name: Swift.String?

        public init (
            configuration: [Swift.String:[Swift.String]]? = nil,
            name: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.name = name
        }
    }

}

extension ForecastClientTypes.AttributeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case transformations = "Transformations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let transformations = transformations {
            var transformationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .transformations)
            for (dictKey0, transformations0) in transformations {
                try transformationsContainer.encode(transformations0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let transformationsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .transformations)
        var transformationsDecoded0: [Swift.String:Swift.String]? = nil
        if let transformationsContainer = transformationsContainer {
            transformationsDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in transformationsContainer {
                if let value0 = value0 {
                    transformationsDecoded0?[key0] = value0
                }
            }
        }
        transformations = transformationsDecoded0
    }
}

extension ForecastClientTypes {
    /// Provides information about the method used to transform attributes. The following is an example using the RETAIL domain: {
    ///     "AttributeName": "demand",
    ///
    ///
    ///     "Transformations": {"aggregation": "sum", "middlefill": "zero", "backfill": "zero"}
    ///
    ///
    ///     }
    public struct AttributeConfig: Swift.Equatable {
        /// The name of the attribute as specified in the schema. Amazon Forecast supports the target field of the target time series and the related time series datasets. For example, for the RETAIL domain, the target is demand.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters. The following list shows the parameters and their valid values for the "filling" featurization method for a Target Time Series dataset. Default values are bolded.
        ///
        /// * aggregation: sum, avg, first, min, max
        ///
        /// * frontfill: none
        ///
        /// * middlefill: zero, nan (not a number), value, median, mean, min, max
        ///
        /// * backfill: zero, nan, value, median, mean, min, max
        ///
        ///
        /// The following list shows the parameters and their valid values for a Related Time Series featurization method (there are no defaults):
        ///
        /// * middlefill: zero, value, median, mean, min, max
        ///
        /// * backfill: zero, value, median, mean, min, max
        ///
        /// * futurefill: zero, value, median, mean, min, max
        ///
        ///
        /// To set a filling method to a specific value, set the fill parameter to value and define the value in a corresponding _value parameter. For example, to set backfilling to a value of 2, include the following: "backfill": "value" and "backfill_value":"2".
        /// This member is required.
        public var transformations: [Swift.String:Swift.String]?

        public init (
            attributeName: Swift.String? = nil,
            transformations: [Swift.String:Swift.String]? = nil
        )
        {
            self.attributeName = attributeName
            self.transformations = transformations
        }
    }

}

extension ForecastClientTypes {
    public enum AttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case float
        case geolocation
        case integer
        case string
        case timestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeType] {
            return [
                .float,
                .geolocation,
                .integer,
                .string,
                .timestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .float: return "float"
            case .geolocation: return "geolocation"
            case .integer: return "integer"
            case .string: return "string"
            case .timestamp: return "timestamp"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeType(rawValue: rawValue) ?? AttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes {
    public enum AutoMLOverrideStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accuracyoptimized
        case latencyoptimized
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoMLOverrideStrategy] {
            return [
                .accuracyoptimized,
                .latencyoptimized,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accuracyoptimized: return "AccuracyOptimized"
            case .latencyoptimized: return "LatencyOptimized"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoMLOverrideStrategy(rawValue: rawValue) ?? AutoMLOverrideStrategy.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.CategoricalParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for values0 in values {
                try valuesContainer.encode(values0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ForecastClientTypes {
    /// Specifies a categorical hyperparameter and it's range of tunable values. This object is part of the [ParameterRanges] object.
    public struct CategoricalParameterRange: Swift.Equatable {
        /// The name of the categorical hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// A list of the tunable categories for the hyperparameter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ForecastClientTypes.ContinuousParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case name = "Name"
        case scalingType = "ScalingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxValue = maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scalingType = scalingType {
            try encodeContainer.encode(scalingType.rawValue, forKey: .scalingType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minValue)
        minValue = minValueDecoded
        let scalingTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ScalingType.self, forKey: .scalingType)
        scalingType = scalingTypeDecoded
    }
}

extension ForecastClientTypes {
    /// Specifies a continuous hyperparameter and it's range of tunable values. This object is part of the [ParameterRanges] object.
    public struct ContinuousParameterRange: Swift.Equatable {
        /// The maximum tunable value of the hyperparameter.
        /// This member is required.
        public var maxValue: Swift.Double?
        /// The minimum tunable value of the hyperparameter.
        /// This member is required.
        public var minValue: Swift.Double?
        /// The name of the hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values: Auto Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter. Linear Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale. Logarithmic Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have values greater than 0. ReverseLogarithmic hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale. Reverse logarithmic scaling works only for ranges that are entirely within the range 0 <= x < 1.0. For information about choosing a hyperparameter scale, see [Hyperparameter Scaling](http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type). One of the following values:
        public var scalingType: ForecastClientTypes.ScalingType?

        public init (
            maxValue: Swift.Double? = nil,
            minValue: Swift.Double? = nil,
            name: Swift.String? = nil,
            scalingType: ForecastClientTypes.ScalingType? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }
    }

}

extension CreateAutoPredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataConfig = "DataConfig"
        case encryptionConfig = "EncryptionConfig"
        case explainPredictor = "ExplainPredictor"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case optimizationMetric = "OptimizationMetric"
        case predictorName = "PredictorName"
        case referencePredictorArn = "ReferencePredictorArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataConfig = dataConfig {
            try encodeContainer.encode(dataConfig, forKey: .dataConfig)
        }
        if let encryptionConfig = encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let explainPredictor = explainPredictor {
            try encodeContainer.encode(explainPredictor, forKey: .explainPredictor)
        }
        if let forecastDimensions = forecastDimensions {
            var forecastDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastDimensions)
            for forecastdimensions0 in forecastDimensions {
                try forecastDimensionsContainer.encode(forecastdimensions0)
            }
        }
        if let forecastFrequency = forecastFrequency {
            try encodeContainer.encode(forecastFrequency, forKey: .forecastFrequency)
        }
        if let forecastHorizon = forecastHorizon {
            try encodeContainer.encode(forecastHorizon, forKey: .forecastHorizon)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttypes0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttypes0)
            }
        }
        if let optimizationMetric = optimizationMetric {
            try encodeContainer.encode(optimizationMetric.rawValue, forKey: .optimizationMetric)
        }
        if let predictorName = predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let referencePredictorArn = referencePredictorArn {
            try encodeContainer.encode(referencePredictorArn, forKey: .referencePredictorArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

extension CreateAutoPredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAutoPredictorInput: Swift.Equatable {
    /// The data configuration for your dataset group and any additional datasets.
    public var dataConfig: ForecastClientTypes.DataConfig?
    /// An AWS Key Management Service (KMS) key and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the [CreateDataset] and [CreatePredictor] requests.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    public var explainPredictor: Swift.Bool?
    /// An array of dimension (field) names that specify how to group the generated forecast. For example, if you are generating forecasts for item sales across all your stores, and your dataset contains a store_id field, you would specify store_id as a dimension to group sales forecasts for each store.
    public var forecastDimensions: [Swift.String]?
    /// The frequency of predictions in a forecast. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes. The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency. When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the RELATED_TIME_SERIES dataset frequency.
    public var forecastFrequency: Swift.String?
    /// The number of time-steps that the model predicts. The forecast horizon is also called the prediction length.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used to train a predictor. You can specify up to five forecast types. Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify the mean forecast with mean.
    public var forecastTypes: [Swift.String]?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// A unique name for the predictor
    /// This member is required.
    public var predictorName: Swift.String?
    /// The ARN of the predictor to retrain or upgrade. This parameter is only used when retraining or upgrading a predictor. When creating a new predictor, do not specify a value for this parameter. When upgrading or retraining a predictor, only specify values for the ReferencePredictorArn and PredictorName. The value for PredictorName must be a unique predictor name.
    public var referencePredictorArn: Swift.String?
    /// Optional metadata to help you categorize and organize your predictors. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        dataConfig: ForecastClientTypes.DataConfig? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        explainPredictor: Swift.Bool? = nil,
        forecastDimensions: [Swift.String]? = nil,
        forecastFrequency: Swift.String? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorName: Swift.String? = nil,
        referencePredictorArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.dataConfig = dataConfig
        self.encryptionConfig = encryptionConfig
        self.explainPredictor = explainPredictor
        self.forecastDimensions = forecastDimensions
        self.forecastFrequency = forecastFrequency
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.optimizationMetric = optimizationMetric
        self.predictorName = predictorName
        self.referencePredictorArn = referencePredictorArn
        self.tags = tags
    }
}

struct CreateAutoPredictorInputBody: Swift.Equatable {
    let predictorName: Swift.String?
    let forecastHorizon: Swift.Int?
    let forecastTypes: [Swift.String]?
    let forecastDimensions: [Swift.String]?
    let forecastFrequency: Swift.String?
    let dataConfig: ForecastClientTypes.DataConfig?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let referencePredictorArn: Swift.String?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
    let explainPredictor: Swift.Bool?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateAutoPredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataConfig = "DataConfig"
        case encryptionConfig = "EncryptionConfig"
        case explainPredictor = "ExplainPredictor"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case optimizationMetric = "OptimizationMetric"
        case predictorName = "PredictorName"
        case referencePredictorArn = "ReferencePredictorArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let forecastDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastDimensions)
        var forecastDimensionsDecoded0:[Swift.String]? = nil
        if let forecastDimensionsContainer = forecastDimensionsContainer {
            forecastDimensionsDecoded0 = [Swift.String]()
            for string0 in forecastDimensionsContainer {
                if let string0 = string0 {
                    forecastDimensionsDecoded0?.append(string0)
                }
            }
        }
        forecastDimensions = forecastDimensionsDecoded0
        let forecastFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastFrequency)
        forecastFrequency = forecastFrequencyDecoded
        let dataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataConfig.self, forKey: .dataConfig)
        dataConfig = dataConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let referencePredictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referencePredictorArn)
        referencePredictorArn = referencePredictorArnDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
        let explainPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .explainPredictor)
        explainPredictor = explainPredictorDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAutoPredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAutoPredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAutoPredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAutoPredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAutoPredictorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.predictorArn = output.predictorArn
        } else {
            self.predictorArn = nil
        }
    }
}

public struct CreateAutoPredictorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct CreateAutoPredictorOutputResponseBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension CreateAutoPredictorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension CreateDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArns = datasetArns {
            var datasetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetArns)
            for arnlist0 in datasetArns {
                try datasetArnsContainer.encode(arnlist0)
            }
        }
        if let datasetGroupName = datasetGroupName {
            try encodeContainer.encode(datasetGroupName, forKey: .datasetGroupName)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

extension CreateDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetGroupInput: Swift.Equatable {
    /// An array of Amazon Resource Names (ARNs) of the datasets that you want to include in the dataset group.
    public var datasetArns: [Swift.String]?
    /// A name for the dataset group.
    /// This member is required.
    public var datasetGroupName: Swift.String?
    /// The domain associated with the dataset group. When you add a dataset to a dataset group, this value and the value specified for the Domain parameter of the [CreateDataset] operation must match. The Domain and DatasetType that you choose determine the fields that must be present in training data that you import to a dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires that item_id, timestamp, and demand fields are present in your data. For more information, see [howitworks-datasets-groups].
    /// This member is required.
    public var domain: ForecastClientTypes.Domain?
    /// The optional metadata that you apply to the dataset group to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        datasetArns: [Swift.String]? = nil,
        datasetGroupName: Swift.String? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.datasetArns = datasetArns
        self.datasetGroupName = datasetGroupName
        self.domain = domain
        self.tags = tags
    }
}

struct CreateDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupName: Swift.String?
    let domain: ForecastClientTypes.Domain?
    let datasetArns: [Swift.String]?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[Swift.String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [Swift.String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroupArn = output.datasetGroupArn
        } else {
            self.datasetGroupArn = nil
        }
    }
}

public struct CreateDatasetGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct CreateDatasetGroupOutputResponseBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension CreateDatasetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension CreateDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobName = "DatasetImportJobName"
        case geolocationFormat = "GeolocationFormat"
        case tags = "Tags"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetImportJobName = datasetImportJobName {
            try encodeContainer.encode(datasetImportJobName, forKey: .datasetImportJobName)
        }
        if let geolocationFormat = geolocationFormat {
            try encodeContainer.encode(geolocationFormat, forKey: .geolocationFormat)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let timeZone = timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
        if let timestampFormat = timestampFormat {
            try encodeContainer.encode(timestampFormat, forKey: .timestampFormat)
        }
        if useGeolocationForTimeZone != false {
            try encodeContainer.encode(useGeolocationForTimeZone, forKey: .useGeolocationForTimeZone)
        }
    }
}

extension CreateDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetImportJobInput: Swift.Equatable {
    /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket. If encryption is used, DataSource must include an AWS Key Management Service (KMS) key and the IAM role must allow Amazon Forecast permission to access the key. The KMS key and IAM role must match those specified in the EncryptionConfig parameter of the [CreateDataset] operation.
    /// This member is required.
    public var dataSource: ForecastClientTypes.DataSource?
    /// The Amazon Resource Name (ARN) of the Amazon Forecast dataset that you want to import data to.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The name for the dataset import job. We recommend including the current timestamp in the name, for example, 20190721DatasetImport. This can help you avoid getting a ResourceAlreadyExistsException exception.
    /// This member is required.
    public var datasetImportJobName: Swift.String?
    /// The format of the geolocation attribute. The geolocation attribute can be formatted in one of two ways:
    ///
    /// * LAT_LONG - the latitude and longitude in decimal format (Example: 47.61_-122.33).
    ///
    /// * CC_POSTALCODE (US Only) - the country code (US), followed by the 5-digit ZIP code (Example: US_98121).
    public var geolocationFormat: Swift.String?
    /// The optional metadata that you apply to the dataset import job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?
    /// A single time zone for every item in your dataset. This option is ideal for datasets with all timestamps within a single time zone, or if all timestamps are normalized to a single time zone. Refer to the [Joda-Time API](http://joda-time.sourceforge.net/timezones.html) for a complete list of valid time zone names.
    public var timeZone: Swift.String?
    /// The format of timestamps in the dataset. The format that you specify depends on the DataFrequency specified when the dataset was created. The following formats are supported
    ///
    /// * "yyyy-MM-dd" For the following data frequencies: Y, M, W, and D
    ///
    /// * "yyyy-MM-dd HH:mm:ss" For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D
    ///
    ///
    /// If the format isn't specified, Amazon Forecast expects the format to be "yyyy-MM-dd HH:mm:ss".
    public var timestampFormat: Swift.String?
    /// Automatically derive time zone information from the geolocation attribute. This option is ideal for datasets that contain timestamps in multiple time zones and those timestamps are expressed in local time.
    public var useGeolocationForTimeZone: Swift.Bool

    public init (
        dataSource: ForecastClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        datasetImportJobName: Swift.String? = nil,
        geolocationFormat: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        timeZone: Swift.String? = nil,
        timestampFormat: Swift.String? = nil,
        useGeolocationForTimeZone: Swift.Bool = false
    )
    {
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobName = datasetImportJobName
        self.geolocationFormat = geolocationFormat
        self.tags = tags
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

struct CreateDatasetImportJobInputBody: Swift.Equatable {
    let datasetImportJobName: Swift.String?
    let datasetArn: Swift.String?
    let dataSource: ForecastClientTypes.DataSource?
    let timestampFormat: Swift.String?
    let timeZone: Swift.String?
    let useGeolocationForTimeZone: Swift.Bool
    let geolocationFormat: Swift.String?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobName = "DatasetImportJobName"
        case geolocationFormat = "GeolocationFormat"
        case tags = "Tags"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let timestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let useGeolocationForTimeZoneDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useGeolocationForTimeZone)
        useGeolocationForTimeZone = useGeolocationForTimeZoneDecoded
        let geolocationFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geolocationFormat)
        geolocationFormat = geolocationFormatDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobArn = output.datasetImportJobArn
        } else {
            self.datasetImportJobArn = nil
        }
    }
}

public struct CreateDatasetImportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct CreateDatasetImportJobOutputResponseBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension CreateDatasetImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension CreateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataFrequency = "DataFrequency"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case schema = "Schema"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataFrequency = dataFrequency {
            try encodeContainer.encode(dataFrequency, forKey: .dataFrequency)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType.rawValue, forKey: .datasetType)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let encryptionConfig = encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

extension CreateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetInput: Swift.Equatable {
    /// The frequency of data collection. This parameter is required for RELATED_TIME_SERIES datasets. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "D" indicates every day and "15min" indicates every 15 minutes.
    public var dataFrequency: Swift.String?
    /// A name for the dataset.
    /// This member is required.
    public var datasetName: Swift.String?
    /// The dataset type. Valid values depend on the chosen Domain.
    /// This member is required.
    public var datasetType: ForecastClientTypes.DatasetType?
    /// The domain associated with the dataset. When you add a dataset to a dataset group, this value and the value specified for the Domain parameter of the [CreateDatasetGroup] operation must match. The Domain and DatasetType that you choose determine the fields that must be present in the training data that you import to the dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires item_id, timestamp, and demand fields to be present in your data. For more information, see [howitworks-datasets-groups].
    /// This member is required.
    public var domain: ForecastClientTypes.Domain?
    /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The schema for the dataset. The schema attributes and their order must match the fields in your data. The dataset Domain and DatasetType that you choose determine the minimum required fields in your training data. For information about the required fields for a specific dataset domain and type, see [howitworks-domains-ds-types].
    /// This member is required.
    public var schema: ForecastClientTypes.Schema?
    /// The optional metadata that you apply to the dataset to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        dataFrequency: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        datasetType: ForecastClientTypes.DatasetType? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.dataFrequency = dataFrequency
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.encryptionConfig = encryptionConfig
        self.schema = schema
        self.tags = tags
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    let datasetName: Swift.String?
    let domain: ForecastClientTypes.Domain?
    let datasetType: ForecastClientTypes.DatasetType?
    let dataFrequency: Swift.String?
    let schema: ForecastClientTypes.Schema?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataFrequency = "DataFrequency"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case schema = "Schema"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let dataFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataFrequency)
        dataFrequency = dataFrequencyDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetArn = output.datasetArn
        } else {
            self.datasetArn = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct CreateDatasetOutputResponseBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension CreateDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension CreateExplainabilityExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityExportName = "ExplainabilityExportName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let explainabilityArn = explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
        if let explainabilityExportName = explainabilityExportName {
            try encodeContainer.encode(explainabilityExportName, forKey: .explainabilityExportName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

extension CreateExplainabilityExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateExplainabilityExportInput: Swift.Equatable {
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the Explainability to export.
    /// This member is required.
    public var explainabilityArn: Swift.String?
    /// A unique name for the Explainability export.
    /// This member is required.
    public var explainabilityExportName: Swift.String?
    /// Optional metadata to help you categorize and organize your resources. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        destination: ForecastClientTypes.DataDestination? = nil,
        explainabilityArn: Swift.String? = nil,
        explainabilityExportName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.explainabilityArn = explainabilityArn
        self.explainabilityExportName = explainabilityExportName
        self.tags = tags
    }
}

struct CreateExplainabilityExportInputBody: Swift.Equatable {
    let explainabilityExportName: Swift.String?
    let explainabilityArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateExplainabilityExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityExportName = "ExplainabilityExportName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportName)
        explainabilityExportName = explainabilityExportNameDecoded
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateExplainabilityExportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateExplainabilityExportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateExplainabilityExportOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateExplainabilityExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateExplainabilityExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.explainabilityExportArn = output.explainabilityExportArn
        } else {
            self.explainabilityExportArn = nil
        }
    }
}

public struct CreateExplainabilityExportOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the export.
    public var explainabilityExportArn: Swift.String?

    public init (
        explainabilityExportArn: Swift.String? = nil
    )
    {
        self.explainabilityExportArn = explainabilityExportArn
    }
}

struct CreateExplainabilityExportOutputResponseBody: Swift.Equatable {
    let explainabilityExportArn: Swift.String?
}

extension CreateExplainabilityExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
    }
}

extension CreateExplainabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case enableVisualization = "EnableVisualization"
        case endDateTime = "EndDateTime"
        case explainabilityConfig = "ExplainabilityConfig"
        case explainabilityName = "ExplainabilityName"
        case resourceArn = "ResourceArn"
        case schema = "Schema"
        case startDateTime = "StartDateTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let enableVisualization = enableVisualization {
            try encodeContainer.encode(enableVisualization, forKey: .enableVisualization)
        }
        if let endDateTime = endDateTime {
            try encodeContainer.encode(endDateTime, forKey: .endDateTime)
        }
        if let explainabilityConfig = explainabilityConfig {
            try encodeContainer.encode(explainabilityConfig, forKey: .explainabilityConfig)
        }
        if let explainabilityName = explainabilityName {
            try encodeContainer.encode(explainabilityName, forKey: .explainabilityName)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let startDateTime = startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

extension CreateExplainabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateExplainabilityInput: Swift.Equatable {
    /// The source of your training data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an AWS Key Management Service (KMS) key. This object is submitted in the [CreateDatasetImportJob] request.
    public var dataSource: ForecastClientTypes.DataSource?
    /// Create an Expainability visualization that is viewable within the AWS console.
    public var enableVisualization: Swift.Bool?
    /// If TimePointGranularity is set to SPECIFIC, define the last time point for the Explainability.
    public var endDateTime: Swift.String?
    /// The configuration settings that define the granularity of time series and time points for the Explainability.
    /// This member is required.
    public var explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    /// A unique name for the Explainability.
    /// This member is required.
    public var explainabilityName: Swift.String?
    /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Defines the fields of a dataset. You specify this object in the [CreateDataset] request.
    public var schema: ForecastClientTypes.Schema?
    /// If TimePointGranularity is set to SPECIFIC, define the first point for the Explainability.
    public var startDateTime: Swift.String?
    /// Optional metadata to help you categorize and organize your resources. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        dataSource: ForecastClientTypes.DataSource? = nil,
        enableVisualization: Swift.Bool? = nil,
        endDateTime: Swift.String? = nil,
        explainabilityConfig: ForecastClientTypes.ExplainabilityConfig? = nil,
        explainabilityName: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        startDateTime: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.dataSource = dataSource
        self.enableVisualization = enableVisualization
        self.endDateTime = endDateTime
        self.explainabilityConfig = explainabilityConfig
        self.explainabilityName = explainabilityName
        self.resourceArn = resourceArn
        self.schema = schema
        self.startDateTime = startDateTime
        self.tags = tags
    }
}

struct CreateExplainabilityInputBody: Swift.Equatable {
    let explainabilityName: Swift.String?
    let resourceArn: Swift.String?
    let explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    let dataSource: ForecastClientTypes.DataSource?
    let schema: ForecastClientTypes.Schema?
    let enableVisualization: Swift.Bool?
    let startDateTime: Swift.String?
    let endDateTime: Swift.String?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateExplainabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case enableVisualization = "EnableVisualization"
        case endDateTime = "EndDateTime"
        case explainabilityConfig = "ExplainabilityConfig"
        case explainabilityName = "ExplainabilityName"
        case resourceArn = "ResourceArn"
        case schema = "Schema"
        case startDateTime = "StartDateTime"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityName)
        explainabilityName = explainabilityNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let explainabilityConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ExplainabilityConfig.self, forKey: .explainabilityConfig)
        explainabilityConfig = explainabilityConfigDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let enableVisualizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableVisualization)
        enableVisualization = enableVisualizationDecoded
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateExplainabilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateExplainabilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateExplainabilityOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateExplainabilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateExplainabilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.explainabilityArn = output.explainabilityArn
        } else {
            self.explainabilityArn = nil
        }
    }
}

public struct CreateExplainabilityOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explainability.
    public var explainabilityArn: Swift.String?

    public init (
        explainabilityArn: Swift.String? = nil
    )
    {
        self.explainabilityArn = explainabilityArn
    }
}

struct CreateExplainabilityOutputResponseBody: Swift.Equatable {
    let explainabilityArn: Swift.String?
}

extension CreateExplainabilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
    }
}

extension CreateForecastExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobName = "ForecastExportJobName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let forecastExportJobName = forecastExportJobName {
            try encodeContainer.encode(forecastExportJobName, forKey: .forecastExportJobName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

extension CreateForecastExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateForecastExportJobInput: Swift.Equatable {
    /// The location where you want to save the forecast and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the location. The forecast must be exported to an Amazon S3 bucket. If encryption is used, Destination must include an AWS Key Management Service (KMS) key. The IAM role must allow Amazon Forecast permission to access the key.
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the forecast that you want to export.
    /// This member is required.
    public var forecastArn: Swift.String?
    /// The name for the forecast export job.
    /// This member is required.
    public var forecastExportJobName: Swift.String?
    /// The optional metadata that you apply to the forecast export job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        destination: ForecastClientTypes.DataDestination? = nil,
        forecastArn: Swift.String? = nil,
        forecastExportJobName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.forecastArn = forecastArn
        self.forecastExportJobName = forecastExportJobName
        self.tags = tags
    }
}

struct CreateForecastExportJobInputBody: Swift.Equatable {
    let forecastExportJobName: Swift.String?
    let forecastArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateForecastExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobName = "ForecastExportJobName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateForecastExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateForecastExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateForecastExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateForecastExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateForecastExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecastExportJobArn = output.forecastExportJobArn
        } else {
            self.forecastExportJobArn = nil
        }
    }
}

public struct CreateForecastExportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the export job.
    public var forecastExportJobArn: Swift.String?

    public init (
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct CreateForecastExportJobOutputResponseBody: Swift.Equatable {
    let forecastExportJobArn: Swift.String?
}

extension CreateForecastExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

extension CreateForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case predictorArn = "PredictorArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastName = forecastName {
            try encodeContainer.encode(forecastName, forKey: .forecastName)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttypes0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttypes0)
            }
        }
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

extension CreateForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateForecastInput: Swift.Equatable {
    /// A name for the forecast.
    /// This member is required.
    public var forecastName: Swift.String?
    /// The quantiles at which probabilistic forecasts are generated. You can currently specify up to 5 quantiles per forecast. Accepted values include 0.01 to 0.99 (increments of .01 only) and mean. The mean forecast is different from the median (0.50) when the distribution is not symmetric (for example, Beta and Negative Binomial). The default value is ["0.1", "0.5", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the predictor to use to generate the forecast.
    /// This member is required.
    public var predictorArn: Swift.String?
    /// The optional metadata that you apply to the forecast to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        forecastName: Swift.String? = nil,
        forecastTypes: [Swift.String]? = nil,
        predictorArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.forecastName = forecastName
        self.forecastTypes = forecastTypes
        self.predictorArn = predictorArn
        self.tags = tags
    }
}

struct CreateForecastInputBody: Swift.Equatable {
    let forecastName: Swift.String?
    let predictorArn: Swift.String?
    let forecastTypes: [Swift.String]?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreateForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case predictorArn = "PredictorArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateForecastOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateForecastOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecastArn = output.forecastArn
        } else {
            self.forecastArn = nil
        }
    }
}

public struct CreateForecastOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast.
    public var forecastArn: Swift.String?

    public init (
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct CreateForecastOutputResponseBody: Swift.Equatable {
    let forecastArn: Swift.String?
}

extension CreateForecastOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

extension CreatePredictorBacktestExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let predictorBacktestExportJobName = predictorBacktestExportJobName {
            try encodeContainer.encode(predictorBacktestExportJobName, forKey: .predictorBacktestExportJobName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

extension CreatePredictorBacktestExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePredictorBacktestExportJobInput: Swift.Equatable {
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
    /// This member is required.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the predictor that you want to export.
    /// This member is required.
    public var predictorArn: Swift.String?
    /// The name for the backtest export job.
    /// This member is required.
    public var predictorBacktestExportJobName: Swift.String?
    /// Optional metadata to help you categorize and organize your backtests. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:
    ///
    /// * For each resource, each tag key must be unique and each tag key must have one value.
    ///
    /// * Maximum number of tags per resource: 50.
    ///
    /// * Maximum key length: 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length: 256 Unicode characters in UTF-8.
    ///
    /// * Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.
    ///
    /// * Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        destination: ForecastClientTypes.DataDestination? = nil,
        predictorArn: Swift.String? = nil,
        predictorBacktestExportJobName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.destination = destination
        self.predictorArn = predictorArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.tags = tags
    }
}

struct CreatePredictorBacktestExportJobInputBody: Swift.Equatable {
    let predictorBacktestExportJobName: Swift.String?
    let predictorArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let tags: [ForecastClientTypes.Tag]?
}

extension CreatePredictorBacktestExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePredictorBacktestExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePredictorBacktestExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePredictorBacktestExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePredictorBacktestExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePredictorBacktestExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.predictorBacktestExportJobArn = output.predictorBacktestExportJobArn
        } else {
            self.predictorBacktestExportJobArn = nil
        }
    }
}

public struct CreatePredictorBacktestExportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job that you want to export.
    public var predictorBacktestExportJobArn: Swift.String?

    public init (
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct CreatePredictorBacktestExportJobOutputResponseBody: Swift.Equatable {
    let predictorBacktestExportJobArn: Swift.String?
}

extension CreatePredictorBacktestExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

extension CreatePredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case encryptionConfig = "EncryptionConfig"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hPOConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case optimizationMetric = "OptimizationMetric"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorName = "PredictorName"
        case tags = "Tags"
        case trainingParameters = "TrainingParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let autoMLOverrideStrategy = autoMLOverrideStrategy {
            try encodeContainer.encode(autoMLOverrideStrategy.rawValue, forKey: .autoMLOverrideStrategy)
        }
        if let encryptionConfig = encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let evaluationParameters = evaluationParameters {
            try encodeContainer.encode(evaluationParameters, forKey: .evaluationParameters)
        }
        if let featurizationConfig = featurizationConfig {
            try encodeContainer.encode(featurizationConfig, forKey: .featurizationConfig)
        }
        if let forecastHorizon = forecastHorizon {
            try encodeContainer.encode(forecastHorizon, forKey: .forecastHorizon)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttypes0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttypes0)
            }
        }
        if let hPOConfig = hPOConfig {
            try encodeContainer.encode(hPOConfig, forKey: .hPOConfig)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let optimizationMetric = optimizationMetric {
            try encodeContainer.encode(optimizationMetric.rawValue, forKey: .optimizationMetric)
        }
        if let performAutoML = performAutoML {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if let performHPO = performHPO {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let predictorName = predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let trainingParameters = trainingParameters {
            var trainingParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .trainingParameters)
            for (dictKey0, trainingparameters0) in trainingParameters {
                try trainingParametersContainer.encode(trainingparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the algorithm to use for model training. Required if PerformAutoML is not set to true. Supported algorithms:
    ///
    /// * arn:aws:forecast:::algorithm/ARIMA
    ///
    /// * arn:aws:forecast:::algorithm/CNN-QR
    ///
    /// * arn:aws:forecast:::algorithm/Deep_AR_Plus
    ///
    /// * arn:aws:forecast:::algorithm/ETS
    ///
    /// * arn:aws:forecast:::algorithm/NPTS
    ///
    /// * arn:aws:forecast:::algorithm/Prophet
    public var algorithmArn: Swift.String?
    /// The LatencyOptimized AutoML override strategy is only available in private beta. Contact AWS Support or your account manager to learn more about access privileges. Used to overide the default AutoML strategy, which is to optimize predictor accuracy. To apply an AutoML strategy that minimizes training time, use LatencyOptimized. This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
    public var evaluationParameters: ForecastClientTypes.EvaluationParameters?
    /// The featurization configuration.
    /// This member is required.
    public var featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    /// Specifies the number of time-steps that the model is trained to predict. The forecast horizon is also called the prediction length. For example, if you configure a dataset for daily data collection (using the DataFrequency parameter of the [CreateDataset] operation) and set the forecast horizon to 10, the model returns predictions for 10 days. The maximum forecast horizon is the lesser of 500 time-steps or 1/3 of the TARGET_TIME_SERIES dataset length.
    /// This member is required.
    public var forecastHorizon: Swift.Int?
    /// Specifies the forecast types used to train a predictor. You can specify up to five forecast types. Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify the mean forecast with mean. The default value is ["0.10", "0.50", "0.9"].
    public var forecastTypes: [Swift.String]?
    /// Provides hyperparameter override values for the algorithm. If you don't provide this parameter, Amazon Forecast uses default values. The individual algorithms specify which hyperparameters support hyperparameter optimization (HPO). For more information, see [aws-forecast-choosing-recipes]. If you included the HPOConfig object, you must set PerformHPO to true.
    public var hPOConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    /// Describes the dataset group that contains the data to use to train the predictor.
    /// This member is required.
    public var inputDataConfig: ForecastClientTypes.InputDataConfig?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// Whether to perform AutoML. When Amazon Forecast performs AutoML, it evaluates the algorithms it provides and chooses the best algorithm and configuration for your training dataset. The default value is false. In this case, you are required to specify an algorithm. Set PerformAutoML to true to have Amazon Forecast perform AutoML. This is a good option if you aren't sure which algorithm is suitable for your training data. In this case, PerformHPO must be false.
    public var performAutoML: Swift.Bool?
    /// Whether to perform hyperparameter optimization (HPO). HPO finds optimal hyperparameter values for your training data. The process of performing HPO is known as running a hyperparameter tuning job. The default value is false. In this case, Amazon Forecast uses default hyperparameter values from the chosen algorithm. To override the default values, set PerformHPO to true and, optionally, supply the [HyperParameterTuningJobConfig] object. The tuning job specifies a metric to optimize, which hyperparameters participate in tuning, and the valid range for each tunable hyperparameter. In this case, you are required to specify an algorithm and PerformAutoML must be false. The following algorithms support HPO:
    ///
    /// * DeepAR+
    ///
    /// * CNN-QR
    public var performHPO: Swift.Bool?
    /// A name for the predictor.
    /// This member is required.
    public var predictorName: Swift.String?
    /// The optional metadata that you apply to the predictor to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public var tags: [ForecastClientTypes.Tag]?
    /// The hyperparameters to override for model training. The hyperparameters that you can override are listed in the individual algorithms. For the list of supported algorithms, see [aws-forecast-choosing-recipes].
    public var trainingParameters: [Swift.String:Swift.String]?

    public init (
        algorithmArn: Swift.String? = nil,
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        evaluationParameters: ForecastClientTypes.EvaluationParameters? = nil,
        featurizationConfig: ForecastClientTypes.FeaturizationConfig? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        hPOConfig: ForecastClientTypes.HyperParameterTuningJobConfig? = nil,
        inputDataConfig: ForecastClientTypes.InputDataConfig? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        performAutoML: Swift.Bool? = nil,
        performHPO: Swift.Bool? = nil,
        predictorName: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil,
        trainingParameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.encryptionConfig = encryptionConfig
        self.evaluationParameters = evaluationParameters
        self.featurizationConfig = featurizationConfig
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.hPOConfig = hPOConfig
        self.inputDataConfig = inputDataConfig
        self.optimizationMetric = optimizationMetric
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.predictorName = predictorName
        self.tags = tags
        self.trainingParameters = trainingParameters
    }
}

struct CreatePredictorInputBody: Swift.Equatable {
    let predictorName: Swift.String?
    let algorithmArn: Swift.String?
    let forecastHorizon: Swift.Int?
    let forecastTypes: [Swift.String]?
    let performAutoML: Swift.Bool?
    let autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    let performHPO: Swift.Bool?
    let trainingParameters: [Swift.String:Swift.String]?
    let evaluationParameters: ForecastClientTypes.EvaluationParameters?
    let hPOConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    let inputDataConfig: ForecastClientTypes.InputDataConfig?
    let featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let tags: [ForecastClientTypes.Tag]?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
}

extension CreatePredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case encryptionConfig = "EncryptionConfig"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hPOConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case optimizationMetric = "OptimizationMetric"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorName = "PredictorName"
        case tags = "Tags"
        case trainingParameters = "TrainingParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let trainingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .trainingParameters)
        var trainingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let trainingParametersContainer = trainingParametersContainer {
            trainingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in trainingParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    trainingParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        trainingParameters = trainingParametersDecoded0
        let evaluationParametersDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EvaluationParameters.self, forKey: .evaluationParameters)
        evaluationParameters = evaluationParametersDecoded
        let hPOConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.HyperParameterTuningJobConfig.self, forKey: .hPOConfig)
        hPOConfig = hPOConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let featurizationConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FeaturizationConfig.self, forKey: .featurizationConfig)
        featurizationConfig = featurizationConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
    }
}

extension CreatePredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePredictorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.predictorArn = output.predictorArn
        } else {
            self.predictorArn = nil
        }
    }
}

public struct CreatePredictorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct CreatePredictorOutputResponseBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension CreatePredictorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension ForecastClientTypes.DataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalDatasets = "AdditionalDatasets"
        case attributeConfigs = "AttributeConfigs"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalDatasets = additionalDatasets {
            var additionalDatasetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalDatasets)
            for additionaldatasets0 in additionalDatasets {
                try additionalDatasetsContainer.encode(additionaldatasets0)
            }
        }
        if let attributeConfigs = attributeConfigs {
            var attributeConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeConfigs)
            for attributeconfigs0 in attributeConfigs {
                try attributeConfigsContainer.encode(attributeconfigs0)
            }
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let attributeConfigsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.AttributeConfig?].self, forKey: .attributeConfigs)
        var attributeConfigsDecoded0:[ForecastClientTypes.AttributeConfig]? = nil
        if let attributeConfigsContainer = attributeConfigsContainer {
            attributeConfigsDecoded0 = [ForecastClientTypes.AttributeConfig]()
            for structure0 in attributeConfigsContainer {
                if let structure0 = structure0 {
                    attributeConfigsDecoded0?.append(structure0)
                }
            }
        }
        attributeConfigs = attributeConfigsDecoded0
        let additionalDatasetsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.AdditionalDataset?].self, forKey: .additionalDatasets)
        var additionalDatasetsDecoded0:[ForecastClientTypes.AdditionalDataset]? = nil
        if let additionalDatasetsContainer = additionalDatasetsContainer {
            additionalDatasetsDecoded0 = [ForecastClientTypes.AdditionalDataset]()
            for structure0 in additionalDatasetsContainer {
                if let structure0 = structure0 {
                    additionalDatasetsDecoded0?.append(structure0)
                }
            }
        }
        additionalDatasets = additionalDatasetsDecoded0
    }
}

extension ForecastClientTypes {
    /// The data configuration for your dataset group and any additional datasets.
    public struct DataConfig: Swift.Equatable {
        /// Additional built-in datasets like Holidays and the Weather Index.
        public var additionalDatasets: [ForecastClientTypes.AdditionalDataset]?
        /// Aggregation and filling options for attributes in your dataset group.
        public var attributeConfigs: [ForecastClientTypes.AttributeConfig]?
        /// The ARN of the dataset group used to train the predictor.
        /// This member is required.
        public var datasetGroupArn: Swift.String?

        public init (
            additionalDatasets: [ForecastClientTypes.AdditionalDataset]? = nil,
            attributeConfigs: [ForecastClientTypes.AttributeConfig]? = nil,
            datasetGroupArn: Swift.String? = nil
        )
        {
            self.additionalDatasets = additionalDatasets
            self.attributeConfigs = attributeConfigs
            self.datasetGroupArn = datasetGroupArn
        }
    }

}

extension ForecastClientTypes.DataDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Config = "S3Config"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Config = s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
    }
}

extension ForecastClientTypes {
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
    public struct DataDestination: Swift.Equatable {
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the bucket.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?

        public init (
            s3Config: ForecastClientTypes.S3Config? = nil
        )
        {
            self.s3Config = s3Config
        }
    }

}

extension ForecastClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Config = "S3Config"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Config = s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
    }
}

extension ForecastClientTypes {
    /// The source of your training data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an AWS Key Management Service (KMS) key. This object is submitted in the [CreateDatasetImportJob] request.
    public struct DataSource: Swift.Equatable {
        /// The path to the training data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the data.
        /// This member is required.
        public var s3Config: ForecastClientTypes.S3Config?

        public init (
            s3Config: ForecastClientTypes.S3Config? = nil
        )
        {
            self.s3Config = s3Config
        }
    }

}

extension ForecastClientTypes.DatasetGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case datasetGroupName = "DatasetGroupName"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetGroupName = datasetGroupName {
            try encodeContainer.encode(datasetGroupName, forKey: .datasetGroupName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset group properties used in the [ListDatasetGroups] operation. To get the complete set of properties, call the [DescribeDatasetGroup] operation, and provide the DatasetGroupArn.
    public struct DatasetGroupSummary: Swift.Equatable {
        /// When the dataset group was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// The name of the dataset group.
        public var datasetGroupName: Swift.String?
        /// When the dataset group was created or last updated from a call to the [UpdateDatasetGroup] operation. While the dataset group is being updated, LastModificationTime is the current time of the ListDatasetGroups call.
        public var lastModificationTime: ClientRuntime.Date?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            datasetGroupName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.datasetGroupName = datasetGroupName
            self.lastModificationTime = lastModificationTime
        }
    }

}

extension ForecastClientTypes.DatasetImportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataSource = "DataSource"
        case datasetImportJobArn = "DatasetImportJobArn"
        case datasetImportJobName = "DatasetImportJobName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let datasetImportJobName = datasetImportJobName {
            try encodeContainer.encode(datasetImportJobName, forKey: .datasetImportJobName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset import job properties used in the [ListDatasetImportJobs] operation. To get the complete set of properties, call the [DescribeDatasetImportJob] operation, and provide the DatasetImportJobArn.
    public struct DatasetImportJobSummary: Swift.Equatable {
        /// When the dataset import job was created.
        public var creationTime: ClientRuntime.Date?
        /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket. If encryption is used, DataSource includes an AWS Key Management Service (KMS) key.
        public var dataSource: ForecastClientTypes.DataSource?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// The name of the dataset import job.
        public var datasetImportJobName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the dataset import job. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            dataSource: ForecastClientTypes.DataSource? = nil,
            datasetImportJobArn: Swift.String? = nil,
            datasetImportJobName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.dataSource = dataSource
            self.datasetImportJobArn = datasetImportJobArn
            self.datasetImportJobName = datasetImportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

extension ForecastClientTypes.DatasetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType.rawValue, forKey: .datasetType)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the dataset properties used in the [ListDatasets] operation. To get the complete set of properties, call the [DescribeDataset] operation, and provide the DatasetArn.
    public struct DatasetSummary: Swift.Equatable {
        /// When the dataset was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public var datasetArn: Swift.String?
        /// The name of the dataset.
        public var datasetName: Swift.String?
        /// The dataset type.
        public var datasetType: ForecastClientTypes.DatasetType?
        /// The domain associated with the dataset.
        public var domain: ForecastClientTypes.Domain?
        /// When you create a dataset, LastModificationTime is the same as CreationTime. While data is being imported to the dataset, LastModificationTime is the current time of the ListDatasets call. After a [CreateDatasetImportJob] operation has finished, LastModificationTime is when the import job completed or failed.
        public var lastModificationTime: ClientRuntime.Date?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetName: Swift.String? = nil,
            datasetType: ForecastClientTypes.DatasetType? = nil,
            domain: ForecastClientTypes.Domain? = nil,
            lastModificationTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetArn = datasetArn
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.lastModificationTime = lastModificationTime
        }
    }

}

extension ForecastClientTypes {
    public enum DatasetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case itemMetadata
        case relatedTimeSeries
        case targetTimeSeries
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetType] {
            return [
                .itemMetadata,
                .relatedTimeSeries,
                .targetTimeSeries,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .itemMetadata: return "ITEM_METADATA"
            case .relatedTimeSeries: return "RELATED_TIME_SERIES"
            case .targetTimeSeries: return "TARGET_TIME_SERIES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetType(rawValue: rawValue) ?? DatasetType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension DeleteDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group to delete.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DeleteDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension DeleteDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DeleteDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetGroupOutputResponse: Swift.Equatable {

}

extension DeleteDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

extension DeleteDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetImportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job to delete.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DeleteDatasetImportJobInputBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension DeleteDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DeleteDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetImportJobOutputResponse: Swift.Equatable {

}

extension DeleteDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

extension DeleteDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to delete.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension DeleteDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DeleteDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Swift.Equatable {

}

extension DeleteExplainabilityExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityExportArn = explainabilityExportArn {
            try encodeContainer.encode(explainabilityExportArn, forKey: .explainabilityExportArn)
        }
    }
}

extension DeleteExplainabilityExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteExplainabilityExportInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explainability export to delete.
    /// This member is required.
    public var explainabilityExportArn: Swift.String?

    public init (
        explainabilityExportArn: Swift.String? = nil
    )
    {
        self.explainabilityExportArn = explainabilityExportArn
    }
}

struct DeleteExplainabilityExportInputBody: Swift.Equatable {
    let explainabilityExportArn: Swift.String?
}

extension DeleteExplainabilityExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
    }
}

extension DeleteExplainabilityExportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteExplainabilityExportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteExplainabilityExportOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExplainabilityExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteExplainabilityExportOutputResponse: Swift.Equatable {

}

extension DeleteExplainabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityArn = explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
    }
}

extension DeleteExplainabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteExplainabilityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explainability resource to delete.
    /// This member is required.
    public var explainabilityArn: Swift.String?

    public init (
        explainabilityArn: Swift.String? = nil
    )
    {
        self.explainabilityArn = explainabilityArn
    }
}

struct DeleteExplainabilityInputBody: Swift.Equatable {
    let explainabilityArn: Swift.String?
}

extension DeleteExplainabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
    }
}

extension DeleteExplainabilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteExplainabilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteExplainabilityOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExplainabilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteExplainabilityOutputResponse: Swift.Equatable {

}

extension DeleteForecastExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastExportJobArn = forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
    }
}

extension DeleteForecastExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteForecastExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast export job to delete.
    /// This member is required.
    public var forecastExportJobArn: Swift.String?

    public init (
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct DeleteForecastExportJobInputBody: Swift.Equatable {
    let forecastExportJobArn: Swift.String?
}

extension DeleteForecastExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

extension DeleteForecastExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteForecastExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteForecastExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteForecastExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteForecastExportJobOutputResponse: Swift.Equatable {

}

extension DeleteForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
    }
}

extension DeleteForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteForecastInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast to delete.
    /// This member is required.
    public var forecastArn: Swift.String?

    public init (
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct DeleteForecastInputBody: Swift.Equatable {
    let forecastArn: Swift.String?
}

extension DeleteForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

extension DeleteForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteForecastOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteForecastOutputResponse: Swift.Equatable {

}

extension DeletePredictorBacktestExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorBacktestExportJobArn = predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
    }
}

extension DeletePredictorBacktestExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePredictorBacktestExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job to delete.
    /// This member is required.
    public var predictorBacktestExportJobArn: Swift.String?

    public init (
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct DeletePredictorBacktestExportJobInputBody: Swift.Equatable {
    let predictorBacktestExportJobArn: Swift.String?
}

extension DeletePredictorBacktestExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

extension DeletePredictorBacktestExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePredictorBacktestExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePredictorBacktestExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePredictorBacktestExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePredictorBacktestExportJobOutputResponse: Swift.Equatable {

}

extension DeletePredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

extension DeletePredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor to delete.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DeletePredictorInputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension DeletePredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DeletePredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePredictorOutputResponse: Swift.Equatable {

}

extension DeleteResourceTreeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DeleteResourceTreeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourceTreeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the parent resource to delete. All child resources of the parent resource will also be deleted.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourceTreeInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension DeleteResourceTreeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourceTreeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceTreeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceTreeOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceTreeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceTreeOutputResponse: Swift.Equatable {

}

extension DescribeAutoPredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

extension DescribeAutoPredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAutoPredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DescribeAutoPredictorInputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension DescribeAutoPredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DescribeAutoPredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAutoPredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAutoPredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAutoPredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAutoPredictorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataConfig = output.dataConfig
            self.datasetImportJobArns = output.datasetImportJobArns
            self.encryptionConfig = output.encryptionConfig
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.explainabilityInfo = output.explainabilityInfo
            self.forecastFrequency = output.forecastFrequency
            self.forecastHorizon = output.forecastHorizon
            self.forecastTypes = output.forecastTypes
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.optimizationMetric = output.optimizationMetric
            self.predictorArn = output.predictorArn
            self.predictorName = output.predictorName
            self.referencePredictorSummary = output.referencePredictorSummary
            self.status = output.status
        } else {
            self.creationTime = nil
            self.dataConfig = nil
            self.datasetImportJobArns = nil
            self.encryptionConfig = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.explainabilityInfo = nil
            self.forecastFrequency = nil
            self.forecastHorizon = nil
            self.forecastTypes = nil
            self.lastModificationTime = nil
            self.message = nil
            self.optimizationMetric = nil
            self.predictorArn = nil
            self.predictorName = nil
            self.referencePredictorSummary = nil
            self.status = nil
        }
    }
}

public struct DescribeAutoPredictorOutputResponse: Swift.Equatable {
    /// The timestamp of the CreateAutoPredictor request.
    public var creationTime: ClientRuntime.Date?
    /// The data configuration for your dataset group and any additional datasets.
    public var dataConfig: ForecastClientTypes.DataConfig?
    /// An array of the ARNs of the dataset import jobs used to import training data for the predictor.
    public var datasetImportJobArns: [Swift.String]?
    /// An AWS Key Management Service (KMS) key and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the [CreateDataset] and [CreatePredictor] requests.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The estimated time remaining in minutes for the predictor training job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    public var explainabilityInfo: ForecastClientTypes.ExplainabilityInfo?
    /// The frequency of predictions in a forecast. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes.
    public var forecastFrequency: Swift.String?
    /// The number of time-steps that the model predicts. The forecast horizon is also called the prediction length.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used during predictor training. Default value is ["0.1","0.5","0.9"].
    public var forecastTypes: [Swift.String]?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// In the event of an error, a message detailing the cause of the error.
    public var message: Swift.String?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// The Amazon Resource Name (ARN) of the predictor
    public var predictorArn: Swift.String?
    /// The name of the predictor.
    public var predictorName: Swift.String?
    /// The ARN and state of the reference predictor. This parameter is only valid for retrained or upgraded predictors.
    public var referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary?
    /// The status of the predictor. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        dataConfig: ForecastClientTypes.DataConfig? = nil,
        datasetImportJobArns: [Swift.String]? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        explainabilityInfo: ForecastClientTypes.ExplainabilityInfo? = nil,
        forecastFrequency: Swift.String? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorArn: Swift.String? = nil,
        predictorName: Swift.String? = nil,
        referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataConfig = dataConfig
        self.datasetImportJobArns = datasetImportJobArns
        self.encryptionConfig = encryptionConfig
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.explainabilityInfo = explainabilityInfo
        self.forecastFrequency = forecastFrequency
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.optimizationMetric = optimizationMetric
        self.predictorArn = predictorArn
        self.predictorName = predictorName
        self.referencePredictorSummary = referencePredictorSummary
        self.status = status
    }
}

struct DescribeAutoPredictorOutputResponseBody: Swift.Equatable {
    let predictorArn: Swift.String?
    let predictorName: Swift.String?
    let forecastHorizon: Swift.Int?
    let forecastTypes: [Swift.String]?
    let forecastFrequency: Swift.String?
    let datasetImportJobArns: [Swift.String]?
    let dataConfig: ForecastClientTypes.DataConfig?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
    let explainabilityInfo: ForecastClientTypes.ExplainabilityInfo?
}

extension DescribeAutoPredictorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataConfig = "DataConfig"
        case datasetImportJobArns = "DatasetImportJobArns"
        case encryptionConfig = "EncryptionConfig"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case explainabilityInfo = "ExplainabilityInfo"
        case forecastFrequency = "ForecastFrequency"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case optimizationMetric = "OptimizationMetric"
        case predictorArn = "PredictorArn"
        case predictorName = "PredictorName"
        case referencePredictorSummary = "ReferencePredictorSummary"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let forecastFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastFrequency)
        forecastFrequency = forecastFrequencyDecoded
        let datasetImportJobArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetImportJobArns)
        var datasetImportJobArnsDecoded0:[Swift.String]? = nil
        if let datasetImportJobArnsContainer = datasetImportJobArnsContainer {
            datasetImportJobArnsDecoded0 = [Swift.String]()
            for string0 in datasetImportJobArnsContainer {
                if let string0 = string0 {
                    datasetImportJobArnsDecoded0?.append(string0)
                }
            }
        }
        datasetImportJobArns = datasetImportJobArnsDecoded0
        let dataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataConfig.self, forKey: .dataConfig)
        dataConfig = dataConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let referencePredictorSummaryDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ReferencePredictorSummary.self, forKey: .referencePredictorSummary)
        referencePredictorSummary = referencePredictorSummaryDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
        let explainabilityInfoDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ExplainabilityInfo.self, forKey: .explainabilityInfo)
        explainabilityInfo = explainabilityInfoDecoded
    }
}

extension DescribeDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension DescribeDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DescribeDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension DescribeDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DescribeDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.datasetArns = output.datasetArns
            self.datasetGroupArn = output.datasetGroupArn
            self.datasetGroupName = output.datasetGroupName
            self.domain = output.domain
            self.lastModificationTime = output.lastModificationTime
            self.status = output.status
        } else {
            self.creationTime = nil
            self.datasetArns = nil
            self.datasetGroupArn = nil
            self.datasetGroupName = nil
            self.domain = nil
            self.lastModificationTime = nil
            self.status = nil
        }
    }
}

public struct DescribeDatasetGroupOutputResponse: Swift.Equatable {
    /// When the dataset group was created.
    public var creationTime: ClientRuntime.Date?
    /// An array of Amazon Resource Names (ARNs) of the datasets contained in the dataset group.
    public var datasetArns: [Swift.String]?
    /// The ARN of the dataset group.
    public var datasetGroupArn: Swift.String?
    /// The name of the dataset group.
    public var datasetGroupName: Swift.String?
    /// The domain associated with the dataset group.
    public var domain: ForecastClientTypes.Domain?
    /// When the dataset group was created or last updated from a call to the [UpdateDatasetGroup] operation. While the dataset group is being updated, LastModificationTime is the current time of the DescribeDatasetGroup call.
    public var lastModificationTime: ClientRuntime.Date?
    /// The status of the dataset group. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED
    ///
    ///
    /// The UPDATE states apply when you call the [UpdateDatasetGroup] operation. The Status of the dataset group must be ACTIVE before you can use the dataset group to create a predictor.
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        datasetArns: [Swift.String]? = nil,
        datasetGroupArn: Swift.String? = nil,
        datasetGroupName: Swift.String? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetArns = datasetArns
        self.datasetGroupArn = datasetGroupArn
        self.datasetGroupName = datasetGroupName
        self.domain = domain
        self.lastModificationTime = lastModificationTime
        self.status = status
    }
}

struct DescribeDatasetGroupOutputResponseBody: Swift.Equatable {
    let datasetGroupName: Swift.String?
    let datasetGroupArn: Swift.String?
    let datasetArns: [Swift.String]?
    let domain: ForecastClientTypes.Domain?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeDatasetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case lastModificationTime = "LastModificationTime"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[Swift.String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [Swift.String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DescribeDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

extension DescribeDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetImportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DescribeDatasetImportJobInputBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension DescribeDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DescribeDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataSize = output.dataSize
            self.dataSource = output.dataSource
            self.datasetArn = output.datasetArn
            self.datasetImportJobArn = output.datasetImportJobArn
            self.datasetImportJobName = output.datasetImportJobName
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.fieldStatistics = output.fieldStatistics
            self.geolocationFormat = output.geolocationFormat
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
            self.timeZone = output.timeZone
            self.timestampFormat = output.timestampFormat
            self.useGeolocationForTimeZone = output.useGeolocationForTimeZone
        } else {
            self.creationTime = nil
            self.dataSize = nil
            self.dataSource = nil
            self.datasetArn = nil
            self.datasetImportJobArn = nil
            self.datasetImportJobName = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.fieldStatistics = nil
            self.geolocationFormat = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
            self.timeZone = nil
            self.timestampFormat = nil
            self.useGeolocationForTimeZone = false
        }
    }
}

public struct DescribeDatasetImportJobOutputResponse: Swift.Equatable {
    /// When the dataset import job was created.
    public var creationTime: ClientRuntime.Date?
    /// The size of the dataset in gigabytes (GB) after the import job has finished.
    public var dataSize: Swift.Double?
    /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. If encryption is used, DataSource includes an AWS Key Management Service (KMS) key.
    public var dataSource: ForecastClientTypes.DataSource?
    /// The Amazon Resource Name (ARN) of the dataset that the training data was imported to.
    public var datasetArn: Swift.String?
    /// The ARN of the dataset import job.
    public var datasetImportJobArn: Swift.String?
    /// The name of the dataset import job.
    public var datasetImportJobName: Swift.String?
    /// The estimated time remaining in minutes for the dataset import job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Statistical information about each field in the input data.
    public var fieldStatistics: [Swift.String:ForecastClientTypes.Statistics]?
    /// The format of the geolocation attribute. Valid Values:"LAT_LONG" and "CC_POSTALCODE".
    public var geolocationFormat: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the dataset import job. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    public var status: Swift.String?
    /// The single time zone applied to every item in the dataset
    public var timeZone: Swift.String?
    /// The format of timestamps in the dataset. The format that you specify depends on the DataFrequency specified when the dataset was created. The following formats are supported
    ///
    /// * "yyyy-MM-dd" For the following data frequencies: Y, M, W, and D
    ///
    /// * "yyyy-MM-dd HH:mm:ss" For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D
    public var timestampFormat: Swift.String?
    /// Whether TimeZone is automatically derived from the geolocation attribute.
    public var useGeolocationForTimeZone: Swift.Bool

    public init (
        creationTime: ClientRuntime.Date? = nil,
        dataSize: Swift.Double? = nil,
        dataSource: ForecastClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        datasetImportJobArn: Swift.String? = nil,
        datasetImportJobName: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        fieldStatistics: [Swift.String:ForecastClientTypes.Statistics]? = nil,
        geolocationFormat: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil,
        timeZone: Swift.String? = nil,
        timestampFormat: Swift.String? = nil,
        useGeolocationForTimeZone: Swift.Bool = false
    )
    {
        self.creationTime = creationTime
        self.dataSize = dataSize
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobArn = datasetImportJobArn
        self.datasetImportJobName = datasetImportJobName
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.fieldStatistics = fieldStatistics
        self.geolocationFormat = geolocationFormat
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

struct DescribeDatasetImportJobOutputResponseBody: Swift.Equatable {
    let datasetImportJobName: Swift.String?
    let datasetImportJobArn: Swift.String?
    let datasetArn: Swift.String?
    let timestampFormat: Swift.String?
    let timeZone: Swift.String?
    let useGeolocationForTimeZone: Swift.Bool
    let geolocationFormat: Swift.String?
    let dataSource: ForecastClientTypes.DataSource?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let fieldStatistics: [Swift.String:ForecastClientTypes.Statistics]?
    let dataSize: Swift.Double?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeDatasetImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataSize = "DataSize"
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobArn = "DatasetImportJobArn"
        case datasetImportJobName = "DatasetImportJobName"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case fieldStatistics = "FieldStatistics"
        case geolocationFormat = "GeolocationFormat"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let timestampFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let useGeolocationForTimeZoneDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useGeolocationForTimeZone)
        useGeolocationForTimeZone = useGeolocationForTimeZoneDecoded
        let geolocationFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geolocationFormat)
        geolocationFormat = geolocationFormatDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let fieldStatisticsContainer = try containerValues.decodeIfPresent([Swift.String: ForecastClientTypes.Statistics?].self, forKey: .fieldStatistics)
        var fieldStatisticsDecoded0: [Swift.String:ForecastClientTypes.Statistics]? = nil
        if let fieldStatisticsContainer = fieldStatisticsContainer {
            fieldStatisticsDecoded0 = [Swift.String:ForecastClientTypes.Statistics]()
            for (key0, statistics0) in fieldStatisticsContainer {
                if let statistics0 = statistics0 {
                    fieldStatisticsDecoded0?[key0] = statistics0
                }
            }
        }
        fieldStatistics = fieldStatisticsDecoded0
        let dataSizeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dataSize)
        dataSize = dataSizeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DescribeDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

extension DescribeDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension DescribeDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DescribeDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataFrequency = output.dataFrequency
            self.datasetArn = output.datasetArn
            self.datasetName = output.datasetName
            self.datasetType = output.datasetType
            self.domain = output.domain
            self.encryptionConfig = output.encryptionConfig
            self.lastModificationTime = output.lastModificationTime
            self.schema = output.schema
            self.status = output.status
        } else {
            self.creationTime = nil
            self.dataFrequency = nil
            self.datasetArn = nil
            self.datasetName = nil
            self.datasetType = nil
            self.domain = nil
            self.encryptionConfig = nil
            self.lastModificationTime = nil
            self.schema = nil
            self.status = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Swift.Equatable {
    /// When the dataset was created.
    public var creationTime: ClientRuntime.Date?
    /// The frequency of data collection. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "M" indicates every month and "30min" indicates every 30 minutes.
    public var dataFrequency: Swift.String?
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?
    /// The name of the dataset.
    public var datasetName: Swift.String?
    /// The dataset type.
    public var datasetType: ForecastClientTypes.DatasetType?
    /// The domain associated with the dataset.
    public var domain: ForecastClientTypes.Domain?
    /// The AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// When you create a dataset, LastModificationTime is the same as CreationTime. While data is being imported to the dataset, LastModificationTime is the current time of the DescribeDataset call. After a [CreateDatasetImportJob] operation has finished, LastModificationTime is when the import job completed or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// An array of SchemaAttribute objects that specify the dataset fields. Each SchemaAttribute specifies the name and data type of a field.
    public var schema: ForecastClientTypes.Schema?
    /// The status of the dataset. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED
    ///
    ///
    /// The UPDATE states apply while data is imported to the dataset from a call to the [CreateDatasetImportJob] operation and reflect the status of the dataset import job. For example, when the import job status is CREATE_IN_PROGRESS, the status of the dataset is UPDATE_IN_PROGRESS. The Status of the dataset must be ACTIVE before you can import training data.
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        dataFrequency: Swift.String? = nil,
        datasetArn: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        datasetType: ForecastClientTypes.DatasetType? = nil,
        domain: ForecastClientTypes.Domain? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataFrequency = dataFrequency
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.encryptionConfig = encryptionConfig
        self.lastModificationTime = lastModificationTime
        self.schema = schema
        self.status = status
    }
}

struct DescribeDatasetOutputResponseBody: Swift.Equatable {
    let datasetArn: Swift.String?
    let datasetName: Swift.String?
    let domain: ForecastClientTypes.Domain?
    let datasetType: ForecastClientTypes.DatasetType?
    let dataFrequency: Swift.String?
    let schema: ForecastClientTypes.Schema?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataFrequency = "DataFrequency"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case lastModificationTime = "LastModificationTime"
        case schema = "Schema"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let dataFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataFrequency)
        dataFrequency = dataFrequencyDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DescribeExplainabilityExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityExportArn = explainabilityExportArn {
            try encodeContainer.encode(explainabilityExportArn, forKey: .explainabilityExportArn)
        }
    }
}

extension DescribeExplainabilityExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExplainabilityExportInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explainability export.
    /// This member is required.
    public var explainabilityExportArn: Swift.String?

    public init (
        explainabilityExportArn: Swift.String? = nil
    )
    {
        self.explainabilityExportArn = explainabilityExportArn
    }
}

struct DescribeExplainabilityExportInputBody: Swift.Equatable {
    let explainabilityExportArn: Swift.String?
}

extension DescribeExplainabilityExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExportArn = "ExplainabilityExportArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
    }
}

extension DescribeExplainabilityExportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExplainabilityExportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExplainabilityExportOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExplainabilityExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeExplainabilityExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.explainabilityArn = output.explainabilityArn
            self.explainabilityExportArn = output.explainabilityExportArn
            self.explainabilityExportName = output.explainabilityExportName
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.explainabilityArn = nil
            self.explainabilityExportArn = nil
            self.explainabilityExportName = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
        }
    }
}

public struct DescribeExplainabilityExportOutputResponse: Swift.Equatable {
    /// When the Explainability export was created.
    public var creationTime: ClientRuntime.Date?
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the Explainability.
    public var explainabilityArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the Explainability export.
    public var explainabilityExportArn: Swift.String?
    /// The name of the Explainability export.
    public var explainabilityExportName: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// Information about any errors that occurred during the export.
    public var message: Swift.String?
    /// The status of the Explainability export. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        explainabilityArn: Swift.String? = nil,
        explainabilityExportArn: Swift.String? = nil,
        explainabilityExportName: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.explainabilityArn = explainabilityArn
        self.explainabilityExportArn = explainabilityExportArn
        self.explainabilityExportName = explainabilityExportName
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
    }
}

struct DescribeExplainabilityExportOutputResponseBody: Swift.Equatable {
    let explainabilityExportArn: Swift.String?
    let explainabilityExportName: Swift.String?
    let explainabilityArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeExplainabilityExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityExportArn = "ExplainabilityExportArn"
        case explainabilityExportName = "ExplainabilityExportName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
        let explainabilityExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportName)
        explainabilityExportName = explainabilityExportNameDecoded
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DescribeExplainabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityArn = explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
    }
}

extension DescribeExplainabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExplainabilityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Explaianability to describe.
    /// This member is required.
    public var explainabilityArn: Swift.String?

    public init (
        explainabilityArn: Swift.String? = nil
    )
    {
        self.explainabilityArn = explainabilityArn
    }
}

struct DescribeExplainabilityInputBody: Swift.Equatable {
    let explainabilityArn: Swift.String?
}

extension DescribeExplainabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
    }
}

extension DescribeExplainabilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExplainabilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExplainabilityOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExplainabilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeExplainabilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.dataSource = output.dataSource
            self.enableVisualization = output.enableVisualization
            self.endDateTime = output.endDateTime
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.explainabilityArn = output.explainabilityArn
            self.explainabilityConfig = output.explainabilityConfig
            self.explainabilityName = output.explainabilityName
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.schema = output.schema
            self.startDateTime = output.startDateTime
            self.status = output.status
        } else {
            self.creationTime = nil
            self.dataSource = nil
            self.enableVisualization = nil
            self.endDateTime = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.explainabilityArn = nil
            self.explainabilityConfig = nil
            self.explainabilityName = nil
            self.lastModificationTime = nil
            self.message = nil
            self.resourceArn = nil
            self.schema = nil
            self.startDateTime = nil
            self.status = nil
        }
    }
}

public struct DescribeExplainabilityOutputResponse: Swift.Equatable {
    /// When the Explainability resource was created.
    public var creationTime: ClientRuntime.Date?
    /// The source of your training data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the data and, optionally, an AWS Key Management Service (KMS) key. This object is submitted in the [CreateDatasetImportJob] request.
    public var dataSource: ForecastClientTypes.DataSource?
    /// Whether the visualization was enabled for the Explainability resource.
    public var enableVisualization: Swift.Bool?
    /// If TimePointGranularity is set to SPECIFIC, the last time point in the Explainability.
    public var endDateTime: Swift.String?
    /// The estimated time remaining in minutes for the [CreateExplainability] job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Explainability.
    public var explainabilityArn: Swift.String?
    /// The configuration settings that define the granularity of time series and time points for the Explainability.
    public var explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    /// The name of the Explainability.
    public var explainabilityName: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, a message about the error.
    public var message: Swift.String?
    /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability resource.
    public var resourceArn: Swift.String?
    /// Defines the fields of a dataset. You specify this object in the [CreateDataset] request.
    public var schema: ForecastClientTypes.Schema?
    /// If TimePointGranularity is set to SPECIFIC, the first time point in the Explainability.
    public var startDateTime: Swift.String?
    /// The status of the Explainability resource. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        dataSource: ForecastClientTypes.DataSource? = nil,
        enableVisualization: Swift.Bool? = nil,
        endDateTime: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        explainabilityArn: Swift.String? = nil,
        explainabilityConfig: ForecastClientTypes.ExplainabilityConfig? = nil,
        explainabilityName: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        schema: ForecastClientTypes.Schema? = nil,
        startDateTime: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataSource = dataSource
        self.enableVisualization = enableVisualization
        self.endDateTime = endDateTime
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.explainabilityArn = explainabilityArn
        self.explainabilityConfig = explainabilityConfig
        self.explainabilityName = explainabilityName
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.resourceArn = resourceArn
        self.schema = schema
        self.startDateTime = startDateTime
        self.status = status
    }
}

struct DescribeExplainabilityOutputResponseBody: Swift.Equatable {
    let explainabilityArn: Swift.String?
    let explainabilityName: Swift.String?
    let resourceArn: Swift.String?
    let explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
    let enableVisualization: Swift.Bool?
    let dataSource: ForecastClientTypes.DataSource?
    let schema: ForecastClientTypes.Schema?
    let startDateTime: Swift.String?
    let endDateTime: Swift.String?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeExplainabilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataSource = "DataSource"
        case enableVisualization = "EnableVisualization"
        case endDateTime = "EndDateTime"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityConfig = "ExplainabilityConfig"
        case explainabilityName = "ExplainabilityName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case resourceArn = "ResourceArn"
        case schema = "Schema"
        case startDateTime = "StartDateTime"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let explainabilityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityName)
        explainabilityName = explainabilityNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let explainabilityConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ExplainabilityConfig.self, forKey: .explainabilityConfig)
        explainabilityConfig = explainabilityConfigDecoded
        let enableVisualizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableVisualization)
        enableVisualization = enableVisualizationDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DescribeForecastExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastExportJobArn = forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
    }
}

extension DescribeForecastExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeForecastExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast export job.
    /// This member is required.
    public var forecastExportJobArn: Swift.String?

    public init (
        forecastExportJobArn: Swift.String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct DescribeForecastExportJobInputBody: Swift.Equatable {
    let forecastExportJobArn: Swift.String?
}

extension DescribeForecastExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

extension DescribeForecastExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeForecastExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeForecastExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeForecastExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeForecastExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.forecastArn = output.forecastArn
            self.forecastExportJobArn = output.forecastExportJobArn
            self.forecastExportJobName = output.forecastExportJobName
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.forecastArn = nil
            self.forecastExportJobArn = nil
            self.forecastExportJobName = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
        }
    }
}

public struct DescribeForecastExportJobOutputResponse: Swift.Equatable {
    /// When the forecast export job was created.
    public var creationTime: ClientRuntime.Date?
    /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
    public var destination: ForecastClientTypes.DataDestination?
    /// The Amazon Resource Name (ARN) of the exported forecast.
    public var forecastArn: Swift.String?
    /// The ARN of the forecast export job.
    public var forecastExportJobArn: Swift.String?
    /// The name of the forecast export job.
    public var forecastExportJobName: Swift.String?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The status of the forecast export job. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the forecast export job must be ACTIVE before you can access the forecast in your S3 bucket.
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        forecastArn: Swift.String? = nil,
        forecastExportJobArn: Swift.String? = nil,
        forecastExportJobName: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.forecastArn = forecastArn
        self.forecastExportJobArn = forecastExportJobArn
        self.forecastExportJobName = forecastExportJobName
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
    }
}

struct DescribeForecastExportJobOutputResponseBody: Swift.Equatable {
    let forecastExportJobArn: Swift.String?
    let forecastExportJobName: Swift.String?
    let forecastArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeForecastExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobArn = "ForecastExportJobArn"
        case forecastExportJobName = "ForecastExportJobName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DescribeForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
    }
}

extension DescribeForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeForecastInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the forecast.
    /// This member is required.
    public var forecastArn: Swift.String?

    public init (
        forecastArn: Swift.String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct DescribeForecastInputBody: Swift.Equatable {
    let forecastArn: Swift.String?
}

extension DescribeForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

extension DescribeForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeForecastOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeForecastOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.datasetGroupArn = output.datasetGroupArn
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.forecastArn = output.forecastArn
            self.forecastName = output.forecastName
            self.forecastTypes = output.forecastTypes
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.predictorArn = output.predictorArn
            self.status = output.status
        } else {
            self.creationTime = nil
            self.datasetGroupArn = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.forecastArn = nil
            self.forecastName = nil
            self.forecastTypes = nil
            self.lastModificationTime = nil
            self.message = nil
            self.predictorArn = nil
            self.status = nil
        }
    }
}

public struct DescribeForecastOutputResponse: Swift.Equatable {
    /// When the forecast creation task was created.
    public var creationTime: ClientRuntime.Date?
    /// The ARN of the dataset group that provided the data used to train the predictor.
    public var datasetGroupArn: Swift.String?
    /// The estimated time remaining in minutes for the forecast job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// The forecast ARN as specified in the request.
    public var forecastArn: Swift.String?
    /// The name of the forecast.
    public var forecastName: Swift.String?
    /// The quantiles at which probabilistic forecasts were generated.
    public var forecastTypes: [Swift.String]?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The ARN of the predictor used to generate the forecast.
    public var predictorArn: Swift.String?
    /// The status of the forecast. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    ///
    /// The Status of the forecast must be ACTIVE before you can query or export the forecast.
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        datasetGroupArn: Swift.String? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        forecastArn: Swift.String? = nil,
        forecastName: Swift.String? = nil,
        forecastTypes: [Swift.String]? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetGroupArn = datasetGroupArn
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.forecastArn = forecastArn
        self.forecastName = forecastName
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.status = status
    }
}

struct DescribeForecastOutputResponseBody: Swift.Equatable {
    let forecastArn: Swift.String?
    let forecastName: Swift.String?
    let forecastTypes: [Swift.String]?
    let predictorArn: Swift.String?
    let datasetGroupArn: Swift.String?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribeForecastOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case forecastArn = "ForecastArn"
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let forecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DescribePredictorBacktestExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorBacktestExportJobArn = predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
    }
}

extension DescribePredictorBacktestExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePredictorBacktestExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor backtest export job.
    /// This member is required.
    public var predictorBacktestExportJobArn: Swift.String?

    public init (
        predictorBacktestExportJobArn: Swift.String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct DescribePredictorBacktestExportJobInputBody: Swift.Equatable {
    let predictorBacktestExportJobArn: Swift.String?
}

extension DescribePredictorBacktestExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

extension DescribePredictorBacktestExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePredictorBacktestExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePredictorBacktestExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePredictorBacktestExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePredictorBacktestExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.predictorArn = output.predictorArn
            self.predictorBacktestExportJobArn = output.predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = output.predictorBacktestExportJobName
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.lastModificationTime = nil
            self.message = nil
            self.predictorArn = nil
            self.predictorBacktestExportJobArn = nil
            self.predictorBacktestExportJobName = nil
            self.status = nil
        }
    }
}

public struct DescribePredictorBacktestExportJobOutputResponse: Swift.Equatable {
    /// When the predictor backtest export job was created.
    public var creationTime: ClientRuntime.Date?
    /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
    public var destination: ForecastClientTypes.DataDestination?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// Information about any errors that may have occurred during the backtest export.
    public var message: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor.
    public var predictorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the predictor backtest export job.
    public var predictorBacktestExportJobArn: Swift.String?
    /// The name of the predictor backtest export job.
    public var predictorBacktestExportJobName: Swift.String?
    /// The status of the predictor backtest export job. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    public var status: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        destination: ForecastClientTypes.DataDestination? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        predictorArn: Swift.String? = nil,
        predictorBacktestExportJobArn: Swift.String? = nil,
        predictorBacktestExportJobName: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.status = status
    }
}

struct DescribePredictorBacktestExportJobOutputResponseBody: Swift.Equatable {
    let predictorBacktestExportJobArn: Swift.String?
    let predictorBacktestExportJobName: Swift.String?
    let predictorArn: Swift.String?
    let destination: ForecastClientTypes.DataDestination?
    let message: Swift.String?
    let status: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension DescribePredictorBacktestExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DescribePredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

extension DescribePredictorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePredictorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor that you want information about.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DescribePredictorInputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension DescribePredictorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DescribePredictorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePredictorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePredictorOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePredictorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePredictorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.algorithmArn = output.algorithmArn
            self.autoMLAlgorithmArns = output.autoMLAlgorithmArns
            self.autoMLOverrideStrategy = output.autoMLOverrideStrategy
            self.creationTime = output.creationTime
            self.datasetImportJobArns = output.datasetImportJobArns
            self.encryptionConfig = output.encryptionConfig
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.evaluationParameters = output.evaluationParameters
            self.featurizationConfig = output.featurizationConfig
            self.forecastHorizon = output.forecastHorizon
            self.forecastTypes = output.forecastTypes
            self.hPOConfig = output.hPOConfig
            self.inputDataConfig = output.inputDataConfig
            self.isAutoPredictor = output.isAutoPredictor
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.optimizationMetric = output.optimizationMetric
            self.performAutoML = output.performAutoML
            self.performHPO = output.performHPO
            self.predictorArn = output.predictorArn
            self.predictorExecutionDetails = output.predictorExecutionDetails
            self.predictorName = output.predictorName
            self.status = output.status
            self.trainingParameters = output.trainingParameters
        } else {
            self.algorithmArn = nil
            self.autoMLAlgorithmArns = nil
            self.autoMLOverrideStrategy = nil
            self.creationTime = nil
            self.datasetImportJobArns = nil
            self.encryptionConfig = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.evaluationParameters = nil
            self.featurizationConfig = nil
            self.forecastHorizon = nil
            self.forecastTypes = nil
            self.hPOConfig = nil
            self.inputDataConfig = nil
            self.isAutoPredictor = nil
            self.lastModificationTime = nil
            self.message = nil
            self.optimizationMetric = nil
            self.performAutoML = nil
            self.performHPO = nil
            self.predictorArn = nil
            self.predictorExecutionDetails = nil
            self.predictorName = nil
            self.status = nil
            self.trainingParameters = nil
        }
    }
}

public struct DescribePredictorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the algorithm used for model training.
    public var algorithmArn: Swift.String?
    /// When PerformAutoML is specified, the ARN of the chosen algorithm.
    public var autoMLAlgorithmArns: [Swift.String]?
    /// The LatencyOptimized AutoML override strategy is only available in private beta. Contact AWS Support or your account manager to learn more about access privileges. The AutoML strategy used to train the predictor. Unless LatencyOptimized is specified, the AutoML strategy optimizes predictor accuracy. This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// When the model training task was created.
    public var creationTime: ClientRuntime.Date?
    /// An array of the ARNs of the dataset import jobs used to import training data for the predictor.
    public var datasetImportJobArns: [Swift.String]?
    /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
    public var encryptionConfig: ForecastClientTypes.EncryptionConfig?
    /// The estimated time remaining in minutes for the predictor training job to complete.
    public var estimatedTimeRemainingInMinutes: Swift.Int?
    /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
    public var evaluationParameters: ForecastClientTypes.EvaluationParameters?
    /// The featurization configuration.
    public var featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    /// The number of time-steps of the forecast. The forecast horizon is also called the prediction length.
    public var forecastHorizon: Swift.Int?
    /// The forecast types used during predictor training. Default value is ["0.1","0.5","0.9"]
    public var forecastTypes: [Swift.String]?
    /// The hyperparameter override values for the algorithm.
    public var hPOConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    /// Describes the dataset group that contains the data to use to train the predictor.
    public var inputDataConfig: ForecastClientTypes.InputDataConfig?
    /// Whether the predictor was created with [CreateAutoPredictor].
    public var isAutoPredictor: Swift.Bool?
    /// The last time the resource was modified. The timestamp depends on the status of the job:
    ///
    /// * CREATE_PENDING - The CreationTime.
    ///
    /// * CREATE_IN_PROGRESS - The current timestamp.
    ///
    /// * CREATE_STOPPING - The current timestamp.
    ///
    /// * CREATE_STOPPED - When the job stopped.
    ///
    /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
    public var lastModificationTime: ClientRuntime.Date?
    /// If an error occurred, an informational message about the error.
    public var message: Swift.String?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// Whether the predictor is set to perform AutoML.
    public var performAutoML: Swift.Bool?
    /// Whether the predictor is set to perform hyperparameter optimization (HPO).
    public var performHPO: Swift.Bool?
    /// The ARN of the predictor.
    public var predictorArn: Swift.String?
    /// Details on the the status and results of the backtests performed to evaluate the accuracy of the predictor. You specify the number of backtests to perform when you call the operation.
    public var predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails?
    /// The name of the predictor.
    public var predictorName: Swift.String?
    /// The status of the predictor. States include:
    ///
    /// * ACTIVE
    ///
    /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
    ///
    /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
    ///
    /// * CREATE_STOPPING, CREATE_STOPPED
    ///
    ///
    /// The Status of the predictor must be ACTIVE before you can use the predictor to create a forecast.
    public var status: Swift.String?
    /// The default training parameters or overrides selected during model training. When running AutoML or choosing HPO with CNN-QR or DeepAR+, the optimized values for the chosen hyperparameters are returned. For more information, see [aws-forecast-choosing-recipes].
    public var trainingParameters: [Swift.String:Swift.String]?

    public init (
        algorithmArn: Swift.String? = nil,
        autoMLAlgorithmArns: [Swift.String]? = nil,
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        creationTime: ClientRuntime.Date? = nil,
        datasetImportJobArns: [Swift.String]? = nil,
        encryptionConfig: ForecastClientTypes.EncryptionConfig? = nil,
        estimatedTimeRemainingInMinutes: Swift.Int? = nil,
        evaluationParameters: ForecastClientTypes.EvaluationParameters? = nil,
        featurizationConfig: ForecastClientTypes.FeaturizationConfig? = nil,
        forecastHorizon: Swift.Int? = nil,
        forecastTypes: [Swift.String]? = nil,
        hPOConfig: ForecastClientTypes.HyperParameterTuningJobConfig? = nil,
        inputDataConfig: ForecastClientTypes.InputDataConfig? = nil,
        isAutoPredictor: Swift.Bool? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        performAutoML: Swift.Bool? = nil,
        performHPO: Swift.Bool? = nil,
        predictorArn: Swift.String? = nil,
        predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails? = nil,
        predictorName: Swift.String? = nil,
        status: Swift.String? = nil,
        trainingParameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.autoMLAlgorithmArns = autoMLAlgorithmArns
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.creationTime = creationTime
        self.datasetImportJobArns = datasetImportJobArns
        self.encryptionConfig = encryptionConfig
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.evaluationParameters = evaluationParameters
        self.featurizationConfig = featurizationConfig
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.hPOConfig = hPOConfig
        self.inputDataConfig = inputDataConfig
        self.isAutoPredictor = isAutoPredictor
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.optimizationMetric = optimizationMetric
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.predictorArn = predictorArn
        self.predictorExecutionDetails = predictorExecutionDetails
        self.predictorName = predictorName
        self.status = status
        self.trainingParameters = trainingParameters
    }
}

struct DescribePredictorOutputResponseBody: Swift.Equatable {
    let predictorArn: Swift.String?
    let predictorName: Swift.String?
    let algorithmArn: Swift.String?
    let autoMLAlgorithmArns: [Swift.String]?
    let forecastHorizon: Swift.Int?
    let forecastTypes: [Swift.String]?
    let performAutoML: Swift.Bool?
    let autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    let performHPO: Swift.Bool?
    let trainingParameters: [Swift.String:Swift.String]?
    let evaluationParameters: ForecastClientTypes.EvaluationParameters?
    let hPOConfig: ForecastClientTypes.HyperParameterTuningJobConfig?
    let inputDataConfig: ForecastClientTypes.InputDataConfig?
    let featurizationConfig: ForecastClientTypes.FeaturizationConfig?
    let encryptionConfig: ForecastClientTypes.EncryptionConfig?
    let predictorExecutionDetails: ForecastClientTypes.PredictorExecutionDetails?
    let estimatedTimeRemainingInMinutes: Swift.Int?
    let isAutoPredictor: Swift.Bool?
    let datasetImportJobArns: [Swift.String]?
    let status: Swift.String?
    let message: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
}

extension DescribePredictorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLAlgorithmArns = "AutoMLAlgorithmArns"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case creationTime = "CreationTime"
        case datasetImportJobArns = "DatasetImportJobArns"
        case encryptionConfig = "EncryptionConfig"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hPOConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case isAutoPredictor = "IsAutoPredictor"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case optimizationMetric = "OptimizationMetric"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorArn = "PredictorArn"
        case predictorExecutionDetails = "PredictorExecutionDetails"
        case predictorName = "PredictorName"
        case status = "Status"
        case trainingParameters = "TrainingParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let autoMLAlgorithmArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .autoMLAlgorithmArns)
        var autoMLAlgorithmArnsDecoded0:[Swift.String]? = nil
        if let autoMLAlgorithmArnsContainer = autoMLAlgorithmArnsContainer {
            autoMLAlgorithmArnsDecoded0 = [Swift.String]()
            for string0 in autoMLAlgorithmArnsContainer {
                if let string0 = string0 {
                    autoMLAlgorithmArnsDecoded0?.append(string0)
                }
            }
        }
        autoMLAlgorithmArns = autoMLAlgorithmArnsDecoded0
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[Swift.String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [Swift.String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let trainingParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .trainingParameters)
        var trainingParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let trainingParametersContainer = trainingParametersContainer {
            trainingParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in trainingParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    trainingParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        trainingParameters = trainingParametersDecoded0
        let evaluationParametersDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EvaluationParameters.self, forKey: .evaluationParameters)
        evaluationParameters = evaluationParametersDecoded
        let hPOConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.HyperParameterTuningJobConfig.self, forKey: .hPOConfig)
        hPOConfig = hPOConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let featurizationConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FeaturizationConfig.self, forKey: .featurizationConfig)
        featurizationConfig = featurizationConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let predictorExecutionDetailsDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.PredictorExecutionDetails.self, forKey: .predictorExecutionDetails)
        predictorExecutionDetails = predictorExecutionDetailsDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let isAutoPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAutoPredictor)
        isAutoPredictor = isAutoPredictorDecoded
        let datasetImportJobArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetImportJobArns)
        var datasetImportJobArnsDecoded0:[Swift.String]? = nil
        if let datasetImportJobArnsContainer = datasetImportJobArnsContainer {
            datasetImportJobArnsDecoded0 = [Swift.String]()
            for string0 in datasetImportJobArnsContainer {
                if let string0 = string0 {
                    datasetImportJobArnsDecoded0?.append(string0)
                }
            }
        }
        datasetImportJobArns = datasetImportJobArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
    }
}

extension ForecastClientTypes {
    public enum Domain: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case ec2Capacity
        case inventoryPlanning
        case metrics
        case retail
        case webTraffic
        case workForce
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .custom,
                .ec2Capacity,
                .inventoryPlanning,
                .metrics,
                .retail,
                .webTraffic,
                .workForce,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .ec2Capacity: return "EC2_CAPACITY"
            case .inventoryPlanning: return "INVENTORY_PLANNING"
            case .metrics: return "METRICS"
            case .retail: return "RETAIL"
            case .webTraffic: return "WEB_TRAFFIC"
            case .workForce: return "WORK_FORCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Domain(rawValue: rawValue) ?? Domain.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.EncryptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kMSKeyArn = "KMSKeyArn"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
    }
}

extension ForecastClientTypes {
    /// An AWS Key Management Service (KMS) key and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key. You can specify this optional object in the [CreateDataset] and [CreatePredictor] requests.
    public struct EncryptionConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the KMS key.
        /// This member is required.
        public var kMSKeyArn: Swift.String?
        /// The ARN of the IAM role that Amazon Forecast can assume to access the AWS KMS key. Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an InvalidInputException error.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            kMSKeyArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kMSKeyArn = kMSKeyArn
            self.roleArn = roleArn
        }
    }

}

extension ForecastClientTypes.ErrorMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastType = "ForecastType"
        case mAPE = "MAPE"
        case mASE = "MASE"
        case rMSE = "RMSE"
        case wAPE = "WAPE"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastType = forecastType {
            try encodeContainer.encode(forecastType, forKey: .forecastType)
        }
        if let mAPE = mAPE {
            try encodeContainer.encode(mAPE, forKey: .mAPE)
        }
        if let mASE = mASE {
            try encodeContainer.encode(mASE, forKey: .mASE)
        }
        if let rMSE = rMSE {
            try encodeContainer.encode(rMSE, forKey: .rMSE)
        }
        if let wAPE = wAPE {
            try encodeContainer.encode(wAPE, forKey: .wAPE)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastType)
        forecastType = forecastTypeDecoded
        let wAPEDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .wAPE)
        wAPE = wAPEDecoded
        let rMSEDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rMSE)
        rMSE = rMSEDecoded
        let mASEDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .mASE)
        mASE = mASEDecoded
        let mAPEDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .mAPE)
        mAPE = mAPEDecoded
    }
}

extension ForecastClientTypes {
    /// Provides detailed error metrics to evaluate the performance of a predictor. This object is part of the [Metrics] object.
    public struct ErrorMetric: Swift.Equatable {
        /// The Forecast type used to compute WAPE, MAPE, MASE, and RMSE.
        public var forecastType: Swift.String?
        /// The Mean Absolute Percentage Error (MAPE)
        public var mAPE: Swift.Double?
        /// The Mean Absolute Scaled Error (MASE)
        public var mASE: Swift.Double?
        /// The root-mean-square error (RMSE).
        public var rMSE: Swift.Double?
        /// The weighted absolute percentage error (WAPE).
        public var wAPE: Swift.Double?

        public init (
            forecastType: Swift.String? = nil,
            mAPE: Swift.Double? = nil,
            mASE: Swift.Double? = nil,
            rMSE: Swift.Double? = nil,
            wAPE: Swift.Double? = nil
        )
        {
            self.forecastType = forecastType
            self.mAPE = mAPE
            self.mASE = mASE
            self.rMSE = rMSE
            self.wAPE = wAPE
        }
    }

}

extension ForecastClientTypes.EvaluationParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backTestWindowOffset = "BackTestWindowOffset"
        case numberOfBacktestWindows = "NumberOfBacktestWindows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backTestWindowOffset = backTestWindowOffset {
            try encodeContainer.encode(backTestWindowOffset, forKey: .backTestWindowOffset)
        }
        if let numberOfBacktestWindows = numberOfBacktestWindows {
            try encodeContainer.encode(numberOfBacktestWindows, forKey: .numberOfBacktestWindows)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfBacktestWindowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBacktestWindows)
        numberOfBacktestWindows = numberOfBacktestWindowsDecoded
        let backTestWindowOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backTestWindowOffset)
        backTestWindowOffset = backTestWindowOffsetDecoded
    }
}

extension ForecastClientTypes {
    /// Parameters that define how to split a dataset into training data and testing data, and the number of iterations to perform. These parameters are specified in the predefined algorithms but you can override them in the [CreatePredictor] request.
    public struct EvaluationParameters: Swift.Equatable {
        /// The point from the end of the dataset where you want to split the data for model training and testing (evaluation). Specify the value as the number of data points. The default is the value of the forecast horizon. BackTestWindowOffset can be used to mimic a past virtual forecast start date. This value must be greater than or equal to the forecast horizon and less than half of the TARGET_TIME_SERIES dataset length. ForecastHorizon <= BackTestWindowOffset < 1/2 * TARGET_TIME_SERIES dataset length
        public var backTestWindowOffset: Swift.Int?
        /// The number of times to split the input data. The default is 1. Valid values are 1 through 5.
        public var numberOfBacktestWindows: Swift.Int?

        public init (
            backTestWindowOffset: Swift.Int? = nil,
            numberOfBacktestWindows: Swift.Int? = nil
        )
        {
            self.backTestWindowOffset = backTestWindowOffset
            self.numberOfBacktestWindows = numberOfBacktestWindows
        }
    }

}

extension ForecastClientTypes.EvaluationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case testWindows = "TestWindows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let testWindows = testWindows {
            var testWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .testWindows)
            for testwindows0 in testWindows {
                try testWindowsContainer.encode(testwindows0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let testWindowsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WindowSummary?].self, forKey: .testWindows)
        var testWindowsDecoded0:[ForecastClientTypes.WindowSummary]? = nil
        if let testWindowsContainer = testWindowsContainer {
            testWindowsDecoded0 = [ForecastClientTypes.WindowSummary]()
            for structure0 in testWindowsContainer {
                if let structure0 = structure0 {
                    testWindowsDecoded0?.append(structure0)
                }
            }
        }
        testWindows = testWindowsDecoded0
    }
}

extension ForecastClientTypes {
    /// The results of evaluating an algorithm. Returned as part of the [GetAccuracyMetrics] response.
    public struct EvaluationResult: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the algorithm that was evaluated.
        public var algorithmArn: Swift.String?
        /// The array of test windows used for evaluating the algorithm. The NumberOfBacktestWindows from the [EvaluationParameters] object determines the number of windows in the array.
        public var testWindows: [ForecastClientTypes.WindowSummary]?

        public init (
            algorithmArn: Swift.String? = nil,
            testWindows: [ForecastClientTypes.WindowSummary]? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }
    }

}

extension ForecastClientTypes {
    public enum EvaluationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case computed
        case summary
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationType] {
            return [
                .computed,
                .summary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .computed: return "COMPUTED"
            case .summary: return "SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationType(rawValue: rawValue) ?? EvaluationType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ExplainabilityConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timePointGranularity = "TimePointGranularity"
        case timeSeriesGranularity = "TimeSeriesGranularity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timePointGranularity = timePointGranularity {
            try encodeContainer.encode(timePointGranularity.rawValue, forKey: .timePointGranularity)
        }
        if let timeSeriesGranularity = timeSeriesGranularity {
            try encodeContainer.encode(timeSeriesGranularity.rawValue, forKey: .timeSeriesGranularity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesGranularityDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimeSeriesGranularity.self, forKey: .timeSeriesGranularity)
        timeSeriesGranularity = timeSeriesGranularityDecoded
        let timePointGranularityDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.TimePointGranularity.self, forKey: .timePointGranularity)
        timePointGranularity = timePointGranularityDecoded
    }
}

extension ForecastClientTypes {
    /// The ExplainabilityConfig data type defines the number of time series and time points included in [CreateExplainability]. If you provide a predictor ARN for ResourceArn, you must set both TimePointGranularity and TimeSeriesGranularity to “ALL”. When creating Predictor Explainability, Amazon Forecast considers all time series and time points. If you provide a forecast ARN for ResourceArn, you can set TimePointGranularity and TimeSeriesGranularity to either “ALL” or “Specific”.
    public struct ExplainabilityConfig: Swift.Equatable {
        /// To create an Explainability for all time points in your forecast horizon, use ALL. To create an Explainability for specific time points in your forecast horizon, use SPECIFIC. Specify time points with the StartDateTime and EndDateTime parameters within the [CreateExplainability] operation.
        /// This member is required.
        public var timePointGranularity: ForecastClientTypes.TimePointGranularity?
        /// To create an Explainability for all time series in your datasets, use ALL. To create an Explainability for specific time series in your datasets, use SPECIFIC. Specify time series by uploading a CSV file to an Amazon S3 bucket and set the location within the [DataDestination] data type.
        /// This member is required.
        public var timeSeriesGranularity: ForecastClientTypes.TimeSeriesGranularity?

        public init (
            timePointGranularity: ForecastClientTypes.TimePointGranularity? = nil,
            timeSeriesGranularity: ForecastClientTypes.TimeSeriesGranularity? = nil
        )
        {
            self.timePointGranularity = timePointGranularity
            self.timeSeriesGranularity = timeSeriesGranularity
        }
    }

}

extension ForecastClientTypes.ExplainabilityExportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case explainabilityExportArn = "ExplainabilityExportArn"
        case explainabilityExportName = "ExplainabilityExportName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let explainabilityExportArn = explainabilityExportArn {
            try encodeContainer.encode(explainabilityExportArn, forKey: .explainabilityExportArn)
        }
        if let explainabilityExportName = explainabilityExportName {
            try encodeContainer.encode(explainabilityExportName, forKey: .explainabilityExportName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportArn)
        explainabilityExportArn = explainabilityExportArnDecoded
        let explainabilityExportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityExportName)
        explainabilityExportName = explainabilityExportNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the Explainability export properties used in the [ListExplainabilityExports] operation. To get a complete set of properties, call the [DescribeExplainabilityExport] operation, and provide the ExplainabilityExportArn.
    public struct ExplainabilityExportSummary: Swift.Equatable {
        /// When the Explainability was created.
        public var creationTime: ClientRuntime.Date?
        /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
        public var destination: ForecastClientTypes.DataDestination?
        /// The Amazon Resource Name (ARN) of the Explainability export.
        public var explainabilityExportArn: Swift.String?
        /// The name of the Explainability export
        public var explainabilityExportName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// Information about any errors that may have occurred during the Explainability export.
        public var message: Swift.String?
        /// The status of the Explainability export. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            explainabilityExportArn: Swift.String? = nil,
            explainabilityExportName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.explainabilityExportArn = explainabilityExportArn
            self.explainabilityExportName = explainabilityExportName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

extension ForecastClientTypes.ExplainabilityInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityArn = "ExplainabilityArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explainabilityArn = explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ForecastClientTypes {
    public struct ExplainabilityInfo: Swift.Equatable {
        public var explainabilityArn: Swift.String?
        public var status: Swift.String?

        public init (
            explainabilityArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.explainabilityArn = explainabilityArn
            self.status = status
        }
    }

}

extension ForecastClientTypes.ExplainabilitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case explainabilityArn = "ExplainabilityArn"
        case explainabilityConfig = "ExplainabilityConfig"
        case explainabilityName = "ExplainabilityName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case resourceArn = "ResourceArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let explainabilityArn = explainabilityArn {
            try encodeContainer.encode(explainabilityArn, forKey: .explainabilityArn)
        }
        if let explainabilityConfig = explainabilityConfig {
            try encodeContainer.encode(explainabilityConfig, forKey: .explainabilityConfig)
        }
        if let explainabilityName = explainabilityName {
            try encodeContainer.encode(explainabilityName, forKey: .explainabilityName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityArn)
        explainabilityArn = explainabilityArnDecoded
        let explainabilityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explainabilityName)
        explainabilityName = explainabilityNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let explainabilityConfigDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ExplainabilityConfig.self, forKey: .explainabilityConfig)
        explainabilityConfig = explainabilityConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the Explainability properties used in the [ListExplainabilities] operation. To get a complete set of properties, call the [DescribeExplainability] operation, and provide the listed ExplainabilityArn.
    public struct ExplainabilitySummary: Swift.Equatable {
        /// When the Explainability was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the Explainability.
        public var explainabilityArn: Swift.String?
        /// The configuration settings that define the granularity of time series and time points for the Explainability.
        public var explainabilityConfig: ForecastClientTypes.ExplainabilityConfig?
        /// The name of the Explainability.
        public var explainabilityName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// Information about any errors that may have occurred during the Explainability creation process.
        public var message: Swift.String?
        /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.
        public var resourceArn: Swift.String?
        /// The status of the Explainability. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            explainabilityArn: Swift.String? = nil,
            explainabilityConfig: ForecastClientTypes.ExplainabilityConfig? = nil,
            explainabilityName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.explainabilityArn = explainabilityArn
            self.explainabilityConfig = explainabilityConfig
            self.explainabilityName = explainabilityName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.resourceArn = resourceArn
            self.status = status
        }
    }

}

extension ForecastClientTypes.Featurization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case featurizationPipeline = "FeaturizationPipeline"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let featurizationPipeline = featurizationPipeline {
            var featurizationPipelineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featurizationPipeline)
            for featurizationpipeline0 in featurizationPipeline {
                try featurizationPipelineContainer.encode(featurizationpipeline0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let featurizationPipelineContainer = try containerValues.decodeIfPresent([ForecastClientTypes.FeaturizationMethod?].self, forKey: .featurizationPipeline)
        var featurizationPipelineDecoded0:[ForecastClientTypes.FeaturizationMethod]? = nil
        if let featurizationPipelineContainer = featurizationPipelineContainer {
            featurizationPipelineDecoded0 = [ForecastClientTypes.FeaturizationMethod]()
            for structure0 in featurizationPipelineContainer {
                if let structure0 = structure0 {
                    featurizationPipelineDecoded0?.append(structure0)
                }
            }
        }
        featurizationPipeline = featurizationPipelineDecoded0
    }
}

extension ForecastClientTypes {
    /// Provides featurization (transformation) information for a dataset field. This object is part of the [FeaturizationConfig] object. For example: {
    ///     "AttributeName": "demand",
    ///
    ///
    ///     FeaturizationPipeline [ {
    ///
    ///
    ///     "FeaturizationMethodName": "filling",
    ///
    ///
    ///     "FeaturizationMethodParameters": {"aggregation": "avg", "backfill": "nan"}
    ///
    ///
    ///     } ]
    ///
    ///
    ///     }
    public struct Featurization: Swift.Equatable {
        /// The name of the schema attribute that specifies the data field to be featurized. Amazon Forecast supports the target field of the TARGET_TIME_SERIES and the RELATED_TIME_SERIES datasets. For example, for the RETAIL domain, the target is demand, and for the CUSTOM domain, the target is target_value. For more information, see [howitworks-missing-values].
        /// This member is required.
        public var attributeName: Swift.String?
        /// An array of one FeaturizationMethod object that specifies the feature transformation method.
        public var featurizationPipeline: [ForecastClientTypes.FeaturizationMethod]?

        public init (
            attributeName: Swift.String? = nil,
            featurizationPipeline: [ForecastClientTypes.FeaturizationMethod]? = nil
        )
        {
            self.attributeName = attributeName
            self.featurizationPipeline = featurizationPipeline
        }
    }

}

extension ForecastClientTypes.FeaturizationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featurizations = "Featurizations"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featurizations = featurizations {
            var featurizationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featurizations)
            for featurizations0 in featurizations {
                try featurizationsContainer.encode(featurizations0)
            }
        }
        if let forecastDimensions = forecastDimensions {
            var forecastDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastDimensions)
            for forecastdimensions0 in forecastDimensions {
                try forecastDimensionsContainer.encode(forecastdimensions0)
            }
        }
        if let forecastFrequency = forecastFrequency {
            try encodeContainer.encode(forecastFrequency, forKey: .forecastFrequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastFrequency)
        forecastFrequency = forecastFrequencyDecoded
        let forecastDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .forecastDimensions)
        var forecastDimensionsDecoded0:[Swift.String]? = nil
        if let forecastDimensionsContainer = forecastDimensionsContainer {
            forecastDimensionsDecoded0 = [Swift.String]()
            for string0 in forecastDimensionsContainer {
                if let string0 = string0 {
                    forecastDimensionsDecoded0?.append(string0)
                }
            }
        }
        forecastDimensions = forecastDimensionsDecoded0
        let featurizationsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Featurization?].self, forKey: .featurizations)
        var featurizationsDecoded0:[ForecastClientTypes.Featurization]? = nil
        if let featurizationsContainer = featurizationsContainer {
            featurizationsDecoded0 = [ForecastClientTypes.Featurization]()
            for structure0 in featurizationsContainer {
                if let structure0 = structure0 {
                    featurizationsDecoded0?.append(structure0)
                }
            }
        }
        featurizations = featurizationsDecoded0
    }
}

extension ForecastClientTypes {
    /// In a [CreatePredictor] operation, the specified algorithm trains a model using the specified dataset group. You can optionally tell the operation to modify data fields prior to training a model. These modifications are referred to as featurization. You define featurization using the FeaturizationConfig object. You specify an array of transformations, one for each field that you want to featurize. You then include the FeaturizationConfig object in your CreatePredictor request. Amazon Forecast applies the featurization to the TARGET_TIME_SERIES and RELATED_TIME_SERIES datasets before model training. You can create multiple featurization configurations. For example, you might call the CreatePredictor operation twice by specifying different featurization configurations.
    public struct FeaturizationConfig: Swift.Equatable {
        /// An array of featurization (transformation) information for the fields of a dataset.
        public var featurizations: [ForecastClientTypes.Featurization]?
        /// An array of dimension (field) names that specify how to group the generated forecast. For example, suppose that you are generating a forecast for item sales across all of your stores, and your dataset contains a store_id field. If you want the sales forecast for each item by store, you would specify store_id as the dimension. All forecast dimensions specified in the TARGET_TIME_SERIES dataset don't need to be specified in the CreatePredictor request. All forecast dimensions specified in the RELATED_TIME_SERIES dataset must be specified in the CreatePredictor request.
        public var forecastDimensions: [Swift.String]?
        /// The frequency of predictions in a forecast. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes. The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency. When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the RELATED_TIME_SERIES dataset frequency.
        /// This member is required.
        public var forecastFrequency: Swift.String?

        public init (
            featurizations: [ForecastClientTypes.Featurization]? = nil,
            forecastDimensions: [Swift.String]? = nil,
            forecastFrequency: Swift.String? = nil
        )
        {
            self.featurizations = featurizations
            self.forecastDimensions = forecastDimensions
            self.forecastFrequency = forecastFrequency
        }
    }

}

extension ForecastClientTypes.FeaturizationMethod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featurizationMethodName = "FeaturizationMethodName"
        case featurizationMethodParameters = "FeaturizationMethodParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featurizationMethodName = featurizationMethodName {
            try encodeContainer.encode(featurizationMethodName.rawValue, forKey: .featurizationMethodName)
        }
        if let featurizationMethodParameters = featurizationMethodParameters {
            var featurizationMethodParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .featurizationMethodParameters)
            for (dictKey0, featurizationmethodparameters0) in featurizationMethodParameters {
                try featurizationMethodParametersContainer.encode(featurizationmethodparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featurizationMethodNameDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FeaturizationMethodName.self, forKey: .featurizationMethodName)
        featurizationMethodName = featurizationMethodNameDecoded
        let featurizationMethodParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .featurizationMethodParameters)
        var featurizationMethodParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let featurizationMethodParametersContainer = featurizationMethodParametersContainer {
            featurizationMethodParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in featurizationMethodParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    featurizationMethodParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        featurizationMethodParameters = featurizationMethodParametersDecoded0
    }
}

extension ForecastClientTypes {
    /// Provides information about the method that featurizes (transforms) a dataset field. The method is part of the FeaturizationPipeline of the [Featurization] object. The following is an example of how you specify a FeaturizationMethod object. {
    ///     "FeaturizationMethodName": "filling",
    ///
    ///
    ///     "FeaturizationMethodParameters": {"aggregation": "sum", "middlefill": "zero", "backfill": "zero"}
    ///
    ///
    ///     }
    public struct FeaturizationMethod: Swift.Equatable {
        /// The name of the method. The "filling" method is the only supported method.
        /// This member is required.
        public var featurizationMethodName: ForecastClientTypes.FeaturizationMethodName?
        /// The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters. The following list shows the parameters and their valid values for the "filling" featurization method for a Target Time Series dataset. Bold signifies the default value.
        ///
        /// * aggregation: sum, avg, first, min, max
        ///
        /// * frontfill: none
        ///
        /// * middlefill: zero, nan (not a number), value, median, mean, min, max
        ///
        /// * backfill: zero, nan, value, median, mean, min, max
        ///
        ///
        /// The following list shows the parameters and their valid values for a Related Time Series featurization method (there are no defaults):
        ///
        /// * middlefill: zero, value, median, mean, min, max
        ///
        /// * backfill: zero, value, median, mean, min, max
        ///
        /// * futurefill: zero, value, median, mean, min, max
        ///
        ///
        /// To set a filling method to a specific value, set the fill parameter to value and define the value in a corresponding _value parameter. For example, to set backfilling to a value of 2, include the following: "backfill": "value" and "backfill_value":"2".
        public var featurizationMethodParameters: [Swift.String:Swift.String]?

        public init (
            featurizationMethodName: ForecastClientTypes.FeaturizationMethodName? = nil,
            featurizationMethodParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.featurizationMethodName = featurizationMethodName
            self.featurizationMethodParameters = featurizationMethodParameters
        }
    }

}

extension ForecastClientTypes {
    public enum FeaturizationMethodName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filling
        case sdkUnknown(Swift.String)

        public static var allCases: [FeaturizationMethodName] {
            return [
                .filling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filling: return "filling"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeaturizationMethodName(rawValue: rawValue) ?? FeaturizationMethodName.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.FilterConditionString.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ForecastClientTypes {
    /// Describes a filter for choosing a subset of objects. Each filter consists of a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the objects that match the statement, respectively. The match statement consists of a key and a value.
    public struct Filter: Swift.Equatable {
        /// The condition to apply. To include the objects that match the statement, specify IS. To exclude matching objects, specify IS_NOT.
        /// This member is required.
        public var condition: ForecastClientTypes.FilterConditionString?
        /// The name of the parameter to filter on.
        /// This member is required.
        public var key: Swift.String?
        /// The value to match.
        /// This member is required.
        public var value: Swift.String?

        public init (
            condition: ForecastClientTypes.FilterConditionString? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.condition = condition
            self.key = key
            self.value = value
        }
    }

}

extension ForecastClientTypes {
    public enum FilterConditionString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `is`
        case isNot
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterConditionString] {
            return [
                .is,
                .isNot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .is: return "IS"
            case .isNot: return "IS_NOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterConditionString(rawValue: rawValue) ?? FilterConditionString.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ForecastExportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case forecastExportJobArn = "ForecastExportJobArn"
        case forecastExportJobName = "ForecastExportJobName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let forecastExportJobArn = forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
        if let forecastExportJobName = forecastExportJobName {
            try encodeContainer.encode(forecastExportJobName, forKey: .forecastExportJobName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the forecast export job properties used in the [ListForecastExportJobs] operation. To get the complete set of properties, call the [DescribeForecastExportJob] operation, and provide the listed ForecastExportJobArn.
    public struct ForecastExportJobSummary: Swift.Equatable {
        /// When the forecast export job was created.
        public var creationTime: ClientRuntime.Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public var destination: ForecastClientTypes.DataDestination?
        /// The Amazon Resource Name (ARN) of the forecast export job.
        public var forecastExportJobArn: Swift.String?
        /// The name of the forecast export job.
        public var forecastExportJobName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The status of the forecast export job. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the forecast export job must be ACTIVE before you can access the forecast in your S3 bucket.
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            forecastExportJobArn: Swift.String? = nil,
            forecastExportJobName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.forecastExportJobArn = forecastExportJobArn
            self.forecastExportJobName = forecastExportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }
    }

}

extension ForecastClientTypes.ForecastSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdUsingAutoPredictor = "CreatedUsingAutoPredictor"
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case forecastArn = "ForecastArn"
        case forecastName = "ForecastName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdUsingAutoPredictor = createdUsingAutoPredictor {
            try encodeContainer.encode(createdUsingAutoPredictor, forKey: .createdUsingAutoPredictor)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let forecastName = forecastName {
            try encodeContainer.encode(forecastName, forKey: .forecastName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let forecastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let createdUsingAutoPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createdUsingAutoPredictor)
        createdUsingAutoPredictor = createdUsingAutoPredictorDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the forecast properties used in the [ListForecasts] operation. To get the complete set of properties, call the [DescribeForecast] operation, and provide the ForecastArn that is listed in the summary.
    public struct ForecastSummary: Swift.Equatable {
        public var createdUsingAutoPredictor: Swift.Bool?
        /// When the forecast creation task was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provided the data used to train the predictor.
        public var datasetGroupArn: Swift.String?
        /// The ARN of the forecast.
        public var forecastArn: Swift.String?
        /// The name of the forecast.
        public var forecastName: Swift.String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The ARN of the predictor used to generate the forecast.
        public var predictorArn: Swift.String?
        /// The status of the forecast. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        ///
        /// The Status of the forecast must be ACTIVE before you can query or export the forecast.
        public var status: Swift.String?

        public init (
            createdUsingAutoPredictor: Swift.Bool? = nil,
            creationTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            forecastArn: Swift.String? = nil,
            forecastName: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            predictorArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.createdUsingAutoPredictor = createdUsingAutoPredictor
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.forecastArn = forecastArn
            self.forecastName = forecastName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.status = status
        }
    }

}

extension GetAccuracyMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

extension GetAccuracyMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccuracyMetricsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the predictor to get metrics for.
    /// This member is required.
    public var predictorArn: Swift.String?

    public init (
        predictorArn: Swift.String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct GetAccuracyMetricsInputBody: Swift.Equatable {
    let predictorArn: Swift.String?
}

extension GetAccuracyMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension GetAccuracyMetricsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccuracyMetricsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccuracyMetricsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccuracyMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccuracyMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoMLOverrideStrategy = output.autoMLOverrideStrategy
            self.isAutoPredictor = output.isAutoPredictor
            self.optimizationMetric = output.optimizationMetric
            self.predictorEvaluationResults = output.predictorEvaluationResults
        } else {
            self.autoMLOverrideStrategy = nil
            self.isAutoPredictor = nil
            self.optimizationMetric = nil
            self.predictorEvaluationResults = nil
        }
    }
}

public struct GetAccuracyMetricsOutputResponse: Swift.Equatable {
    /// The LatencyOptimized AutoML override strategy is only available in private beta. Contact AWS Support or your account manager to learn more about access privileges. The AutoML strategy used to train the predictor. Unless LatencyOptimized is specified, the AutoML strategy optimizes predictor accuracy. This parameter is only valid for predictors trained using AutoML.
    public var autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    /// Whether the predictor was created with [CreateAutoPredictor].
    public var isAutoPredictor: Swift.Bool?
    /// The accuracy metric used to optimize the predictor.
    public var optimizationMetric: ForecastClientTypes.OptimizationMetric?
    /// An array of results from evaluating the predictor.
    public var predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]?

    public init (
        autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy? = nil,
        isAutoPredictor: Swift.Bool? = nil,
        optimizationMetric: ForecastClientTypes.OptimizationMetric? = nil,
        predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]? = nil
    )
    {
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.isAutoPredictor = isAutoPredictor
        self.optimizationMetric = optimizationMetric
        self.predictorEvaluationResults = predictorEvaluationResults
    }
}

struct GetAccuracyMetricsOutputResponseBody: Swift.Equatable {
    let predictorEvaluationResults: [ForecastClientTypes.EvaluationResult]?
    let isAutoPredictor: Swift.Bool?
    let autoMLOverrideStrategy: ForecastClientTypes.AutoMLOverrideStrategy?
    let optimizationMetric: ForecastClientTypes.OptimizationMetric?
}

extension GetAccuracyMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case isAutoPredictor = "IsAutoPredictor"
        case optimizationMetric = "OptimizationMetric"
        case predictorEvaluationResults = "PredictorEvaluationResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorEvaluationResultsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.EvaluationResult?].self, forKey: .predictorEvaluationResults)
        var predictorEvaluationResultsDecoded0:[ForecastClientTypes.EvaluationResult]? = nil
        if let predictorEvaluationResultsContainer = predictorEvaluationResultsContainer {
            predictorEvaluationResultsDecoded0 = [ForecastClientTypes.EvaluationResult]()
            for structure0 in predictorEvaluationResultsContainer {
                if let structure0 = structure0 {
                    predictorEvaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        predictorEvaluationResults = predictorEvaluationResultsDecoded0
        let isAutoPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAutoPredictor)
        isAutoPredictor = isAutoPredictorDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let optimizationMetricDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.OptimizationMetric.self, forKey: .optimizationMetric)
        optimizationMetric = optimizationMetricDecoded
    }
}

extension ForecastClientTypes.HyperParameterTuningJobConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterRanges = "ParameterRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterRanges = parameterRanges {
            try encodeContainer.encode(parameterRanges, forKey: .parameterRanges)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterRangesDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ParameterRanges.self, forKey: .parameterRanges)
        parameterRanges = parameterRangesDecoded
    }
}

extension ForecastClientTypes {
    /// Configuration information for a hyperparameter tuning job. You specify this object in the [CreatePredictor] request. A hyperparameter is a parameter that governs the model training process. You set hyperparameters before training starts, unlike model parameters, which are determined during training. The values of the hyperparameters effect which values are chosen for the model parameters. In a hyperparameter tuning job, Amazon Forecast chooses the set of hyperparameter values that optimize a specified metric. Forecast accomplishes this by running many training jobs over a range of hyperparameter values. The optimum set of values depends on the algorithm, the training data, and the specified metric objective.
    public struct HyperParameterTuningJobConfig: Swift.Equatable {
        /// Specifies the ranges of valid values for the hyperparameters.
        public var parameterRanges: ForecastClientTypes.ParameterRanges?

        public init (
            parameterRanges: ForecastClientTypes.ParameterRanges? = nil
        )
        {
            self.parameterRanges = parameterRanges
        }
    }

}

extension ForecastClientTypes.InputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
        case supplementaryFeatures = "SupplementaryFeatures"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let supplementaryFeatures = supplementaryFeatures {
            var supplementaryFeaturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supplementaryFeatures)
            for supplementaryfeatures0 in supplementaryFeatures {
                try supplementaryFeaturesContainer.encode(supplementaryfeatures0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let supplementaryFeaturesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.SupplementaryFeature?].self, forKey: .supplementaryFeatures)
        var supplementaryFeaturesDecoded0:[ForecastClientTypes.SupplementaryFeature]? = nil
        if let supplementaryFeaturesContainer = supplementaryFeaturesContainer {
            supplementaryFeaturesDecoded0 = [ForecastClientTypes.SupplementaryFeature]()
            for structure0 in supplementaryFeaturesContainer {
                if let structure0 = structure0 {
                    supplementaryFeaturesDecoded0?.append(structure0)
                }
            }
        }
        supplementaryFeatures = supplementaryFeaturesDecoded0
    }
}

extension ForecastClientTypes {
    /// The data used to train a predictor. The data includes a dataset group and any supplementary features. You specify this object in the [CreatePredictor] request.
    public struct InputDataConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the dataset group.
        /// This member is required.
        public var datasetGroupArn: Swift.String?
        /// An array of supplementary features. The only supported feature is a holiday calendar.
        public var supplementaryFeatures: [ForecastClientTypes.SupplementaryFeature]?

        public init (
            datasetGroupArn: Swift.String? = nil,
            supplementaryFeatures: [ForecastClientTypes.SupplementaryFeature]? = nil
        )
        {
            self.datasetGroupArn = datasetGroupArn
            self.supplementaryFeatures = supplementaryFeatures
        }
    }

}

extension ForecastClientTypes.IntegerParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case name = "Name"
        case scalingType = "ScalingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxValue = maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scalingType = scalingType {
            try encodeContainer.encode(scalingType.rawValue, forKey: .scalingType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let scalingTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ScalingType.self, forKey: .scalingType)
        scalingType = scalingTypeDecoded
    }
}

extension ForecastClientTypes {
    /// Specifies an integer hyperparameter and it's range of tunable values. This object is part of the [ParameterRanges] object.
    public struct IntegerParameterRange: Swift.Equatable {
        /// The maximum tunable value of the hyperparameter.
        /// This member is required.
        public var maxValue: Swift.Int?
        /// The minimum tunable value of the hyperparameter.
        /// This member is required.
        public var minValue: Swift.Int?
        /// The name of the hyperparameter to tune.
        /// This member is required.
        public var name: Swift.String?
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values: Auto Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter. Linear Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale. Logarithmic Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have values greater than 0. ReverseLogarithmic Not supported for IntegerParameterRange. Reverse logarithmic scaling works only for ranges that are entirely within the range 0 <= x < 1.0. For information about choosing a hyperparameter scale, see [Hyperparameter Scaling](http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type). One of the following values:
        public var scalingType: ForecastClientTypes.ScalingType?

        public init (
            maxValue: Swift.Int? = nil,
            minValue: Swift.Int? = nil,
            name: Swift.String? = nil,
            scalingType: ForecastClientTypes.ScalingType? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }
    }

}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We can't process the request because it includes an invalid value or a value that exceeds the valid range.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The token is not valid. Tokens expire after 24 hours.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit on the number of resources per account has been exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDatasetGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetGroupsInput: Swift.Equatable {
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroups = output.datasetGroups
            self.nextToken = output.nextToken
        } else {
            self.datasetGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetGroupsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each dataset group's properties.
    public var datasetGroups: [ForecastClientTypes.DatasetGroupSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        datasetGroups: [ForecastClientTypes.DatasetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroups = datasetGroups
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsOutputResponseBody: Swift.Equatable {
    let datasetGroups: [ForecastClientTypes.DatasetGroupSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroups = "DatasetGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.DatasetGroupSummary?].self, forKey: .datasetGroups)
        var datasetGroupsDecoded0:[ForecastClientTypes.DatasetGroupSummary]? = nil
        if let datasetGroupsContainer = datasetGroupsContainer {
            datasetGroupsDecoded0 = [ForecastClientTypes.DatasetGroupSummary]()
            for structure0 in datasetGroupsContainer {
                if let structure0 = structure0 {
                    datasetGroupsDecoded0?.append(structure0)
                }
            }
        }
        datasetGroups = datasetGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatasetImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetImportJobsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the datasets that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the datasets that match the statement, specify IS. To exclude matching datasets, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are DatasetArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all dataset import jobs whose status is ACTIVE, you specify the following filter: "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListDatasetImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListDatasetImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetImportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobs = output.datasetImportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetImportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetImportJobsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each dataset import job's properties.
    public var datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetImportJobs = datasetImportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsOutputResponseBody: Swift.Equatable {
    let datasetImportJobs: [ForecastClientTypes.DatasetImportJobSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobs = "DatasetImportJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.DatasetImportJobSummary?].self, forKey: .datasetImportJobs)
        var datasetImportJobsDecoded0:[ForecastClientTypes.DatasetImportJobSummary]? = nil
        if let datasetImportJobsContainer = datasetImportJobsContainer {
            datasetImportJobsDecoded0 = [ForecastClientTypes.DatasetImportJobSummary]()
            for structure0 in datasetImportJobsContainer {
                if let structure0 = structure0 {
                    datasetImportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetImportJobs = datasetImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatasetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetsInput: Swift.Equatable {
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each dataset's properties.
    public var datasets: [ForecastClientTypes.DatasetSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        datasets: [ForecastClientTypes.DatasetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Swift.Equatable {
    let datasets: [ForecastClientTypes.DatasetSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasets = "Datasets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.DatasetSummary?].self, forKey: .datasets)
        var datasetsDecoded0:[ForecastClientTypes.DatasetSummary]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [ForecastClientTypes.DatasetSummary]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExplainabilitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListExplainabilitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExplainabilitiesInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are PredictorArn and Status.
    ///
    /// * Value - The value to match.
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items returned in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExplainabilitiesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListExplainabilitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListExplainabilitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExplainabilitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExplainabilitiesOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExplainabilitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListExplainabilitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.explainabilities = output.explainabilities
            self.nextToken = output.nextToken
        } else {
            self.explainabilities = nil
            self.nextToken = nil
        }
    }
}

public struct ListExplainabilitiesOutputResponse: Swift.Equatable {
    /// An array of objects that summarize the properties of each Explainability resource.
    public var explainabilities: [ForecastClientTypes.ExplainabilitySummary]?
    /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        explainabilities: [ForecastClientTypes.ExplainabilitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.explainabilities = explainabilities
        self.nextToken = nextToken
    }
}

struct ListExplainabilitiesOutputResponseBody: Swift.Equatable {
    let explainabilities: [ForecastClientTypes.ExplainabilitySummary]?
    let nextToken: Swift.String?
}

extension ListExplainabilitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilities = "Explainabilities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilitiesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ExplainabilitySummary?].self, forKey: .explainabilities)
        var explainabilitiesDecoded0:[ForecastClientTypes.ExplainabilitySummary]? = nil
        if let explainabilitiesContainer = explainabilitiesContainer {
            explainabilitiesDecoded0 = [ForecastClientTypes.ExplainabilitySummary]()
            for structure0 in explainabilitiesContainer {
                if let structure0 = structure0 {
                    explainabilitiesDecoded0?.append(structure0)
                }
            }
        }
        explainabilities = explainabilitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExplainabilityExportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListExplainabilityExportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExplainabilityExportsInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude resources that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are PredictorArn and Status.
    ///
    /// * Value - The value to match.
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExplainabilityExportsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListExplainabilityExportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListExplainabilityExportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExplainabilityExportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExplainabilityExportsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExplainabilityExportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListExplainabilityExportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.explainabilityExports = output.explainabilityExports
            self.nextToken = output.nextToken
        } else {
            self.explainabilityExports = nil
            self.nextToken = nil
        }
    }
}

public struct ListExplainabilityExportsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize the properties of each Explainability export.
    public var explainabilityExports: [ForecastClientTypes.ExplainabilityExportSummary]?
    /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        explainabilityExports: [ForecastClientTypes.ExplainabilityExportSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.explainabilityExports = explainabilityExports
        self.nextToken = nextToken
    }
}

struct ListExplainabilityExportsOutputResponseBody: Swift.Equatable {
    let explainabilityExports: [ForecastClientTypes.ExplainabilityExportSummary]?
    let nextToken: Swift.String?
}

extension ListExplainabilityExportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explainabilityExports = "ExplainabilityExports"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explainabilityExportsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ExplainabilityExportSummary?].self, forKey: .explainabilityExports)
        var explainabilityExportsDecoded0:[ForecastClientTypes.ExplainabilityExportSummary]? = nil
        if let explainabilityExportsContainer = explainabilityExportsContainer {
            explainabilityExportsDecoded0 = [ForecastClientTypes.ExplainabilityExportSummary]()
            for structure0 in explainabilityExportsContainer {
                if let structure0 = structure0 {
                    explainabilityExportsDecoded0?.append(structure0)
                }
            }
        }
        explainabilityExports = explainabilityExportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListForecastExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListForecastExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListForecastExportJobsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are ForecastArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all jobs that export a forecast named electricityforecast, specify the following filter: "Filters": [ { "Condition": "IS", "Key": "ForecastArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityforecast" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListForecastExportJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListForecastExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListForecastExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListForecastExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListForecastExportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListForecastExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListForecastExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecastExportJobs = output.forecastExportJobs
            self.nextToken = output.nextToken
        } else {
            self.forecastExportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListForecastExportJobsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each export job's properties.
    public var forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.forecastExportJobs = forecastExportJobs
        self.nextToken = nextToken
    }
}

struct ListForecastExportJobsOutputResponseBody: Swift.Equatable {
    let forecastExportJobs: [ForecastClientTypes.ForecastExportJobSummary]?
    let nextToken: Swift.String?
}

extension ListForecastExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastExportJobs = "ForecastExportJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ForecastExportJobSummary?].self, forKey: .forecastExportJobs)
        var forecastExportJobsDecoded0:[ForecastClientTypes.ForecastExportJobSummary]? = nil
        if let forecastExportJobsContainer = forecastExportJobsContainer {
            forecastExportJobsDecoded0 = [ForecastClientTypes.ForecastExportJobSummary]()
            for structure0 in forecastExportJobsContainer {
                if let structure0 = structure0 {
                    forecastExportJobsDecoded0?.append(structure0)
                }
            }
        }
        forecastExportJobs = forecastExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListForecastsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListForecastsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListForecastsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the forecasts that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecasts that match the statement, specify IS. To exclude matching forecasts, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are DatasetGroupArn, PredictorArn, and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all forecasts whose status is not ACTIVE, you would specify: "Filters": [ { "Condition": "IS_NOT", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListForecastsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListForecastsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListForecastsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListForecastsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListForecastsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListForecastsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListForecastsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecasts = output.forecasts
            self.nextToken = output.nextToken
        } else {
            self.forecasts = nil
            self.nextToken = nil
        }
    }
}

public struct ListForecastsOutputResponse: Swift.Equatable {
    /// An array of objects that summarize each forecast's properties.
    public var forecasts: [ForecastClientTypes.ForecastSummary]?
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        forecasts: [ForecastClientTypes.ForecastSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.forecasts = forecasts
        self.nextToken = nextToken
    }
}

struct ListForecastsOutputResponseBody: Swift.Equatable {
    let forecasts: [ForecastClientTypes.ForecastSummary]?
    let nextToken: Swift.String?
}

extension ListForecastsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecasts = "Forecasts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ForecastSummary?].self, forKey: .forecasts)
        var forecastsDecoded0:[ForecastClientTypes.ForecastSummary]? = nil
        if let forecastsContainer = forecastsContainer {
            forecastsDecoded0 = [ForecastClientTypes.ForecastSummary]()
            for structure0 in forecastsContainer {
                if let structure0 = structure0 {
                    forecastsDecoded0?.append(structure0)
                }
            }
        }
        forecasts = forecastsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPredictorBacktestExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPredictorBacktestExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPredictorBacktestExportJobsInput: Swift.Equatable {
    /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the predictor backtest export jobs that match the statement from the list. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the predictor backtest export jobs that match the statement, specify IS. To exclude matching predictor backtest export jobs, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are PredictorArn and Status.
    ///
    /// * Value - The value to match.
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPredictorBacktestExportJobsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListPredictorBacktestExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListPredictorBacktestExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPredictorBacktestExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPredictorBacktestExportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPredictorBacktestExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPredictorBacktestExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.predictorBacktestExportJobs = output.predictorBacktestExportJobs
        } else {
            self.nextToken = nil
            self.predictorBacktestExportJobs = nil
        }
    }
}

public struct ListPredictorBacktestExportJobsOutputResponse: Swift.Equatable {
    /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of objects that summarize the properties of each predictor backtest export job.
    public var predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]?

    public init (
        nextToken: Swift.String? = nil,
        predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictorBacktestExportJobs = predictorBacktestExportJobs
    }
}

struct ListPredictorBacktestExportJobsOutputResponseBody: Swift.Equatable {
    let predictorBacktestExportJobs: [ForecastClientTypes.PredictorBacktestExportJobSummary]?
    let nextToken: Swift.String?
}

extension ListPredictorBacktestExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case predictorBacktestExportJobs = "PredictorBacktestExportJobs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorBacktestExportJobSummary?].self, forKey: .predictorBacktestExportJobs)
        var predictorBacktestExportJobsDecoded0:[ForecastClientTypes.PredictorBacktestExportJobSummary]? = nil
        if let predictorBacktestExportJobsContainer = predictorBacktestExportJobsContainer {
            predictorBacktestExportJobsDecoded0 = [ForecastClientTypes.PredictorBacktestExportJobSummary]()
            for structure0 in predictorBacktestExportJobsContainer {
                if let structure0 = structure0 {
                    predictorBacktestExportJobsDecoded0?.append(structure0)
                }
            }
        }
        predictorBacktestExportJobs = predictorBacktestExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPredictorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPredictorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPredictorsInput: Swift.Equatable {
    /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the predictors that match the statement from the list, respectively. The match statement consists of a key and a value. Filter properties
    ///
    /// * Condition - The condition to apply. Valid values are IS and IS_NOT. To include the predictors that match the statement, specify IS. To exclude matching predictors, specify IS_NOT.
    ///
    /// * Key - The name of the parameter to filter on. Valid values are DatasetGroupArn and Status.
    ///
    /// * Value - The value to match.
    ///
    ///
    /// For example, to list all predictors whose status is ACTIVE, you would specify: "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
    public var filters: [ForecastClientTypes.Filter]?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        filters: [ForecastClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPredictorsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [ForecastClientTypes.Filter]?
}

extension ListPredictorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ForecastClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ForecastClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListPredictorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPredictorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPredictorsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPredictorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPredictorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.predictors = output.predictors
        } else {
            self.nextToken = nil
            self.predictors = nil
        }
    }
}

public struct ListPredictorsOutputResponse: Swift.Equatable {
    /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?
    /// An array of objects that summarize each predictor's properties.
    public var predictors: [ForecastClientTypes.PredictorSummary]?

    public init (
        nextToken: Swift.String? = nil,
        predictors: [ForecastClientTypes.PredictorSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictors = predictors
    }
}

struct ListPredictorsOutputResponseBody: Swift.Equatable {
    let predictors: [ForecastClientTypes.PredictorSummary]?
    let nextToken: Swift.String?
}

extension ListPredictorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case predictors = "Predictors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorSummary?].self, forKey: .predictors)
        var predictorsDecoded0:[ForecastClientTypes.PredictorSummary]? = nil
        if let predictorsContainer = predictorsContainer {
            predictorsDecoded0 = [ForecastClientTypes.PredictorSummary]()
            for structure0 in predictorsContainer {
                if let structure0 = structure0 {
                    predictorsDecoded0?.append(structure0)
                }
            }
        }
        predictors = predictorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are Forecast dataset groups, datasets, dataset import jobs, predictors, forecasts, and forecast export jobs.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ForecastClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ForecastClientTypes.Metrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case averageWeightedQuantileLoss = "AverageWeightedQuantileLoss"
        case errorMetrics = "ErrorMetrics"
        case rMSE = "RMSE"
        case weightedQuantileLosses = "WeightedQuantileLosses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let averageWeightedQuantileLoss = averageWeightedQuantileLoss {
            try encodeContainer.encode(averageWeightedQuantileLoss, forKey: .averageWeightedQuantileLoss)
        }
        if let errorMetrics = errorMetrics {
            var errorMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorMetrics)
            for errormetrics0 in errorMetrics {
                try errorMetricsContainer.encode(errormetrics0)
            }
        }
        if let rMSE = rMSE {
            try encodeContainer.encode(rMSE, forKey: .rMSE)
        }
        if let weightedQuantileLosses = weightedQuantileLosses {
            var weightedQuantileLossesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weightedQuantileLosses)
            for weightedquantilelosses0 in weightedQuantileLosses {
                try weightedQuantileLossesContainer.encode(weightedquantilelosses0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rMSEDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rMSE)
        rMSE = rMSEDecoded
        let weightedQuantileLossesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.WeightedQuantileLoss?].self, forKey: .weightedQuantileLosses)
        var weightedQuantileLossesDecoded0:[ForecastClientTypes.WeightedQuantileLoss]? = nil
        if let weightedQuantileLossesContainer = weightedQuantileLossesContainer {
            weightedQuantileLossesDecoded0 = [ForecastClientTypes.WeightedQuantileLoss]()
            for structure0 in weightedQuantileLossesContainer {
                if let structure0 = structure0 {
                    weightedQuantileLossesDecoded0?.append(structure0)
                }
            }
        }
        weightedQuantileLosses = weightedQuantileLossesDecoded0
        let errorMetricsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ErrorMetric?].self, forKey: .errorMetrics)
        var errorMetricsDecoded0:[ForecastClientTypes.ErrorMetric]? = nil
        if let errorMetricsContainer = errorMetricsContainer {
            errorMetricsDecoded0 = [ForecastClientTypes.ErrorMetric]()
            for structure0 in errorMetricsContainer {
                if let structure0 = structure0 {
                    errorMetricsDecoded0?.append(structure0)
                }
            }
        }
        errorMetrics = errorMetricsDecoded0
        let averageWeightedQuantileLossDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .averageWeightedQuantileLoss)
        averageWeightedQuantileLoss = averageWeightedQuantileLossDecoded
    }
}

extension ForecastClientTypes {
    /// Provides metrics that are used to evaluate the performance of a predictor. This object is part of the [WindowSummary] object.
    public struct Metrics: Swift.Equatable {
        /// The average value of all weighted quantile losses.
        public var averageWeightedQuantileLoss: Swift.Double?
        /// Provides detailed error metrics for each forecast type. Metrics include root-mean square-error (RMSE), mean absolute percentage error (MAPE), mean absolute scaled error (MASE), and weighted average percentage error (WAPE).
        public var errorMetrics: [ForecastClientTypes.ErrorMetric]?
        /// The root-mean-square error (RMSE).
        @available(*, deprecated, message: "This property is deprecated, please refer to ErrorMetrics for both RMSE and WAPE")
        public var rMSE: Swift.Double?
        /// An array of weighted quantile losses. Quantiles divide a probability distribution into regions of equal probability. The distribution in this case is the loss function.
        public var weightedQuantileLosses: [ForecastClientTypes.WeightedQuantileLoss]?

        public init (
            averageWeightedQuantileLoss: Swift.Double? = nil,
            errorMetrics: [ForecastClientTypes.ErrorMetric]? = nil,
            rMSE: Swift.Double? = nil,
            weightedQuantileLosses: [ForecastClientTypes.WeightedQuantileLoss]? = nil
        )
        {
            self.averageWeightedQuantileLoss = averageWeightedQuantileLoss
            self.errorMetrics = errorMetrics
            self.rMSE = rMSE
            self.weightedQuantileLosses = weightedQuantileLosses
        }
    }

}

extension ForecastClientTypes {
    public enum OptimizationMetric: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case averageweightedquantileloss
        case mape
        case mase
        case rmse
        case wape
        case sdkUnknown(Swift.String)

        public static var allCases: [OptimizationMetric] {
            return [
                .averageweightedquantileloss,
                .mape,
                .mase,
                .rmse,
                .wape,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .averageweightedquantileloss: return "AverageWeightedQuantileLoss"
            case .mape: return "MAPE"
            case .mase: return "MASE"
            case .rmse: return "RMSE"
            case .wape: return "WAPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptimizationMetric(rawValue: rawValue) ?? OptimizationMetric.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.ParameterRanges: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalParameterRanges = "CategoricalParameterRanges"
        case continuousParameterRanges = "ContinuousParameterRanges"
        case integerParameterRanges = "IntegerParameterRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalParameterRanges = categoricalParameterRanges {
            var categoricalParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalParameterRanges)
            for categoricalparameterranges0 in categoricalParameterRanges {
                try categoricalParameterRangesContainer.encode(categoricalparameterranges0)
            }
        }
        if let continuousParameterRanges = continuousParameterRanges {
            var continuousParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousParameterRanges)
            for continuousparameterranges0 in continuousParameterRanges {
                try continuousParameterRangesContainer.encode(continuousparameterranges0)
            }
        }
        if let integerParameterRanges = integerParameterRanges {
            var integerParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerParameterRanges)
            for integerparameterranges0 in integerParameterRanges {
                try integerParameterRangesContainer.encode(integerparameterranges0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoricalParameterRangesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.CategoricalParameterRange?].self, forKey: .categoricalParameterRanges)
        var categoricalParameterRangesDecoded0:[ForecastClientTypes.CategoricalParameterRange]? = nil
        if let categoricalParameterRangesContainer = categoricalParameterRangesContainer {
            categoricalParameterRangesDecoded0 = [ForecastClientTypes.CategoricalParameterRange]()
            for structure0 in categoricalParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalParameterRanges = categoricalParameterRangesDecoded0
        let continuousParameterRangesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.ContinuousParameterRange?].self, forKey: .continuousParameterRanges)
        var continuousParameterRangesDecoded0:[ForecastClientTypes.ContinuousParameterRange]? = nil
        if let continuousParameterRangesContainer = continuousParameterRangesContainer {
            continuousParameterRangesDecoded0 = [ForecastClientTypes.ContinuousParameterRange]()
            for structure0 in continuousParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousParameterRanges = continuousParameterRangesDecoded0
        let integerParameterRangesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.IntegerParameterRange?].self, forKey: .integerParameterRanges)
        var integerParameterRangesDecoded0:[ForecastClientTypes.IntegerParameterRange]? = nil
        if let integerParameterRangesContainer = integerParameterRangesContainer {
            integerParameterRangesDecoded0 = [ForecastClientTypes.IntegerParameterRange]()
            for structure0 in integerParameterRangesContainer {
                if let structure0 = structure0 {
                    integerParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerParameterRanges = integerParameterRangesDecoded0
    }
}

extension ForecastClientTypes {
    /// Specifies the categorical, continuous, and integer hyperparameters, and their ranges of tunable values. The range of tunable values determines which values that a hyperparameter tuning job can choose for the specified hyperparameter. This object is part of the [HyperParameterTuningJobConfig] object.
    public struct ParameterRanges: Swift.Equatable {
        /// Specifies the tunable range for each categorical hyperparameter.
        public var categoricalParameterRanges: [ForecastClientTypes.CategoricalParameterRange]?
        /// Specifies the tunable range for each continuous hyperparameter.
        public var continuousParameterRanges: [ForecastClientTypes.ContinuousParameterRange]?
        /// Specifies the tunable range for each integer hyperparameter.
        public var integerParameterRanges: [ForecastClientTypes.IntegerParameterRange]?

        public init (
            categoricalParameterRanges: [ForecastClientTypes.CategoricalParameterRange]? = nil,
            continuousParameterRanges: [ForecastClientTypes.ContinuousParameterRange]? = nil,
            integerParameterRanges: [ForecastClientTypes.IntegerParameterRange]? = nil
        )
        {
            self.categoricalParameterRanges = categoricalParameterRanges
            self.continuousParameterRanges = continuousParameterRanges
            self.integerParameterRanges = integerParameterRanges
        }
    }

}

extension ForecastClientTypes.PredictorBacktestExportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorBacktestExportJobArn = predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
        if let predictorBacktestExportJobName = predictorBacktestExportJobName {
            try encodeContainer.encode(predictorBacktestExportJobName, forKey: .predictorBacktestExportJobName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the predictor backtest export job properties used in the [ListPredictorBacktestExportJobs] operation. To get a complete set of properties, call the [DescribePredictorBacktestExportJob] operation, and provide the listed PredictorBacktestExportJobArn.
    public struct PredictorBacktestExportJobSummary: Swift.Equatable {
        /// When the predictor backtest export job was created.
        public var creationTime: ClientRuntime.Date?
        /// The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to access the location, and an AWS Key Management Service (KMS) key (optional).
        public var destination: ForecastClientTypes.DataDestination?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// Information about any errors that may have occurred during the backtest export.
        public var message: Swift.String?
        /// The Amazon Resource Name (ARN) of the predictor backtest export job.
        public var predictorBacktestExportJobArn: Swift.String?
        /// The name of the predictor backtest export job.
        public var predictorBacktestExportJobName: Swift.String?
        /// The status of the predictor backtest export job. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            destination: ForecastClientTypes.DataDestination? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            predictorBacktestExportJobArn: Swift.String? = nil,
            predictorBacktestExportJobName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destination = destination
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = predictorBacktestExportJobName
            self.status = status
        }
    }

}

extension ForecastClientTypes.PredictorExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn = "AlgorithmArn"
        case testWindows = "TestWindows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let testWindows = testWindows {
            var testWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .testWindows)
            for testwindowdetails0 in testWindows {
                try testWindowsContainer.encode(testwindowdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let testWindowsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.TestWindowSummary?].self, forKey: .testWindows)
        var testWindowsDecoded0:[ForecastClientTypes.TestWindowSummary]? = nil
        if let testWindowsContainer = testWindowsContainer {
            testWindowsDecoded0 = [ForecastClientTypes.TestWindowSummary]()
            for structure0 in testWindowsContainer {
                if let structure0 = structure0 {
                    testWindowsDecoded0?.append(structure0)
                }
            }
        }
        testWindows = testWindowsDecoded0
    }
}

extension ForecastClientTypes {
    /// The algorithm used to perform a backtest and the status of those tests.
    public struct PredictorExecution: Swift.Equatable {
        /// The ARN of the algorithm used to test the predictor.
        public var algorithmArn: Swift.String?
        /// An array of test windows used to evaluate the algorithm. The NumberOfBacktestWindows from the object determines the number of windows in the array.
        public var testWindows: [ForecastClientTypes.TestWindowSummary]?

        public init (
            algorithmArn: Swift.String? = nil,
            testWindows: [ForecastClientTypes.TestWindowSummary]? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }
    }

}

extension ForecastClientTypes.PredictorExecutionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predictorExecutions = "PredictorExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorExecutions = predictorExecutions {
            var predictorExecutionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predictorExecutions)
            for predictorexecutions0 in predictorExecutions {
                try predictorExecutionsContainer.encode(predictorexecutions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorExecutionsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.PredictorExecution?].self, forKey: .predictorExecutions)
        var predictorExecutionsDecoded0:[ForecastClientTypes.PredictorExecution]? = nil
        if let predictorExecutionsContainer = predictorExecutionsContainer {
            predictorExecutionsDecoded0 = [ForecastClientTypes.PredictorExecution]()
            for structure0 in predictorExecutionsContainer {
                if let structure0 = structure0 {
                    predictorExecutionsDecoded0?.append(structure0)
                }
            }
        }
        predictorExecutions = predictorExecutionsDecoded0
    }
}

extension ForecastClientTypes {
    /// Contains details on the backtests performed to evaluate the accuracy of the predictor. The tests are returned in descending order of accuracy, with the most accurate backtest appearing first. You specify the number of backtests to perform when you call the operation.
    public struct PredictorExecutionDetails: Swift.Equatable {
        /// An array of the backtests performed to evaluate the accuracy of the predictor against a particular algorithm. The NumberOfBacktestWindows from the object determines the number of windows in the array.
        public var predictorExecutions: [ForecastClientTypes.PredictorExecution]?

        public init (
            predictorExecutions: [ForecastClientTypes.PredictorExecution]? = nil
        )
        {
            self.predictorExecutions = predictorExecutions
        }
    }

}

extension ForecastClientTypes.PredictorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case isAutoPredictor = "IsAutoPredictor"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case predictorName = "PredictorName"
        case referencePredictorSummary = "ReferencePredictorSummary"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let isAutoPredictor = isAutoPredictor {
            try encodeContainer.encode(isAutoPredictor, forKey: .isAutoPredictor)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let predictorName = predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let referencePredictorSummary = referencePredictorSummary {
            try encodeContainer.encode(referencePredictorSummary, forKey: .referencePredictorSummary)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let isAutoPredictorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAutoPredictor)
        isAutoPredictor = isAutoPredictorDecoded
        let referencePredictorSummaryDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.ReferencePredictorSummary.self, forKey: .referencePredictorSummary)
        referencePredictorSummary = referencePredictorSummaryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the predictor properties that are used in the [ListPredictors] operation. To get the complete set of properties, call the [DescribePredictor] operation, and provide the listed PredictorArn.
    public struct PredictorSummary: Swift.Equatable {
        /// When the model training task was created.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that contains the data used to train the predictor.
        public var datasetGroupArn: Swift.String?
        /// Whether AutoPredictor was used to create the predictor.
        public var isAutoPredictor: Swift.Bool?
        /// The last time the resource was modified. The timestamp depends on the status of the job:
        ///
        /// * CREATE_PENDING - The CreationTime.
        ///
        /// * CREATE_IN_PROGRESS - The current timestamp.
        ///
        /// * CREATE_STOPPING - The current timestamp.
        ///
        /// * CREATE_STOPPED - When the job stopped.
        ///
        /// * ACTIVE or CREATE_FAILED - When the job finished or failed.
        public var lastModificationTime: ClientRuntime.Date?
        /// If an error occurred, an informational message about the error.
        public var message: Swift.String?
        /// The ARN of the predictor.
        public var predictorArn: Swift.String?
        /// The name of the predictor.
        public var predictorName: Swift.String?
        /// A summary of the reference predictor used if the predictor was retrained or upgraded.
        public var referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary?
        /// The status of the predictor. States include:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED
        ///
        /// * DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        ///
        /// * CREATE_STOPPING, CREATE_STOPPED
        ///
        ///
        /// The Status of the predictor must be ACTIVE before you can use the predictor to create a forecast.
        public var status: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            isAutoPredictor: Swift.Bool? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            predictorArn: Swift.String? = nil,
            predictorName: Swift.String? = nil,
            referencePredictorSummary: ForecastClientTypes.ReferencePredictorSummary? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.isAutoPredictor = isAutoPredictor
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.predictorName = predictorName
            self.referencePredictorSummary = referencePredictorSummary
            self.status = status
        }
    }

}

extension ForecastClientTypes.ReferencePredictorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension ForecastClientTypes {
    /// Provides a summary of the reference predictor used when retraining or upgrading a predictor.
    public struct ReferencePredictorSummary: Swift.Equatable {
        /// The ARN of the reference predictor.
        public var arn: Swift.String?
        /// Whether the reference predictor is Active or Deleted.
        public var state: ForecastClientTypes.State?

        public init (
            arn: Swift.String? = nil,
            state: ForecastClientTypes.State? = nil
        )
        {
            self.arn = arn
            self.state = state
        }
    }

}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is already a resource with this name. Try again with a different name.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource is in use.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We can't find a resource with that Amazon Resource Name (ARN). Check the ARN and try again.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ForecastClientTypes.S3Config: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kMSKeyArn = "KMSKeyArn"
        case path = "Path"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
    }
}

extension ForecastClientTypes {
    /// The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the file(s). Optionally, includes an AWS Key Management Service (KMS) key. This object is part of the [DataSource] object that is submitted in the [CreateDatasetImportJob] request, and part of the [DataDestination] object.
    public struct S3Config: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key.
        public var kMSKeyArn: Swift.String?
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.
        /// This member is required.
        public var path: Swift.String?
        /// The ARN of the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3 bucket or files. If you provide a value for the KMSKeyArn key, the role must allow access to the key. Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an InvalidInputException error.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            kMSKeyArn: Swift.String? = nil,
            path: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.kMSKeyArn = kMSKeyArn
            self.path = path
            self.roleArn = roleArn
        }
    }

}

extension ForecastClientTypes {
    public enum ScalingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case linear
        case logarithmic
        case reverselogarithmic
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalingType] {
            return [
                .auto,
                .linear,
                .logarithmic,
                .reverselogarithmic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .linear: return "Linear"
            case .logarithmic: return "Logarithmic"
            case .reverselogarithmic: return "ReverseLogarithmic"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScalingType(rawValue: rawValue) ?? ScalingType.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Schema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for schemaattributes0 in attributes {
                try attributesContainer.encode(schemaattributes0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([ForecastClientTypes.SchemaAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ForecastClientTypes.SchemaAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ForecastClientTypes.SchemaAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ForecastClientTypes {
    /// Defines the fields of a dataset. You specify this object in the [CreateDataset] request.
    public struct Schema: Swift.Equatable {
        /// An array of attributes specifying the name and type of each field in a dataset.
        public var attributes: [ForecastClientTypes.SchemaAttribute]?

        public init (
            attributes: [ForecastClientTypes.SchemaAttribute]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension ForecastClientTypes.SchemaAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeType = "AttributeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let attributeType = attributeType {
            try encodeContainer.encode(attributeType.rawValue, forKey: .attributeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.AttributeType.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
    }
}

extension ForecastClientTypes {
    /// An attribute of a schema, which defines a dataset field. A schema attribute is required for every field in a dataset. The [Schema] object contains an array of SchemaAttribute objects.
    public struct SchemaAttribute: Swift.Equatable {
        /// The name of the dataset field.
        public var attributeName: Swift.String?
        /// The data type of the field.
        public var attributeType: ForecastClientTypes.AttributeType?

        public init (
            attributeName: Swift.String? = nil,
            attributeType: ForecastClientTypes.AttributeType? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeType = attributeType
        }
    }

}

extension ForecastClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .deleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleted: return "Deleted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes.Statistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avg = "Avg"
        case count = "Count"
        case countDistinct = "CountDistinct"
        case countDistinctLong = "CountDistinctLong"
        case countLong = "CountLong"
        case countNan = "CountNan"
        case countNanLong = "CountNanLong"
        case countNull = "CountNull"
        case countNullLong = "CountNullLong"
        case max = "Max"
        case min = "Min"
        case stddev = "Stddev"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avg = avg {
            try encodeContainer.encode(avg, forKey: .avg)
        }
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let countDistinct = countDistinct {
            try encodeContainer.encode(countDistinct, forKey: .countDistinct)
        }
        if let countDistinctLong = countDistinctLong {
            try encodeContainer.encode(countDistinctLong, forKey: .countDistinctLong)
        }
        if let countLong = countLong {
            try encodeContainer.encode(countLong, forKey: .countLong)
        }
        if let countNan = countNan {
            try encodeContainer.encode(countNan, forKey: .countNan)
        }
        if let countNanLong = countNanLong {
            try encodeContainer.encode(countNanLong, forKey: .countNanLong)
        }
        if let countNull = countNull {
            try encodeContainer.encode(countNull, forKey: .countNull)
        }
        if let countNullLong = countNullLong {
            try encodeContainer.encode(countNullLong, forKey: .countNullLong)
        }
        if let max = max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let stddev = stddev {
            try encodeContainer.encode(stddev, forKey: .stddev)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let countDistinctDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countDistinct)
        countDistinct = countDistinctDecoded
        let countNullDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNull)
        countNull = countNullDecoded
        let countNanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNan)
        countNan = countNanDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .max)
        max = maxDecoded
        let avgDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .avg)
        avg = avgDecoded
        let stddevDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .stddev)
        stddev = stddevDecoded
        let countLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countLong)
        countLong = countLongDecoded
        let countDistinctLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countDistinctLong)
        countDistinctLong = countDistinctLongDecoded
        let countNullLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNullLong)
        countNullLong = countNullLongDecoded
        let countNanLongDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countNanLong)
        countNanLong = countNanLongDecoded
    }
}

extension ForecastClientTypes {
    /// Provides statistics for each data field imported into to an Amazon Forecast dataset with the [CreateDatasetImportJob] operation.
    public struct Statistics: Swift.Equatable {
        /// For a numeric field, the average value in the field.
        public var avg: Swift.Double?
        /// The number of values in the field. If the response value is -1, refer to CountLong.
        public var count: Swift.Int?
        /// The number of distinct values in the field. If the response value is -1, refer to CountDistinctLong.
        public var countDistinct: Swift.Int?
        /// The number of distinct values in the field. CountDistinctLong is used instead of CountDistinct if the value is greater than 2,147,483,647.
        public var countDistinctLong: Swift.Int?
        /// The number of values in the field. CountLong is used instead of Count if the value is greater than 2,147,483,647.
        public var countLong: Swift.Int?
        /// The number of NAN (not a number) values in the field. If the response value is -1, refer to CountNanLong.
        public var countNan: Swift.Int?
        /// The number of NAN (not a number) values in the field. CountNanLong is used instead of CountNan if the value is greater than 2,147,483,647.
        public var countNanLong: Swift.Int?
        /// The number of null values in the field. If the response value is -1, refer to CountNullLong.
        public var countNull: Swift.Int?
        /// The number of null values in the field. CountNullLong is used instead of CountNull if the value is greater than 2,147,483,647.
        public var countNullLong: Swift.Int?
        /// For a numeric field, the maximum value in the field.
        public var max: Swift.String?
        /// For a numeric field, the minimum value in the field.
        public var min: Swift.String?
        /// For a numeric field, the standard deviation.
        public var stddev: Swift.Double?

        public init (
            avg: Swift.Double? = nil,
            count: Swift.Int? = nil,
            countDistinct: Swift.Int? = nil,
            countDistinctLong: Swift.Int? = nil,
            countLong: Swift.Int? = nil,
            countNan: Swift.Int? = nil,
            countNanLong: Swift.Int? = nil,
            countNull: Swift.Int? = nil,
            countNullLong: Swift.Int? = nil,
            max: Swift.String? = nil,
            min: Swift.String? = nil,
            stddev: Swift.Double? = nil
        )
        {
            self.avg = avg
            self.count = count
            self.countDistinct = countDistinct
            self.countDistinctLong = countDistinctLong
            self.countLong = countLong
            self.countNan = countNan
            self.countNanLong = countNanLong
            self.countNull = countNull
            self.countNullLong = countNullLong
            self.max = max
            self.min = min
            self.stddev = stddev
        }
    }

}

extension StopResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension StopResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource to stop. The supported ARNs are DatasetImportJobArn, PredictorArn, PredictorBacktestExportJobArn, ForecastArn, and ForecastExportJobArn.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct StopResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension StopResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension StopResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopResourceOutputResponse: Swift.Equatable {

}

extension ForecastClientTypes.SupplementaryFeature: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ForecastClientTypes {
    /// Describes a supplementary feature of a dataset group. This object is part of the [InputDataConfig] object. Forecast supports the Weather Index and Holidays built-in featurizations. Weather Index The Amazon Forecast Weather Index is a built-in featurization that incorporates historical and projected weather information into your model. The Weather Index supplements your datasets with over two years of historical weather data and up to 14 days of projected weather data. For more information, see [Amazon Forecast Weather Index](https://docs.aws.amazon.com/forecast/latest/dg/weather.html). Holidays Holidays is a built-in featurization that incorporates a feature-engineered dataset of national holiday information into your model. It provides native support for the holiday calendars of 66 countries. To view the holiday calendars, refer to the [Jollyday](http://jollyday.sourceforge.net/data.html) library. For more information, see [Holidays Featurization](https://docs.aws.amazon.com/forecast/latest/dg/holidays.html).
    public struct SupplementaryFeature: Swift.Equatable {
        /// The name of the feature. Valid values: "holiday" and "weather".
        /// This member is required.
        public var name: Swift.String?
        /// Weather Index To enable the Weather Index, set the value to "true" Holidays To enable Holidays, specify a country with one of the following two-letter country codes:
        ///
        /// * "AL" - ALBANIA
        ///
        /// * "AR" - ARGENTINA
        ///
        /// * "AT" - AUSTRIA
        ///
        /// * "AU" - AUSTRALIA
        ///
        /// * "BA" - BOSNIA HERZEGOVINA
        ///
        /// * "BE" - BELGIUM
        ///
        /// * "BG" - BULGARIA
        ///
        /// * "BO" - BOLIVIA
        ///
        /// * "BR" - BRAZIL
        ///
        /// * "BY" - BELARUS
        ///
        /// * "CA" - CANADA
        ///
        /// * "CL" - CHILE
        ///
        /// * "CO" - COLOMBIA
        ///
        /// * "CR" - COSTA RICA
        ///
        /// * "HR" - CROATIA
        ///
        /// * "CZ" - CZECH REPUBLIC
        ///
        /// * "DK" - DENMARK
        ///
        /// * "EC" - ECUADOR
        ///
        /// * "EE" - ESTONIA
        ///
        /// * "ET" - ETHIOPIA
        ///
        /// * "FI" - FINLAND
        ///
        /// * "FR" - FRANCE
        ///
        /// * "DE" - GERMANY
        ///
        /// * "GR" - GREECE
        ///
        /// * "HU" - HUNGARY
        ///
        /// * "IS" - ICELAND
        ///
        /// * "IN" - INDIA
        ///
        /// * "IE" - IRELAND
        ///
        /// * "IT" - ITALY
        ///
        /// * "JP" - JAPAN
        ///
        /// * "KZ" - KAZAKHSTAN
        ///
        /// * "KR" - KOREA
        ///
        /// * "LV" - LATVIA
        ///
        /// * "LI" - LIECHTENSTEIN
        ///
        /// * "LT" - LITHUANIA
        ///
        /// * "LU" - LUXEMBOURG
        ///
        /// * "MK" - MACEDONIA
        ///
        /// * "MT" - MALTA
        ///
        /// * "MX" - MEXICO
        ///
        /// * "MD" - MOLDOVA
        ///
        /// * "ME" - MONTENEGRO
        ///
        /// * "NL" - NETHERLANDS
        ///
        /// * "NZ" - NEW ZEALAND
        ///
        /// * "NI" - NICARAGUA
        ///
        /// * "NG" - NIGERIA
        ///
        /// * "NO" - NORWAY
        ///
        /// * "PA" - PANAMA
        ///
        /// * "PY" - PARAGUAY
        ///
        /// * "PE" - PERU
        ///
        /// * "PL" - POLAND
        ///
        /// * "PT" - PORTUGAL
        ///
        /// * "RO" - ROMANIA
        ///
        /// * "RU" - RUSSIA
        ///
        /// * "RS" - SERBIA
        ///
        /// * "SK" - SLOVAKIA
        ///
        /// * "SI" - SLOVENIA
        ///
        /// * "ZA" - SOUTH AFRICA
        ///
        /// * "ES" - SPAIN
        ///
        /// * "SE" - SWEDEN
        ///
        /// * "CH" - SWITZERLAND
        ///
        /// * "UA" - UKRAINE
        ///
        /// * "AE" - UNITED ARAB EMIRATES
        ///
        /// * "US" - UNITED STATES
        ///
        /// * "UK" - UNITED KINGDOM
        ///
        /// * "UY" - URUGUAY
        ///
        /// * "VE" - VENEZUELA
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ForecastClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ForecastClientTypes {
    /// The optional metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key).
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are Forecast dataset groups, datasets, dataset import jobs, predictors, forecasts, and forecast export jobs.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs. The following basic restrictions apply to tags:
    ///
    /// * Maximum number of tags per resource - 50.
    ///
    /// * For each resource, each tag key must be unique, and each tag key can have only one value.
    ///
    /// * Maximum key length - 128 Unicode characters in UTF-8.
    ///
    /// * Maximum value length - 256 Unicode characters in UTF-8.
    ///
    /// * If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
    /// This member is required.
    public var tags: [ForecastClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [ForecastClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [ForecastClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ForecastClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ForecastClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ForecastClientTypes.TestWindowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case status = "Status"
        case testWindowEnd = "TestWindowEnd"
        case testWindowStart = "TestWindowStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let testWindowEnd = testWindowEnd {
            try encodeContainer.encode(testWindowEnd.timeIntervalSince1970, forKey: .testWindowEnd)
        }
        if let testWindowStart = testWindowStart {
            try encodeContainer.encode(testWindowStart.timeIntervalSince1970, forKey: .testWindowStart)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testWindowStartDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .testWindowStart)
        testWindowStart = testWindowStartDecoded
        let testWindowEndDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .testWindowEnd)
        testWindowEnd = testWindowEndDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ForecastClientTypes {
    /// The status, start time, and end time of a backtest, as well as a failure reason if applicable.
    public struct TestWindowSummary: Swift.Equatable {
        /// If the test failed, the reason why it failed.
        public var message: Swift.String?
        /// The status of the test. Possible status values are:
        ///
        /// * ACTIVE
        ///
        /// * CREATE_IN_PROGRESS
        ///
        /// * CREATE_FAILED
        public var status: Swift.String?
        /// The time at which the test ended.
        public var testWindowEnd: ClientRuntime.Date?
        /// The time at which the test began.
        public var testWindowStart: ClientRuntime.Date?

        public init (
            message: Swift.String? = nil,
            status: Swift.String? = nil,
            testWindowEnd: ClientRuntime.Date? = nil,
            testWindowStart: ClientRuntime.Date? = nil
        )
        {
            self.message = message
            self.status = status
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }
    }

}

extension ForecastClientTypes {
    public enum TimePointGranularity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case specific
        case sdkUnknown(Swift.String)

        public static var allCases: [TimePointGranularity] {
            return [
                .all,
                .specific,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .specific: return "SPECIFIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimePointGranularity(rawValue: rawValue) ?? TimePointGranularity.sdkUnknown(rawValue)
        }
    }
}

extension ForecastClientTypes {
    public enum TimeSeriesGranularity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case specific
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeSeriesGranularity] {
            return [
                .all,
                .specific,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .specific: return "SPECIFIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeSeriesGranularity(rawValue: rawValue) ?? TimeSeriesGranularity.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are Forecast dataset groups, datasets, dataset import jobs, predictors, forecasts, and forecast exports.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArns = datasetArns {
            var datasetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetArns)
            for arnlist0 in datasetArns {
                try datasetArnsContainer.encode(arnlist0)
            }
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension UpdateDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDatasetGroupInput: Swift.Equatable {
    /// An array of the Amazon Resource Names (ARNs) of the datasets to add to the dataset group.
    /// This member is required.
    public var datasetArns: [Swift.String]?
    /// The ARN of the dataset group.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetArns: [Swift.String]? = nil,
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetArns = datasetArns
        self.datasetGroupArn = datasetGroupArn
    }
}

struct UpdateDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let datasetArns: [Swift.String]?
}

extension UpdateDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[Swift.String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [Swift.String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
    }
}

extension UpdateDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatasetGroupOutputResponse: Swift.Equatable {

}

extension ForecastClientTypes.WeightedQuantileLoss: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lossValue = "LossValue"
        case quantile = "Quantile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lossValue = lossValue {
            try encodeContainer.encode(lossValue, forKey: .lossValue)
        }
        if let quantile = quantile {
            try encodeContainer.encode(quantile, forKey: .quantile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantileDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .quantile)
        quantile = quantileDecoded
        let lossValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lossValue)
        lossValue = lossValueDecoded
    }
}

extension ForecastClientTypes {
    /// The weighted loss value for a quantile. This object is part of the [Metrics] object.
    public struct WeightedQuantileLoss: Swift.Equatable {
        /// The difference between the predicted value and the actual value over the quantile, weighted (normalized) by dividing by the sum over all quantiles.
        public var lossValue: Swift.Double?
        /// The quantile. Quantiles divide a probability distribution into regions of equal probability. For example, if the distribution was divided into 5 regions of equal probability, the quantiles would be 0.2, 0.4, 0.6, and 0.8.
        public var quantile: Swift.Double?

        public init (
            lossValue: Swift.Double? = nil,
            quantile: Swift.Double? = nil
        )
        {
            self.lossValue = lossValue
            self.quantile = quantile
        }
    }

}

extension ForecastClientTypes.WindowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationType = "EvaluationType"
        case itemCount = "ItemCount"
        case metrics = "Metrics"
        case testWindowEnd = "TestWindowEnd"
        case testWindowStart = "TestWindowStart"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationType = evaluationType {
            try encodeContainer.encode(evaluationType.rawValue, forKey: .evaluationType)
        }
        if let itemCount = itemCount {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let metrics = metrics {
            try encodeContainer.encode(metrics, forKey: .metrics)
        }
        if let testWindowEnd = testWindowEnd {
            try encodeContainer.encode(testWindowEnd.timeIntervalSince1970, forKey: .testWindowEnd)
        }
        if let testWindowStart = testWindowStart {
            try encodeContainer.encode(testWindowStart.timeIntervalSince1970, forKey: .testWindowStart)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testWindowStartDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .testWindowStart)
        testWindowStart = testWindowStartDecoded
        let testWindowEndDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .testWindowEnd)
        testWindowEnd = testWindowEndDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let evaluationTypeDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.EvaluationType.self, forKey: .evaluationType)
        evaluationType = evaluationTypeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.Metrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

extension ForecastClientTypes {
    /// The metrics for a time range within the evaluation portion of a dataset. This object is part of the [EvaluationResult] object. The TestWindowStart and TestWindowEnd parameters are determined by the BackTestWindowOffset parameter of the [EvaluationParameters] object.
    public struct WindowSummary: Swift.Equatable {
        /// The type of evaluation.
        ///
        /// * SUMMARY - The average metrics across all windows.
        ///
        /// * COMPUTED - The metrics for the specified window.
        public var evaluationType: ForecastClientTypes.EvaluationType?
        /// The number of data points within the window.
        public var itemCount: Swift.Int?
        /// Provides metrics used to evaluate the performance of a predictor.
        public var metrics: ForecastClientTypes.Metrics?
        /// The timestamp that defines the end of the window.
        public var testWindowEnd: ClientRuntime.Date?
        /// The timestamp that defines the start of the window.
        public var testWindowStart: ClientRuntime.Date?

        public init (
            evaluationType: ForecastClientTypes.EvaluationType? = nil,
            itemCount: Swift.Int? = nil,
            metrics: ForecastClientTypes.Metrics? = nil,
            testWindowEnd: ClientRuntime.Date? = nil,
            testWindowStart: ClientRuntime.Date? = nil
        )
        {
            self.evaluationType = evaluationType
            self.itemCount = itemCount
            self.metrics = metrics
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }
    }

}
