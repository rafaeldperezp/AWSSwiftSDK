// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have sufficient permissions to query the routing control state.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a conflict with this request. Try again.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the ConflictException error
    /// This member is required.
    public var message: Swift.String?
    /// Identifier of the resource in use
    /// This member is required.
    public var resourceId: Swift.String?
    /// Type of the resource in use
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension EndpointTemporarilyUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EndpointTemporarilyUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The cluster endpoint isn't available. Try another cluster endpoint.
public struct EndpointTemporarilyUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointTemporarilyUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EndpointTemporarilyUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetRoutingControlStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routingControlArn = routingControlArn {
            try encodeContainer.encode(routingControlArn, forKey: .routingControlArn)
        }
    }
}

extension GetRoutingControlStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRoutingControlStateInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) for the routing control that you want to get the state for.
    /// This member is required.
    public var routingControlArn: Swift.String?

    public init (
        routingControlArn: Swift.String? = nil
    )
    {
        self.routingControlArn = routingControlArn
    }
}

struct GetRoutingControlStateInputBody: Swift.Equatable {
    let routingControlArn: Swift.String?
}

extension GetRoutingControlStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
    }
}

extension GetRoutingControlStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRoutingControlStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointTemporarilyUnavailableException" : self = .endpointTemporarilyUnavailableException(try EndpointTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRoutingControlStateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case endpointTemporarilyUnavailableException(EndpointTemporarilyUnavailableException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoutingControlStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRoutingControlStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.routingControlArn = output.routingControlArn
            self.routingControlState = output.routingControlState
        } else {
            self.routingControlArn = nil
            self.routingControlState = nil
        }
    }
}

public struct GetRoutingControlStateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the response.
    /// This member is required.
    public var routingControlArn: Swift.String?
    /// The state of the routing control.
    /// This member is required.
    public var routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?

    public init (
        routingControlArn: Swift.String? = nil,
        routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState? = nil
    )
    {
        self.routingControlArn = routingControlArn
        self.routingControlState = routingControlState
    }
}

struct GetRoutingControlStateOutputResponseBody: Swift.Equatable {
    let routingControlArn: Swift.String?
    let routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?
}

extension GetRoutingControlStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
        case routingControlState = "RoutingControlState"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
        let routingControlStateDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.RoutingControlState.self, forKey: .routingControlState)
        routingControlState = routingControlStateDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an unexpected error during processing of the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// Advice to clients on when the call can be safely retried
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request references a routing control that was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Hypothetical resource identifier that was not found
    /// This member is required.
    public var resourceId: Swift.String?
    /// Hypothetical resource type that was not found
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension Route53RecoveryClusterClientTypes {
    public enum RoutingControlState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingControlState] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "Off"
            case .on: return "On"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoutingControlState(rawValue: rawValue) ?? RoutingControlState.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because of request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Advice to clients on when the call can be safely retried
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
        case routingControlState = "RoutingControlState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routingControlArn = routingControlArn {
            try encodeContainer.encode(routingControlArn, forKey: .routingControlArn)
        }
        if let routingControlState = routingControlState {
            try encodeContainer.encode(routingControlState.rawValue, forKey: .routingControlState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
        let routingControlStateDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.RoutingControlState.self, forKey: .routingControlState)
        routingControlState = routingControlStateDecoded
    }
}

extension Route53RecoveryClusterClientTypes {
    /// A routing control state.
    public struct UpdateRoutingControlStateEntry: Swift.Equatable {
        /// The Amazon Resource Number (ARN) for the routing control state entry.
        /// This member is required.
        public var routingControlArn: Swift.String?
        /// The routing control state in a set of routing control state entries.
        /// This member is required.
        public var routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?

        public init (
            routingControlArn: Swift.String? = nil,
            routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState? = nil
        )
        {
            self.routingControlArn = routingControlArn
            self.routingControlState = routingControlState
        }
    }

}

extension UpdateRoutingControlStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
        case routingControlState = "RoutingControlState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let routingControlArn = routingControlArn {
            try encodeContainer.encode(routingControlArn, forKey: .routingControlArn)
        }
        if let routingControlState = routingControlState {
            try encodeContainer.encode(routingControlState.rawValue, forKey: .routingControlState)
        }
    }
}

extension UpdateRoutingControlStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRoutingControlStateInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) for the routing control that you want to update the state for.
    /// This member is required.
    public var routingControlArn: Swift.String?
    /// The state of the routing control. You can set the value to be On or Off.
    /// This member is required.
    public var routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?

    public init (
        routingControlArn: Swift.String? = nil,
        routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState? = nil
    )
    {
        self.routingControlArn = routingControlArn
        self.routingControlState = routingControlState
    }
}

struct UpdateRoutingControlStateInputBody: Swift.Equatable {
    let routingControlArn: Swift.String?
    let routingControlState: Route53RecoveryClusterClientTypes.RoutingControlState?
}

extension UpdateRoutingControlStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case routingControlArn = "RoutingControlArn"
        case routingControlState = "RoutingControlState"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routingControlArn)
        routingControlArn = routingControlArnDecoded
        let routingControlStateDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.RoutingControlState.self, forKey: .routingControlState)
        routingControlState = routingControlStateDecoded
    }
}

extension UpdateRoutingControlStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoutingControlStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointTemporarilyUnavailableException" : self = .endpointTemporarilyUnavailableException(try EndpointTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoutingControlStateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case endpointTemporarilyUnavailableException(EndpointTemporarilyUnavailableException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoutingControlStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoutingControlStateOutputResponse: Swift.Equatable {

}

extension UpdateRoutingControlStatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateRoutingControlStateEntries = "UpdateRoutingControlStateEntries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updateRoutingControlStateEntries = updateRoutingControlStateEntries {
            var updateRoutingControlStateEntriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateRoutingControlStateEntries)
            for updateroutingcontrolstateentries0 in updateRoutingControlStateEntries {
                try updateRoutingControlStateEntriesContainer.encode(updateroutingcontrolstateentries0)
            }
        }
    }
}

extension UpdateRoutingControlStatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRoutingControlStatesInput: Swift.Equatable {
    /// A set of routing control entries that you want to update.
    /// This member is required.
    public var updateRoutingControlStateEntries: [Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]?

    public init (
        updateRoutingControlStateEntries: [Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]? = nil
    )
    {
        self.updateRoutingControlStateEntries = updateRoutingControlStateEntries
    }
}

struct UpdateRoutingControlStatesInputBody: Swift.Equatable {
    let updateRoutingControlStateEntries: [Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]?
}

extension UpdateRoutingControlStatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateRoutingControlStateEntries = "UpdateRoutingControlStateEntries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateRoutingControlStateEntriesContainer = try containerValues.decodeIfPresent([Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry?].self, forKey: .updateRoutingControlStateEntries)
        var updateRoutingControlStateEntriesDecoded0:[Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]? = nil
        if let updateRoutingControlStateEntriesContainer = updateRoutingControlStateEntriesContainer {
            updateRoutingControlStateEntriesDecoded0 = [Route53RecoveryClusterClientTypes.UpdateRoutingControlStateEntry]()
            for structure0 in updateRoutingControlStateEntriesContainer {
                if let structure0 = structure0 {
                    updateRoutingControlStateEntriesDecoded0?.append(structure0)
                }
            }
        }
        updateRoutingControlStateEntries = updateRoutingControlStateEntriesDecoded0
    }
}

extension UpdateRoutingControlStatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoutingControlStatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointTemporarilyUnavailableException" : self = .endpointTemporarilyUnavailableException(try EndpointTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoutingControlStatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case endpointTemporarilyUnavailableException(EndpointTemporarilyUnavailableException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoutingControlStatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoutingControlStatesOutputResponse: Swift.Equatable {

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a validation error on the request.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that caused the error, if applicable
    public var fields: [Route53RecoveryClusterClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// Reason the request failed validation
    public var reason: Route53RecoveryClusterClientTypes.ValidationExceptionReason?

    public init (
        fields: [Route53RecoveryClusterClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: Route53RecoveryClusterClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Route53RecoveryClusterClientTypes.ValidationExceptionReason?
    let fields: [Route53RecoveryClusterClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Route53RecoveryClusterClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Route53RecoveryClusterClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[Route53RecoveryClusterClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Route53RecoveryClusterClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension Route53RecoveryClusterClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53RecoveryClusterClientTypes {
    /// There was a validation error on the request.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Information about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The field that had the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension Route53RecoveryClusterClientTypes {
    /// Reason the request failed validation
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
