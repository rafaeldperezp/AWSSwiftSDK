// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListDataSourcesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDataSourcesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDataSourcesOutputResponse`
extension KendraClient {
    public func listDataSourcesPaginated(input: ListDataSourcesInput) -> ClientRuntime.PaginatorSequence<ListDataSourcesInput, ListDataSourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDataSourcesInput, ListDataSourcesOutputResponse>(input: input, inputKey: \ListDataSourcesInput.nextToken, outputKey: \ListDataSourcesOutputResponse.nextToken, paginationFunction: self.listDataSources(input:))
    }
}

extension ListDataSourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataSourcesInput {
        return ListDataSourcesInput(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListDataSourceSyncJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDataSourceSyncJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDataSourceSyncJobsOutputResponse`
extension KendraClient {
    public func listDataSourceSyncJobsPaginated(input: ListDataSourceSyncJobsInput) -> ClientRuntime.PaginatorSequence<ListDataSourceSyncJobsInput, ListDataSourceSyncJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDataSourceSyncJobsInput, ListDataSourceSyncJobsOutputResponse>(input: input, inputKey: \ListDataSourceSyncJobsInput.nextToken, outputKey: \ListDataSourceSyncJobsOutputResponse.nextToken, paginationFunction: self.listDataSourceSyncJobs(input:))
    }
}

extension ListDataSourceSyncJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataSourceSyncJobsInput {
        return ListDataSourceSyncJobsInput(
            id: self.id,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token,
            startTimeFilter: self.startTimeFilter,
            statusFilter: self.statusFilter
        )}
}

/// Paginate over `[ListEntityPersonasOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListEntityPersonasInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListEntityPersonasOutputResponse`
extension KendraClient {
    public func listEntityPersonasPaginated(input: ListEntityPersonasInput) -> ClientRuntime.PaginatorSequence<ListEntityPersonasInput, ListEntityPersonasOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEntityPersonasInput, ListEntityPersonasOutputResponse>(input: input, inputKey: \ListEntityPersonasInput.nextToken, outputKey: \ListEntityPersonasOutputResponse.nextToken, paginationFunction: self.listEntityPersonas(input:))
    }
}

extension ListEntityPersonasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEntityPersonasInput {
        return ListEntityPersonasInput(
            id: self.id,
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListExperienceEntitiesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListExperienceEntitiesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListExperienceEntitiesOutputResponse`
extension KendraClient {
    public func listExperienceEntitiesPaginated(input: ListExperienceEntitiesInput) -> ClientRuntime.PaginatorSequence<ListExperienceEntitiesInput, ListExperienceEntitiesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListExperienceEntitiesInput, ListExperienceEntitiesOutputResponse>(input: input, inputKey: \ListExperienceEntitiesInput.nextToken, outputKey: \ListExperienceEntitiesOutputResponse.nextToken, paginationFunction: self.listExperienceEntities(input:))
    }
}

extension ListExperienceEntitiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExperienceEntitiesInput {
        return ListExperienceEntitiesInput(
            id: self.id,
            indexId: self.indexId,
            nextToken: token
        )}
}

/// Paginate over `[ListExperiencesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListExperiencesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListExperiencesOutputResponse`
extension KendraClient {
    public func listExperiencesPaginated(input: ListExperiencesInput) -> ClientRuntime.PaginatorSequence<ListExperiencesInput, ListExperiencesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListExperiencesInput, ListExperiencesOutputResponse>(input: input, inputKey: \ListExperiencesInput.nextToken, outputKey: \ListExperiencesOutputResponse.nextToken, paginationFunction: self.listExperiences(input:))
    }
}

extension ListExperiencesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExperiencesInput {
        return ListExperiencesInput(
            indexId: self.indexId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListIndicesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListIndicesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListIndicesOutputResponse`
extension KendraClient {
    public func listIndicesPaginated(input: ListIndicesInput) -> ClientRuntime.PaginatorSequence<ListIndicesInput, ListIndicesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIndicesInput, ListIndicesOutputResponse>(input: input, inputKey: \ListIndicesInput.nextToken, outputKey: \ListIndicesOutputResponse.nextToken, paginationFunction: self.listIndices(input:))
    }
}

extension ListIndicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIndicesInput {
        return ListIndicesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
