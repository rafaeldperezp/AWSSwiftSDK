// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListPublicKeysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPublicKeysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPublicKeysOutputResponse`
extension CloudTrailClient {
    public func listPublicKeysPaginated(input: ListPublicKeysInput) -> ClientRuntime.PaginatorSequence<ListPublicKeysInput, ListPublicKeysOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPublicKeysInput, ListPublicKeysOutputResponse>(input: input, inputKey: \ListPublicKeysInput.nextToken, outputKey: \ListPublicKeysOutputResponse.nextToken, paginationFunction: self.listPublicKeys(input:))
    }
}

extension ListPublicKeysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPublicKeysInput {
        return ListPublicKeysInput(
            endTime: self.endTime,
            nextToken: token,
            startTime: self.startTime
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPublicKeysPaginated`
/// to access the nested member `[CloudTrailClientTypes.PublicKey]`
/// - Returns: `[CloudTrailClientTypes.PublicKey]`
extension PaginatorSequence where Input == ListPublicKeysInput, Output == ListPublicKeysOutputResponse {
    func publicKeyList() async throws -> [CloudTrailClientTypes.PublicKey] {
        return try await self.asyncCompactMap { item in item.publicKeyList }
    }
}

/// Paginate over `[ListTagsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTagsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTagsOutputResponse`
extension CloudTrailClient {
    public func listTagsPaginated(input: ListTagsInput) -> ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutputResponse>(input: input, inputKey: \ListTagsInput.nextToken, outputKey: \ListTagsOutputResponse.nextToken, paginationFunction: self.listTags(input:))
    }
}

extension ListTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsInput {
        return ListTagsInput(
            nextToken: token,
            resourceIdList: self.resourceIdList
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTagsPaginated`
/// to access the nested member `[CloudTrailClientTypes.ResourceTag]`
/// - Returns: `[CloudTrailClientTypes.ResourceTag]`
extension PaginatorSequence where Input == ListTagsInput, Output == ListTagsOutputResponse {
    func resourceTagList() async throws -> [CloudTrailClientTypes.ResourceTag] {
        return try await self.asyncCompactMap { item in item.resourceTagList }
    }
}

/// Paginate over `[ListTrailsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTrailsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTrailsOutputResponse`
extension CloudTrailClient {
    public func listTrailsPaginated(input: ListTrailsInput) -> ClientRuntime.PaginatorSequence<ListTrailsInput, ListTrailsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTrailsInput, ListTrailsOutputResponse>(input: input, inputKey: \ListTrailsInput.nextToken, outputKey: \ListTrailsOutputResponse.nextToken, paginationFunction: self.listTrails(input:))
    }
}

extension ListTrailsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTrailsInput {
        return ListTrailsInput(
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTrailsPaginated`
/// to access the nested member `[CloudTrailClientTypes.TrailInfo]`
/// - Returns: `[CloudTrailClientTypes.TrailInfo]`
extension PaginatorSequence where Input == ListTrailsInput, Output == ListTrailsOutputResponse {
    func trails() async throws -> [CloudTrailClientTypes.TrailInfo] {
        return try await self.asyncCompactMap { item in item.trails }
    }
}

/// Paginate over `[LookupEventsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[LookupEventsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `LookupEventsOutputResponse`
extension CloudTrailClient {
    public func lookupEventsPaginated(input: LookupEventsInput) -> ClientRuntime.PaginatorSequence<LookupEventsInput, LookupEventsOutputResponse> {
        return ClientRuntime.PaginatorSequence<LookupEventsInput, LookupEventsOutputResponse>(input: input, inputKey: \LookupEventsInput.nextToken, outputKey: \LookupEventsOutputResponse.nextToken, paginationFunction: self.lookupEvents(input:))
    }
}

extension LookupEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> LookupEventsInput {
        return LookupEventsInput(
            endTime: self.endTime,
            eventCategory: self.eventCategory,
            lookupAttributes: self.lookupAttributes,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `lookupEventsPaginated`
/// to access the nested member `[CloudTrailClientTypes.Event]`
/// - Returns: `[CloudTrailClientTypes.Event]`
extension PaginatorSequence where Input == LookupEventsInput, Output == LookupEventsOutputResponse {
    func events() async throws -> [CloudTrailClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}
