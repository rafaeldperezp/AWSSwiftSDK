// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BatchGetNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryIds = "NamedQueryIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedQueryIds = namedQueryIds {
            var namedQueryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .namedQueryIds)
            for namedqueryidlist0 in namedQueryIds {
                try namedQueryIdsContainer.encode(namedqueryidlist0)
            }
        }
    }
}

extension BatchGetNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetNamedQueryInput: Swift.Equatable {
    /// An array of query IDs.
    /// This member is required.
    public var namedQueryIds: [Swift.String]?

    public init (
        namedQueryIds: [Swift.String]? = nil
    )
    {
        self.namedQueryIds = namedQueryIds
    }
}

struct BatchGetNamedQueryInputBody: Swift.Equatable {
    let namedQueryIds: [Swift.String]?
}

extension BatchGetNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryIds = "NamedQueryIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .namedQueryIds)
        var namedQueryIdsDecoded0:[Swift.String]? = nil
        if let namedQueryIdsContainer = namedQueryIdsContainer {
            namedQueryIdsDecoded0 = [Swift.String]()
            for string0 in namedQueryIdsContainer {
                if let string0 = string0 {
                    namedQueryIdsDecoded0?.append(string0)
                }
            }
        }
        namedQueryIds = namedQueryIdsDecoded0
    }
}

extension BatchGetNamedQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetNamedQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetNamedQueryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetNamedQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetNamedQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namedQueries = output.namedQueries
            self.unprocessedNamedQueryIds = output.unprocessedNamedQueryIds
        } else {
            self.namedQueries = nil
            self.unprocessedNamedQueryIds = nil
        }
    }
}

public struct BatchGetNamedQueryOutputResponse: Swift.Equatable {
    /// Information about the named query IDs submitted.
    public var namedQueries: [AthenaClientTypes.NamedQuery]?
    /// Information about provided query IDs.
    public var unprocessedNamedQueryIds: [AthenaClientTypes.UnprocessedNamedQueryId]?

    public init (
        namedQueries: [AthenaClientTypes.NamedQuery]? = nil,
        unprocessedNamedQueryIds: [AthenaClientTypes.UnprocessedNamedQueryId]? = nil
    )
    {
        self.namedQueries = namedQueries
        self.unprocessedNamedQueryIds = unprocessedNamedQueryIds
    }
}

struct BatchGetNamedQueryOutputResponseBody: Swift.Equatable {
    let namedQueries: [AthenaClientTypes.NamedQuery]?
    let unprocessedNamedQueryIds: [AthenaClientTypes.UnprocessedNamedQueryId]?
}

extension BatchGetNamedQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueries = "NamedQueries"
        case unprocessedNamedQueryIds = "UnprocessedNamedQueryIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueriesContainer = try containerValues.decodeIfPresent([AthenaClientTypes.NamedQuery?].self, forKey: .namedQueries)
        var namedQueriesDecoded0:[AthenaClientTypes.NamedQuery]? = nil
        if let namedQueriesContainer = namedQueriesContainer {
            namedQueriesDecoded0 = [AthenaClientTypes.NamedQuery]()
            for structure0 in namedQueriesContainer {
                if let structure0 = structure0 {
                    namedQueriesDecoded0?.append(structure0)
                }
            }
        }
        namedQueries = namedQueriesDecoded0
        let unprocessedNamedQueryIdsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.UnprocessedNamedQueryId?].self, forKey: .unprocessedNamedQueryIds)
        var unprocessedNamedQueryIdsDecoded0:[AthenaClientTypes.UnprocessedNamedQueryId]? = nil
        if let unprocessedNamedQueryIdsContainer = unprocessedNamedQueryIdsContainer {
            unprocessedNamedQueryIdsDecoded0 = [AthenaClientTypes.UnprocessedNamedQueryId]()
            for structure0 in unprocessedNamedQueryIdsContainer {
                if let structure0 = structure0 {
                    unprocessedNamedQueryIdsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedNamedQueryIds = unprocessedNamedQueryIdsDecoded0
    }
}

extension BatchGetQueryExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionIds = "QueryExecutionIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionIds = queryExecutionIds {
            var queryExecutionIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryExecutionIds)
            for queryexecutionidlist0 in queryExecutionIds {
                try queryExecutionIdsContainer.encode(queryexecutionidlist0)
            }
        }
    }
}

extension BatchGetQueryExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetQueryExecutionInput: Swift.Equatable {
    /// An array of query execution IDs.
    /// This member is required.
    public var queryExecutionIds: [Swift.String]?

    public init (
        queryExecutionIds: [Swift.String]? = nil
    )
    {
        self.queryExecutionIds = queryExecutionIds
    }
}

struct BatchGetQueryExecutionInputBody: Swift.Equatable {
    let queryExecutionIds: [Swift.String]?
}

extension BatchGetQueryExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionIds = "QueryExecutionIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queryExecutionIds)
        var queryExecutionIdsDecoded0:[Swift.String]? = nil
        if let queryExecutionIdsContainer = queryExecutionIdsContainer {
            queryExecutionIdsDecoded0 = [Swift.String]()
            for string0 in queryExecutionIdsContainer {
                if let string0 = string0 {
                    queryExecutionIdsDecoded0?.append(string0)
                }
            }
        }
        queryExecutionIds = queryExecutionIdsDecoded0
    }
}

extension BatchGetQueryExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetQueryExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetQueryExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetQueryExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetQueryExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryExecutions = output.queryExecutions
            self.unprocessedQueryExecutionIds = output.unprocessedQueryExecutionIds
        } else {
            self.queryExecutions = nil
            self.unprocessedQueryExecutionIds = nil
        }
    }
}

public struct BatchGetQueryExecutionOutputResponse: Swift.Equatable {
    /// Information about a query execution.
    public var queryExecutions: [AthenaClientTypes.QueryExecution]?
    /// Information about the query executions that failed to run.
    public var unprocessedQueryExecutionIds: [AthenaClientTypes.UnprocessedQueryExecutionId]?

    public init (
        queryExecutions: [AthenaClientTypes.QueryExecution]? = nil,
        unprocessedQueryExecutionIds: [AthenaClientTypes.UnprocessedQueryExecutionId]? = nil
    )
    {
        self.queryExecutions = queryExecutions
        self.unprocessedQueryExecutionIds = unprocessedQueryExecutionIds
    }
}

struct BatchGetQueryExecutionOutputResponseBody: Swift.Equatable {
    let queryExecutions: [AthenaClientTypes.QueryExecution]?
    let unprocessedQueryExecutionIds: [AthenaClientTypes.UnprocessedQueryExecutionId]?
}

extension BatchGetQueryExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutions = "QueryExecutions"
        case unprocessedQueryExecutionIds = "UnprocessedQueryExecutionIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.QueryExecution?].self, forKey: .queryExecutions)
        var queryExecutionsDecoded0:[AthenaClientTypes.QueryExecution]? = nil
        if let queryExecutionsContainer = queryExecutionsContainer {
            queryExecutionsDecoded0 = [AthenaClientTypes.QueryExecution]()
            for structure0 in queryExecutionsContainer {
                if let structure0 = structure0 {
                    queryExecutionsDecoded0?.append(structure0)
                }
            }
        }
        queryExecutions = queryExecutionsDecoded0
        let unprocessedQueryExecutionIdsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.UnprocessedQueryExecutionId?].self, forKey: .unprocessedQueryExecutionIds)
        var unprocessedQueryExecutionIdsDecoded0:[AthenaClientTypes.UnprocessedQueryExecutionId]? = nil
        if let unprocessedQueryExecutionIdsContainer = unprocessedQueryExecutionIdsContainer {
            unprocessedQueryExecutionIdsDecoded0 = [AthenaClientTypes.UnprocessedQueryExecutionId]()
            for structure0 in unprocessedQueryExecutionIdsContainer {
                if let structure0 = structure0 {
                    unprocessedQueryExecutionIdsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedQueryExecutionIds = unprocessedQueryExecutionIdsDecoded0
    }
}

extension AthenaClientTypes.Column: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension AthenaClientTypes {
    /// Contains metadata for a column in a table.
    public struct Column: Swift.Equatable {
        /// Optional information about the column.
        public var comment: Swift.String?
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the column.
        public var type: Swift.String?

        public init (
            comment: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.comment = comment
            self.name = name
            self.type = type
        }
    }

}

extension AthenaClientTypes.ColumnInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseSensitive = "CaseSensitive"
        case catalogName = "CatalogName"
        case label = "Label"
        case name = "Name"
        case nullable = "Nullable"
        case precision = "Precision"
        case scale = "Scale"
        case schemaName = "SchemaName"
        case tableName = "TableName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if caseSensitive != false {
            try encodeContainer.encode(caseSensitive, forKey: .caseSensitive)
        }
        if let catalogName = catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nullable = nullable {
            try encodeContainer.encode(nullable.rawValue, forKey: .nullable)
        }
        if precision != 0 {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if scale != 0 {
            try encodeContainer.encode(scale, forKey: .scale)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let precisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .precision)
        precision = precisionDecoded
        let scaleDecoded = try containerValues.decode(Swift.Int.self, forKey: .scale)
        scale = scaleDecoded
        let nullableDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ColumnNullable.self, forKey: .nullable)
        nullable = nullableDecoded
        let caseSensitiveDecoded = try containerValues.decode(Swift.Bool.self, forKey: .caseSensitive)
        caseSensitive = caseSensitiveDecoded
    }
}

extension AthenaClientTypes {
    /// Information about the columns in a query execution result.
    public struct ColumnInfo: Swift.Equatable {
        /// Indicates whether values in the column are case-sensitive.
        public var caseSensitive: Swift.Bool
        /// The catalog to which the query results belong.
        public var catalogName: Swift.String?
        /// A column label.
        public var label: Swift.String?
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates the column's nullable status.
        public var nullable: AthenaClientTypes.ColumnNullable?
        /// For DECIMAL data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.
        public var precision: Swift.Int
        /// For DECIMAL data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.
        public var scale: Swift.Int
        /// The schema name (database name) to which the query results belong.
        public var schemaName: Swift.String?
        /// The table name for the query results.
        public var tableName: Swift.String?
        /// The data type of the column.
        /// This member is required.
        public var type: Swift.String?

        public init (
            caseSensitive: Swift.Bool = false,
            catalogName: Swift.String? = nil,
            label: Swift.String? = nil,
            name: Swift.String? = nil,
            nullable: AthenaClientTypes.ColumnNullable? = nil,
            precision: Swift.Int = 0,
            scale: Swift.Int = 0,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.caseSensitive = caseSensitive
            self.catalogName = catalogName
            self.label = label
            self.name = name
            self.nullable = nullable
            self.precision = precision
            self.scale = scale
            self.schemaName = schemaName
            self.tableName = tableName
            self.type = type
        }
    }

}

extension AthenaClientTypes {
    public enum ColumnNullable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notNull
        case nullable
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnNullable] {
            return [
                .notNull,
                .nullable,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notNull: return "NOT_NULL"
            case .nullable: return "NULLABLE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnNullable(rawValue: rawValue) ?? ColumnNullable.sdkUnknown(rawValue)
        }
    }
}

extension CreateDataCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateDataCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDataCatalogInput: Swift.Equatable {
    /// A description of the data catalog to be created.
    public var description: Swift.String?
    /// The name of the data catalog to create. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 128 alphanumeric, underscore, at sign, or hyphen characters.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the Lambda function or functions to use for creating the data catalog. This is a mapping whose values depend on the catalog type.
    ///
    /// * For the HIVE data catalog type, use the following syntax. The metadata-function parameter is required. The sdk-version parameter is optional and defaults to the currently supported version. metadata-function=lambda_arn, sdk-version=version_number
    ///
    /// * For the LAMBDA data catalog type, use one of the following sets of required parameters, but not both.
    ///
    /// * If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required. metadata-function=lambda_arn, record-function=lambda_arn
    ///
    /// * If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function. function=lambda_arn
    ///
    ///
    ///
    ///
    /// * The GLUE type takes a catalog ID parameter and is required. The  catalog_id  is the account ID of the Amazon Web Services account to which the Glue Data Catalog belongs. catalog-id=catalog_id
    ///
    /// * The GLUE data catalog type also applies to the default AwsDataCatalog that already exists in your account, of which you can have only one and cannot modify.
    ///
    /// * Queries that specify a Glue Data Catalog other than the default AwsDataCatalog must be run on Athena engine version 2.
    ///
    /// * In Regions where Athena engine version 2 is not available, creating new Glue data catalogs results in an INVALID_INPUT error.
    public var parameters: [Swift.String:Swift.String]?
    /// A list of comma separated tags to add to the data catalog that is created.
    public var tags: [AthenaClientTypes.Tag]?
    /// The type of data catalog to create: LAMBDA for a federated catalog, HIVE for an external hive metastore, or GLUE for an Glue Data Catalog.
    /// This member is required.
    public var type: AthenaClientTypes.DataCatalogType?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        tags: [AthenaClientTypes.Tag]? = nil,
        type: AthenaClientTypes.DataCatalogType? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
        self.tags = tags
        self.type = type
    }
}

struct CreateDataCatalogInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: AthenaClientTypes.DataCatalogType?
    let description: Swift.String?
    let parameters: [Swift.String:Swift.String]?
    let tags: [AthenaClientTypes.Tag]?
}

extension CreateDataCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalogType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataCatalogOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateDataCatalogOutputResponse: Swift.Equatable {

}

extension CreateNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case database = "Database"
        case description = "Description"
        case name = "Name"
        case queryString = "QueryString"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension CreateNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateNamedQueryInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the query is idempotent (executes only once). If another CreateNamedQuery request is received, the same response is returned and another query is not created. If a parameter has changed, for example, the QueryString, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The database to which the query belongs.
    /// This member is required.
    public var database: Swift.String?
    /// The query description.
    public var description: Swift.String?
    /// The query name.
    /// This member is required.
    public var name: Swift.String?
    /// The contents of the query with all query statements.
    /// This member is required.
    public var queryString: Swift.String?
    /// The name of the workgroup in which the named query is being created.
    public var workGroup: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        database: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        queryString: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.database = database
        self.description = description
        self.name = name
        self.queryString = queryString
        self.workGroup = workGroup
    }
}

struct CreateNamedQueryInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let database: Swift.String?
    let queryString: Swift.String?
    let clientRequestToken: Swift.String?
    let workGroup: Swift.String?
}

extension CreateNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case database = "Database"
        case description = "Description"
        case name = "Name"
        case queryString = "QueryString"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension CreateNamedQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNamedQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNamedQueryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNamedQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateNamedQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namedQueryId = output.namedQueryId
        } else {
            self.namedQueryId = nil
        }
    }
}

public struct CreateNamedQueryOutputResponse: Swift.Equatable {
    /// The unique ID of the query.
    public var namedQueryId: Swift.String?

    public init (
        namedQueryId: Swift.String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

struct CreateNamedQueryOutputResponseBody: Swift.Equatable {
    let namedQueryId: Swift.String?
}

extension CreateNamedQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
    }
}

extension CreatePreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let queryStatement = queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension CreatePreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePreparedStatementInput: Swift.Equatable {
    /// The description of the prepared statement.
    public var description: Swift.String?
    /// The query string for the prepared statement.
    /// This member is required.
    public var queryStatement: Swift.String?
    /// The name of the prepared statement.
    /// This member is required.
    public var statementName: Swift.String?
    /// The name of the workgroup to which the prepared statement belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        description: Swift.String? = nil,
        queryStatement: Swift.String? = nil,
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.description = description
        self.queryStatement = queryStatement
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct CreatePreparedStatementInputBody: Swift.Equatable {
    let statementName: Swift.String?
    let workGroup: Swift.String?
    let queryStatement: Swift.String?
    let description: Swift.String?
}

extension CreatePreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreatePreparedStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePreparedStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePreparedStatementOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePreparedStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreatePreparedStatementOutputResponse: Swift.Equatable {

}

extension CreateWorkGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateWorkGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkGroupInput: Swift.Equatable {
    /// The configuration for the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption configuration, if any, used for encrypting query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, the limit for the amount of bytes scanned (cutoff) per query, if it is specified, and whether workgroup's settings (specified with EnforceWorkGroupConfiguration) in the WorkGroupConfiguration override client-side settings. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public var configuration: AthenaClientTypes.WorkGroupConfiguration?
    /// The workgroup description.
    public var description: Swift.String?
    /// The workgroup name.
    /// This member is required.
    public var name: Swift.String?
    /// A list of comma separated tags to add to the workgroup that is created.
    public var tags: [AthenaClientTypes.Tag]?

    public init (
        configuration: AthenaClientTypes.WorkGroupConfiguration? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateWorkGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let configuration: AthenaClientTypes.WorkGroupConfiguration?
    let description: Swift.String?
    let tags: [AthenaClientTypes.Tag]?
}

extension CreateWorkGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateWorkGroupOutputResponse: Swift.Equatable {

}

extension AthenaClientTypes.DataCatalog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalogType.self, forKey: .type)
        type = typeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains information about a data catalog in an Amazon Web Services account.
    public struct DataCatalog: Swift.Equatable {
        /// An optional description of the data catalog.
        public var description: Swift.String?
        /// The name of the data catalog. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 128 alphanumeric, underscore, at sign, or hyphen characters.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the Lambda function or functions to use for the data catalog. This is a mapping whose values depend on the catalog type.
        ///
        /// * For the HIVE data catalog type, use the following syntax. The metadata-function parameter is required. The sdk-version parameter is optional and defaults to the currently supported version. metadata-function=lambda_arn, sdk-version=version_number
        ///
        /// * For the LAMBDA data catalog type, use one of the following sets of required parameters, but not both.
        ///
        /// * If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required. metadata-function=lambda_arn, record-function=lambda_arn
        ///
        /// * If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function. function=lambda_arn
        ///
        ///
        ///
        ///
        /// * The GLUE type takes a catalog ID parameter and is required. The  catalog_id  is the account ID of the Amazon Web Services account to which the Glue catalog belongs. catalog-id=catalog_id
        ///
        /// * The GLUE data catalog type also applies to the default AwsDataCatalog that already exists in your account, of which you can have only one and cannot modify.
        ///
        /// * Queries that specify a Glue Data Catalog other than the default AwsDataCatalog must be run on Athena engine version 2.
        public var parameters: [Swift.String:Swift.String]?
        /// The type of data catalog to create: LAMBDA for a federated catalog, HIVE for an external hive metastore, or GLUE for an Glue Data Catalog.
        /// This member is required.
        public var type: AthenaClientTypes.DataCatalogType?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            type: AthenaClientTypes.DataCatalogType? = nil
        )
        {
            self.description = description
            self.name = name
            self.parameters = parameters
            self.type = type
        }
    }

}

extension AthenaClientTypes.DataCatalogSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalogType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AthenaClientTypes {
    /// The summary information for the data catalog, which includes its name and type.
    public struct DataCatalogSummary: Swift.Equatable {
        /// The name of the data catalog.
        public var catalogName: Swift.String?
        /// The data catalog type.
        public var type: AthenaClientTypes.DataCatalogType?

        public init (
            catalogName: Swift.String? = nil,
            type: AthenaClientTypes.DataCatalogType? = nil
        )
        {
            self.catalogName = catalogName
            self.type = type
        }
    }

}

extension AthenaClientTypes {
    public enum DataCatalogType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case glue
        case hive
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [DataCatalogType] {
            return [
                .glue,
                .hive,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .glue: return "GLUE"
            case .hive: return "HIVE"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataCatalogType(rawValue: rawValue) ?? DataCatalogType.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.Database: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains metadata information for a database in a data catalog.
    public struct Database: Swift.Equatable {
        /// An optional description of the database.
        public var description: Swift.String?
        /// The name of the database.
        /// This member is required.
        public var name: Swift.String?
        /// A set of custom key/value pairs.
        public var parameters: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.parameters = parameters
        }
    }

}

extension AthenaClientTypes.Datum: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case varCharValue = "VarCharValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let varCharValue = varCharValue {
            try encodeContainer.encode(varCharValue, forKey: .varCharValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let varCharValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .varCharValue)
        varCharValue = varCharValueDecoded
    }
}

extension AthenaClientTypes {
    /// A piece of data (a field in the table).
    public struct Datum: Swift.Equatable {
        /// The value of the datum.
        public var varCharValue: Swift.String?

        public init (
            varCharValue: Swift.String? = nil
        )
        {
            self.varCharValue = varCharValue
        }
    }

}

extension DeleteDataCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteDataCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDataCatalogInput: Swift.Equatable {
    /// The name of the data catalog to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDataCatalogInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteDataCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteDataCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataCatalogOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDataCatalogOutputResponse: Swift.Equatable {

}

extension DeleteNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedQueryId = namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
    }
}

extension DeleteNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNamedQueryInput: Swift.Equatable {
    /// The unique ID of the query to delete.
    /// This member is required.
    public var namedQueryId: Swift.String?

    public init (
        namedQueryId: Swift.String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

struct DeleteNamedQueryInputBody: Swift.Equatable {
    let namedQueryId: Swift.String?
}

extension DeleteNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
    }
}

extension DeleteNamedQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNamedQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNamedQueryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNamedQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNamedQueryOutputResponse: Swift.Equatable {

}

extension DeletePreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension DeletePreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePreparedStatementInput: Swift.Equatable {
    /// The name of the prepared statement to delete.
    /// This member is required.
    public var statementName: Swift.String?
    /// The workgroup to which the statement to be deleted belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct DeletePreparedStatementInputBody: Swift.Equatable {
    let statementName: Swift.String?
    let workGroup: Swift.String?
}

extension DeletePreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension DeletePreparedStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePreparedStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePreparedStatementOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePreparedStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePreparedStatementOutputResponse: Swift.Equatable {

}

extension DeleteWorkGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recursiveDeleteOption = "RecursiveDeleteOption"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recursiveDeleteOption = recursiveDeleteOption {
            try encodeContainer.encode(recursiveDeleteOption, forKey: .recursiveDeleteOption)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension DeleteWorkGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkGroupInput: Swift.Equatable {
    /// The option to delete the workgroup and its contents even if the workgroup contains any named queries or query executions.
    public var recursiveDeleteOption: Swift.Bool?
    /// The unique name of the workgroup to delete.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        recursiveDeleteOption: Swift.Bool? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.recursiveDeleteOption = recursiveDeleteOption
        self.workGroup = workGroup
    }
}

struct DeleteWorkGroupInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let recursiveDeleteOption: Swift.Bool?
}

extension DeleteWorkGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recursiveDeleteOption = "RecursiveDeleteOption"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let recursiveDeleteOptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .recursiveDeleteOption)
        recursiveDeleteOption = recursiveDeleteOptionDecoded
    }
}

extension DeleteWorkGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkGroupOutputResponse: Swift.Equatable {

}

extension AthenaClientTypes.EncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionOption = "EncryptionOption"
        case kmsKey = "KmsKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionOption = encryptionOption {
            try encodeContainer.encode(encryptionOption.rawValue, forKey: .encryptionOption)
        }
        if let kmsKey = kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionOptionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EncryptionOption.self, forKey: .encryptionOption)
        encryptionOption = encryptionOptionDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension AthenaClientTypes {
    /// If query results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE-KMS or CSE-KMS) and key information.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (SSE-S3), server-side encryption with KMS-managed keys (SSE-KMS), or client-side encryption with KMS-managed keys (CSE-KMS) is used. If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup.
        /// This member is required.
        public var encryptionOption: AthenaClientTypes.EncryptionOption?
        /// For SSE-KMS and CSE-KMS, this is the KMS key ARN or ID.
        public var kmsKey: Swift.String?

        public init (
            encryptionOption: AthenaClientTypes.EncryptionOption? = nil,
            kmsKey: Swift.String? = nil
        )
        {
            self.encryptionOption = encryptionOption
            self.kmsKey = kmsKey
        }
    }

}

extension AthenaClientTypes {
    public enum EncryptionOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cseKms
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionOption] {
            return [
                .cseKms,
                .sseKms,
                .sseS3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cseKms: return "CSE_KMS"
            case .sseKms: return "SSE_KMS"
            case .sseS3: return "SSE_S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionOption(rawValue: rawValue) ?? EncryptionOption.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.EngineVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveEngineVersion = "EffectiveEngineVersion"
        case selectedEngineVersion = "SelectedEngineVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveEngineVersion = effectiveEngineVersion {
            try encodeContainer.encode(effectiveEngineVersion, forKey: .effectiveEngineVersion)
        }
        if let selectedEngineVersion = selectedEngineVersion {
            try encodeContainer.encode(selectedEngineVersion, forKey: .selectedEngineVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectedEngineVersion)
        selectedEngineVersion = selectedEngineVersionDecoded
        let effectiveEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveEngineVersion)
        effectiveEngineVersion = effectiveEngineVersionDecoded
    }
}

extension AthenaClientTypes {
    /// The Athena engine version for running queries.
    public struct EngineVersion: Swift.Equatable {
        /// Read only. The engine version on which the query runs. If the user requests a valid engine version other than Auto, the effective engine version is the same as the engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a CreateWorkGroup or UpdateWorkGroup operation, the EffectiveEngineVersion field is ignored.
        public var effectiveEngineVersion: Swift.String?
        /// The engine version requested by the user. Possible values are determined by the output of ListEngineVersions, including Auto. The default is Auto.
        public var selectedEngineVersion: Swift.String?

        public init (
            effectiveEngineVersion: Swift.String? = nil,
            selectedEngineVersion: Swift.String? = nil
        )
        {
            self.effectiveEngineVersion = effectiveEngineVersion
            self.selectedEngineVersion = selectedEngineVersion
        }
    }

}

extension GetDataCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetDataCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDataCatalogInput: Swift.Equatable {
    /// The name of the data catalog to return.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetDataCatalogInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetDataCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetDataCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataCatalogOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDataCatalogOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataCatalog = output.dataCatalog
        } else {
            self.dataCatalog = nil
        }
    }
}

public struct GetDataCatalogOutputResponse: Swift.Equatable {
    /// The data catalog returned.
    public var dataCatalog: AthenaClientTypes.DataCatalog?

    public init (
        dataCatalog: AthenaClientTypes.DataCatalog? = nil
    )
    {
        self.dataCatalog = dataCatalog
    }
}

struct GetDataCatalogOutputResponseBody: Swift.Equatable {
    let dataCatalog: AthenaClientTypes.DataCatalog?
}

extension GetDataCatalogOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCatalog = "DataCatalog"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataCatalogDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalog.self, forKey: .dataCatalog)
        dataCatalog = dataCatalogDecoded
    }
}

extension GetDatabaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }
}

extension GetDatabaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDatabaseInput: Swift.Equatable {
    /// The name of the data catalog that contains the database to return.
    /// This member is required.
    public var catalogName: Swift.String?
    /// The name of the database to return.
    /// This member is required.
    public var databaseName: Swift.String?

    public init (
        catalogName: Swift.String? = nil,
        databaseName: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
    }
}

struct GetDatabaseInputBody: Swift.Equatable {
    let catalogName: Swift.String?
    let databaseName: Swift.String?
}

extension GetDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension GetDatabaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatabaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MetadataException" : self = .metadataException(try MetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDatabaseOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case metadataException(MetadataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatabaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct GetDatabaseOutputResponse: Swift.Equatable {
    /// The database returned.
    public var database: AthenaClientTypes.Database?

    public init (
        database: AthenaClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

struct GetDatabaseOutputResponseBody: Swift.Equatable {
    let database: AthenaClientTypes.Database?
}

extension GetDatabaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.Database.self, forKey: .database)
        database = databaseDecoded
    }
}

extension GetNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedQueryId = namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
    }
}

extension GetNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNamedQueryInput: Swift.Equatable {
    /// The unique ID of the query. Use [ListNamedQueries] to get query IDs.
    /// This member is required.
    public var namedQueryId: Swift.String?

    public init (
        namedQueryId: Swift.String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

struct GetNamedQueryInputBody: Swift.Equatable {
    let namedQueryId: Swift.String?
}

extension GetNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
    }
}

extension GetNamedQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNamedQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNamedQueryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNamedQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNamedQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namedQuery = output.namedQuery
        } else {
            self.namedQuery = nil
        }
    }
}

public struct GetNamedQueryOutputResponse: Swift.Equatable {
    /// Information about the query.
    public var namedQuery: AthenaClientTypes.NamedQuery?

    public init (
        namedQuery: AthenaClientTypes.NamedQuery? = nil
    )
    {
        self.namedQuery = namedQuery
    }
}

struct GetNamedQueryOutputResponseBody: Swift.Equatable {
    let namedQuery: AthenaClientTypes.NamedQuery?
}

extension GetNamedQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQuery = "NamedQuery"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NamedQuery.self, forKey: .namedQuery)
        namedQuery = namedQueryDecoded
    }
}

extension GetPreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension GetPreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPreparedStatementInput: Swift.Equatable {
    /// The name of the prepared statement to retrieve.
    /// This member is required.
    public var statementName: Swift.String?
    /// The workgroup to which the statement to be retrieved belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct GetPreparedStatementInputBody: Swift.Equatable {
    let statementName: Swift.String?
    let workGroup: Swift.String?
}

extension GetPreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension GetPreparedStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPreparedStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPreparedStatementOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPreparedStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPreparedStatementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.preparedStatement = output.preparedStatement
        } else {
            self.preparedStatement = nil
        }
    }
}

public struct GetPreparedStatementOutputResponse: Swift.Equatable {
    /// The name of the prepared statement that was retrieved.
    public var preparedStatement: AthenaClientTypes.PreparedStatement?

    public init (
        preparedStatement: AthenaClientTypes.PreparedStatement? = nil
    )
    {
        self.preparedStatement = preparedStatement
    }
}

struct GetPreparedStatementOutputResponseBody: Swift.Equatable {
    let preparedStatement: AthenaClientTypes.PreparedStatement?
}

extension GetPreparedStatementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preparedStatement = "PreparedStatement"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preparedStatementDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.PreparedStatement.self, forKey: .preparedStatement)
        preparedStatement = preparedStatementDecoded
    }
}

extension GetQueryExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionId = queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

extension GetQueryExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetQueryExecutionInput: Swift.Equatable {
    /// The unique ID of the query execution.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init (
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct GetQueryExecutionInputBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
}

extension GetQueryExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

extension GetQueryExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQueryExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetQueryExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQueryExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetQueryExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryExecution = output.queryExecution
        } else {
            self.queryExecution = nil
        }
    }
}

public struct GetQueryExecutionOutputResponse: Swift.Equatable {
    /// Information about the query execution.
    public var queryExecution: AthenaClientTypes.QueryExecution?

    public init (
        queryExecution: AthenaClientTypes.QueryExecution? = nil
    )
    {
        self.queryExecution = queryExecution
    }
}

struct GetQueryExecutionOutputResponseBody: Swift.Equatable {
    let queryExecution: AthenaClientTypes.QueryExecution?
}

extension GetQueryExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecution = "QueryExecution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecution.self, forKey: .queryExecution)
        queryExecution = queryExecutionDecoded
    }
}

extension GetQueryResultsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryExecutionId = queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

extension GetQueryResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetQueryResultsInput: Swift.Equatable {
    /// The maximum number of results (rows) to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The unique ID of the query execution.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryExecutionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryExecutionId = queryExecutionId
    }
}

struct GetQueryResultsInputBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetQueryResultsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetQueryResultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQueryResultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetQueryResultsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQueryResultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetQueryResultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resultSet = output.resultSet
            self.updateCount = output.updateCount
        } else {
            self.nextToken = nil
            self.resultSet = nil
            self.updateCount = nil
        }
    }
}

public struct GetQueryResultsOutputResponse: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The results of the query execution.
    public var resultSet: AthenaClientTypes.ResultSet?
    /// The number of rows inserted with a CREATE TABLE AS SELECT statement.
    public var updateCount: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        resultSet: AthenaClientTypes.ResultSet? = nil,
        updateCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.resultSet = resultSet
        self.updateCount = updateCount
    }
}

struct GetQueryResultsOutputResponseBody: Swift.Equatable {
    let updateCount: Swift.Int?
    let resultSet: AthenaClientTypes.ResultSet?
    let nextToken: Swift.String?
}

extension GetQueryResultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resultSet = "ResultSet"
        case updateCount = "UpdateCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .updateCount)
        updateCount = updateCountDecoded
        let resultSetDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultSet.self, forKey: .resultSet)
        resultSet = resultSetDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTableMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension GetTableMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTableMetadataInput: Swift.Equatable {
    /// The name of the data catalog that contains the database and table metadata to return.
    /// This member is required.
    public var catalogName: Swift.String?
    /// The name of the database that contains the table metadata to return.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table for which metadata is returned.
    /// This member is required.
    public var tableName: Swift.String?

    public init (
        catalogName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct GetTableMetadataInputBody: Swift.Equatable {
    let catalogName: Swift.String?
    let databaseName: Swift.String?
    let tableName: Swift.String?
}

extension GetTableMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension GetTableMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTableMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MetadataException" : self = .metadataException(try MetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTableMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case metadataException(MetadataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTableMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTableMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tableMetadata = output.tableMetadata
        } else {
            self.tableMetadata = nil
        }
    }
}

public struct GetTableMetadataOutputResponse: Swift.Equatable {
    /// An object that contains table metadata.
    public var tableMetadata: AthenaClientTypes.TableMetadata?

    public init (
        tableMetadata: AthenaClientTypes.TableMetadata? = nil
    )
    {
        self.tableMetadata = tableMetadata
    }
}

struct GetTableMetadataOutputResponseBody: Swift.Equatable {
    let tableMetadata: AthenaClientTypes.TableMetadata?
}

extension GetTableMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableMetadata = "TableMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableMetadataDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.TableMetadata.self, forKey: .tableMetadata)
        tableMetadata = tableMetadataDecoded
    }
}

extension GetWorkGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension GetWorkGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetWorkGroupInput: Swift.Equatable {
    /// The name of the workgroup.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        workGroup: Swift.String? = nil
    )
    {
        self.workGroup = workGroup
    }
}

struct GetWorkGroupInputBody: Swift.Equatable {
    let workGroup: Swift.String?
}

extension GetWorkGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension GetWorkGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWorkGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workGroup = output.workGroup
        } else {
            self.workGroup = nil
        }
    }
}

public struct GetWorkGroupOutputResponse: Swift.Equatable {
    /// Information about the workgroup.
    public var workGroup: AthenaClientTypes.WorkGroup?

    public init (
        workGroup: AthenaClientTypes.WorkGroup? = nil
    )
    {
        self.workGroup = workGroup
    }
}

struct GetWorkGroupOutputResponseBody: Swift.Equatable {
    let workGroup: AthenaClientTypes.WorkGroup?
}

extension GetWorkGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroup.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates a platform issue, which may be due to a transient condition or outage.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.athenaErrorCode = output.athenaErrorCode
            self.message = output.message
        } else {
            self.athenaErrorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that something is wrong with the input to the request. For example, a required parameter may be missing or out of range.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code returned when the query execution failed to process, or when the processing request for the named query failed.
    public var athenaErrorCode: Swift.String?
    public var message: Swift.String?

    public init (
        athenaErrorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.athenaErrorCode = athenaErrorCode
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let athenaErrorCode: Swift.String?
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case athenaErrorCode = "AthenaErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let athenaErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .athenaErrorCode)
        athenaErrorCode = athenaErrorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDataCatalogsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDataCatalogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDataCatalogsInput: Swift.Equatable {
    /// Specifies the maximum number of data catalogs to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataCatalogsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDataCatalogsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDataCatalogsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataCatalogsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataCatalogsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataCatalogsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataCatalogsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataCatalogsSummary = output.dataCatalogsSummary
            self.nextToken = output.nextToken
        } else {
            self.dataCatalogsSummary = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataCatalogsOutputResponse: Swift.Equatable {
    /// A summary list of data catalogs.
    public var dataCatalogsSummary: [AthenaClientTypes.DataCatalogSummary]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        dataCatalogsSummary: [AthenaClientTypes.DataCatalogSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataCatalogsSummary = dataCatalogsSummary
        self.nextToken = nextToken
    }
}

struct ListDataCatalogsOutputResponseBody: Swift.Equatable {
    let dataCatalogsSummary: [AthenaClientTypes.DataCatalogSummary]?
    let nextToken: Swift.String?
}

extension ListDataCatalogsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCatalogsSummary = "DataCatalogsSummary"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataCatalogsSummaryContainer = try containerValues.decodeIfPresent([AthenaClientTypes.DataCatalogSummary?].self, forKey: .dataCatalogsSummary)
        var dataCatalogsSummaryDecoded0:[AthenaClientTypes.DataCatalogSummary]? = nil
        if let dataCatalogsSummaryContainer = dataCatalogsSummaryContainer {
            dataCatalogsSummaryDecoded0 = [AthenaClientTypes.DataCatalogSummary]()
            for structure0 in dataCatalogsSummaryContainer {
                if let structure0 = structure0 {
                    dataCatalogsSummaryDecoded0?.append(structure0)
                }
            }
        }
        dataCatalogsSummary = dataCatalogsSummaryDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatabasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatabasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatabasesInput: Swift.Equatable {
    /// The name of the data catalog that contains the databases to return.
    /// This member is required.
    public var catalogName: Swift.String?
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        catalogName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatabasesInputBody: Swift.Equatable {
    let catalogName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatabasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatabasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MetadataException" : self = .metadataException(try MetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatabasesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case metadataException(MetadataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatabasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatabasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.databaseList = output.databaseList
            self.nextToken = output.nextToken
        } else {
            self.databaseList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatabasesOutputResponse: Swift.Equatable {
    /// A list of databases from a data catalog.
    public var databaseList: [AthenaClientTypes.Database]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        databaseList: [AthenaClientTypes.Database]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseList = databaseList
        self.nextToken = nextToken
    }
}

struct ListDatabasesOutputResponseBody: Swift.Equatable {
    let databaseList: [AthenaClientTypes.Database]?
    let nextToken: Swift.String?
}

extension ListDatabasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseList = "DatabaseList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseListContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Database?].self, forKey: .databaseList)
        var databaseListDecoded0:[AthenaClientTypes.Database]? = nil
        if let databaseListContainer = databaseListContainer {
            databaseListDecoded0 = [AthenaClientTypes.Database]()
            for structure0 in databaseListContainer {
                if let structure0 = structure0 {
                    databaseListDecoded0?.append(structure0)
                }
            }
        }
        databaseList = databaseListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEngineVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEngineVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEngineVersionsInput: Swift.Equatable {
    /// The maximum number of engine versions to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEngineVersionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEngineVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEngineVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEngineVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEngineVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEngineVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEngineVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engineVersions = output.engineVersions
            self.nextToken = output.nextToken
        } else {
            self.engineVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListEngineVersionsOutputResponse: Swift.Equatable {
    /// A list of engine versions that are available to choose from.
    public var engineVersions: [AthenaClientTypes.EngineVersion]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        engineVersions: [AthenaClientTypes.EngineVersion]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineVersions = engineVersions
        self.nextToken = nextToken
    }
}

struct ListEngineVersionsOutputResponseBody: Swift.Equatable {
    let engineVersions: [AthenaClientTypes.EngineVersion]?
    let nextToken: Swift.String?
}

extension ListEngineVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineVersions = "EngineVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.EngineVersion?].self, forKey: .engineVersions)
        var engineVersionsDecoded0:[AthenaClientTypes.EngineVersion]? = nil
        if let engineVersionsContainer = engineVersionsContainer {
            engineVersionsDecoded0 = [AthenaClientTypes.EngineVersion]()
            for structure0 in engineVersionsContainer {
                if let structure0 = structure0 {
                    engineVersionsDecoded0?.append(structure0)
                }
            }
        }
        engineVersions = engineVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNamedQueriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListNamedQueriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListNamedQueriesInput: Swift.Equatable {
    /// The maximum number of queries to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The name of the workgroup from which the named queries are being returned. If a workgroup is not specified, the saved queries for the primary workgroup are returned.
    public var workGroup: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListNamedQueriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let workGroup: Swift.String?
}

extension ListNamedQueriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension ListNamedQueriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNamedQueriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNamedQueriesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNamedQueriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNamedQueriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namedQueryIds = output.namedQueryIds
            self.nextToken = output.nextToken
        } else {
            self.namedQueryIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListNamedQueriesOutputResponse: Swift.Equatable {
    /// The list of unique query IDs.
    public var namedQueryIds: [Swift.String]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        namedQueryIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.namedQueryIds = namedQueryIds
        self.nextToken = nextToken
    }
}

struct ListNamedQueriesOutputResponseBody: Swift.Equatable {
    let namedQueryIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListNamedQueriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryIds = "NamedQueryIds"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .namedQueryIds)
        var namedQueryIdsDecoded0:[Swift.String]? = nil
        if let namedQueryIdsContainer = namedQueryIdsContainer {
            namedQueryIdsDecoded0 = [Swift.String]()
            for string0 in namedQueryIdsContainer {
                if let string0 = string0 {
                    namedQueryIdsDecoded0?.append(string0)
                }
            }
        }
        namedQueryIds = namedQueryIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPreparedStatementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListPreparedStatementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPreparedStatementsInput: Swift.Equatable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The workgroup to list the prepared statements for.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListPreparedStatementsInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPreparedStatementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPreparedStatementsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPreparedStatementsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPreparedStatementsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPreparedStatementsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPreparedStatementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.preparedStatements = output.preparedStatements
        } else {
            self.nextToken = nil
            self.preparedStatements = nil
        }
    }
}

public struct ListPreparedStatementsOutputResponse: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The list of prepared statements for the workgroup.
    public var preparedStatements: [AthenaClientTypes.PreparedStatementSummary]?

    public init (
        nextToken: Swift.String? = nil,
        preparedStatements: [AthenaClientTypes.PreparedStatementSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.preparedStatements = preparedStatements
    }
}

struct ListPreparedStatementsOutputResponseBody: Swift.Equatable {
    let preparedStatements: [AthenaClientTypes.PreparedStatementSummary]?
    let nextToken: Swift.String?
}

extension ListPreparedStatementsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case preparedStatements = "PreparedStatements"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preparedStatementsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.PreparedStatementSummary?].self, forKey: .preparedStatements)
        var preparedStatementsDecoded0:[AthenaClientTypes.PreparedStatementSummary]? = nil
        if let preparedStatementsContainer = preparedStatementsContainer {
            preparedStatementsDecoded0 = [AthenaClientTypes.PreparedStatementSummary]()
            for structure0 in preparedStatementsContainer {
                if let structure0 = structure0 {
                    preparedStatementsDecoded0?.append(structure0)
                }
            }
        }
        preparedStatements = preparedStatementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListQueryExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListQueryExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListQueryExecutionsInput: Swift.Equatable {
    /// The maximum number of query executions to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The name of the workgroup from which queries are being returned. If a workgroup is not specified, a list of available query execution IDs for the queries in the primary workgroup is returned.
    public var workGroup: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListQueryExecutionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let workGroup: Swift.String?
}

extension ListQueryExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension ListQueryExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQueryExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQueryExecutionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQueryExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListQueryExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queryExecutionIds = output.queryExecutionIds
        } else {
            self.nextToken = nil
            self.queryExecutionIds = nil
        }
    }
}

public struct ListQueryExecutionsOutputResponse: Swift.Equatable {
    /// A token to be used by the next request if this request is truncated.
    public var nextToken: Swift.String?
    /// The unique IDs of each query execution as an array of strings.
    public var queryExecutionIds: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        queryExecutionIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryExecutionIds = queryExecutionIds
    }
}

struct ListQueryExecutionsOutputResponseBody: Swift.Equatable {
    let queryExecutionIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListQueryExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case queryExecutionIds = "QueryExecutionIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queryExecutionIds)
        var queryExecutionIdsDecoded0:[Swift.String]? = nil
        if let queryExecutionIdsContainer = queryExecutionIdsContainer {
            queryExecutionIdsDecoded0 = [Swift.String]()
            for string0 in queryExecutionIdsContainer {
                if let string0 = string0 {
                    queryExecutionIdsDecoded0?.append(string0)
                }
            }
        }
        queryExecutionIds = queryExecutionIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTableMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTableMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTableMetadataInput: Swift.Equatable {
    /// The name of the data catalog for which table metadata should be returned.
    /// This member is required.
    public var catalogName: Swift.String?
    /// The name of the database for which table metadata should be returned.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A regex filter that pattern-matches table names. If no expression is supplied, metadata for all tables are listed.
    public var expression: Swift.String?
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        catalogName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        expression: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTableMetadataInputBody: Swift.Equatable {
    let catalogName: Swift.String?
    let databaseName: Swift.String?
    let expression: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTableMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTableMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTableMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MetadataException" : self = .metadataException(try MetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTableMetadataOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case metadataException(MetadataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTableMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTableMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tableMetadataList = output.tableMetadataList
        } else {
            self.nextToken = nil
            self.tableMetadataList = nil
        }
    }
}

public struct ListTableMetadataOutputResponse: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of table metadata.
    public var tableMetadataList: [AthenaClientTypes.TableMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        tableMetadataList: [AthenaClientTypes.TableMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableMetadataList = tableMetadataList
    }
}

struct ListTableMetadataOutputResponseBody: Swift.Equatable {
    let tableMetadataList: [AthenaClientTypes.TableMetadata]?
    let nextToken: Swift.String?
}

extension ListTableMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tableMetadataList = "TableMetadataList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableMetadataListContainer = try containerValues.decodeIfPresent([AthenaClientTypes.TableMetadata?].self, forKey: .tableMetadataList)
        var tableMetadataListDecoded0:[AthenaClientTypes.TableMetadata]? = nil
        if let tableMetadataListContainer = tableMetadataListContainer {
            tableMetadataListDecoded0 = [AthenaClientTypes.TableMetadata]()
            for structure0 in tableMetadataListContainer {
                if let structure0 = structure0 {
                    tableMetadataListDecoded0?.append(structure0)
                }
            }
        }
        tableMetadataList = tableMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of results to be returned per request that lists the tags for the resource.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no additional results for this request, where the request lists the tags for the resource with the specified ARN.
    public var nextToken: Swift.String?
    /// Lists the tags for the resource with the specified ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A token to be used by the next request if this request is truncated.
    public var nextToken: Swift.String?
    /// The list of tags associated with the specified resource.
    public var tags: [AthenaClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [AthenaClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorkGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWorkGroupsInput: Swift.Equatable {
    /// The maximum number of workgroups to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListWorkGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workGroups = output.workGroups
        } else {
            self.nextToken = nil
            self.workGroups = nil
        }
    }
}

public struct ListWorkGroupsOutputResponse: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of [WorkGroupSummary] objects that include the names, descriptions, creation times, and states for each workgroup.
    public var workGroups: [AthenaClientTypes.WorkGroupSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workGroups: [AthenaClientTypes.WorkGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workGroups = workGroups
    }
}

struct ListWorkGroupsOutputResponseBody: Swift.Equatable {
    let workGroups: [AthenaClientTypes.WorkGroupSummary]?
    let nextToken: Swift.String?
}

extension ListWorkGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workGroups = "WorkGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.WorkGroupSummary?].self, forKey: .workGroups)
        var workGroupsDecoded0:[AthenaClientTypes.WorkGroupSummary]? = nil
        if let workGroupsContainer = workGroupsContainer {
            workGroupsDecoded0 = [AthenaClientTypes.WorkGroupSummary]()
            for structure0 in workGroupsContainer {
                if let structure0 = structure0 {
                    workGroupsDecoded0?.append(structure0)
                }
            }
        }
        workGroups = workGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MetadataException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MetadataExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception that Athena received when it called a custom metastore. Occurs if the error is not caused by user input (InvalidRequestException) or from the Athena platform (InternalServerException). For example, if a user-created Lambda function is missing permissions, the Lambda 4XX exception is returned in a MetadataException.
public struct MetadataException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MetadataExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MetadataExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AthenaClientTypes.NamedQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case description = "Description"
        case name = "Name"
        case namedQueryId = "NamedQueryId"
        case queryString = "QueryString"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namedQueryId = namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension AthenaClientTypes {
    /// A query, where QueryString is the list of SQL query statements that comprise the query.
    public struct NamedQuery: Swift.Equatable {
        /// The database to which the query belongs.
        /// This member is required.
        public var database: Swift.String?
        /// The query description.
        public var description: Swift.String?
        /// The query name.
        /// This member is required.
        public var name: Swift.String?
        /// The unique identifier of the query.
        public var namedQueryId: Swift.String?
        /// The SQL query statements that comprise the query.
        /// This member is required.
        public var queryString: Swift.String?
        /// The name of the workgroup that contains the named query.
        public var workGroup: Swift.String?

        public init (
            database: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            namedQueryId: Swift.String? = nil,
            queryString: Swift.String? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.database = database
            self.description = description
            self.name = name
            self.namedQueryId = namedQueryId
            self.queryString = queryString
            self.workGroup = workGroup
        }
    }

}

extension AthenaClientTypes.PreparedStatement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroupName = "WorkGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let queryStatement = queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroupName = workGroupName {
            try encodeContainer.encode(workGroupName, forKey: .workGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let workGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroupName)
        workGroupName = workGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension AthenaClientTypes {
    /// A prepared SQL statement for use with Athena.
    public struct PreparedStatement: Swift.Equatable {
        /// The description of the prepared statement.
        public var description: Swift.String?
        /// The last modified time of the prepared statement.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The query string for the prepared statement.
        public var queryStatement: Swift.String?
        /// The name of the prepared statement.
        public var statementName: Swift.String?
        /// The name of the workgroup to which the prepared statement belongs.
        public var workGroupName: Swift.String?

        public init (
            description: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            queryStatement: Swift.String? = nil,
            statementName: Swift.String? = nil,
            workGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.queryStatement = queryStatement
            self.statementName = statementName
            self.workGroupName = workGroupName
        }
    }

}

extension AthenaClientTypes.PreparedStatementSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModifiedTime = "LastModifiedTime"
        case statementName = "StatementName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension AthenaClientTypes {
    /// The name and last modified time of the prepared statement.
    public struct PreparedStatementSummary: Swift.Equatable {
        /// The last modified time of the prepared statement.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the prepared statement.
        public var statementName: Swift.String?

        public init (
            lastModifiedTime: ClientRuntime.Date? = nil,
            statementName: Swift.String? = nil
        )
        {
            self.lastModifiedTime = lastModifiedTime
            self.statementName = statementName
        }
    }

}

extension AthenaClientTypes.QueryExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineVersion = "EngineVersion"
        case query = "Query"
        case queryExecutionContext = "QueryExecutionContext"
        case queryExecutionId = "QueryExecutionId"
        case resultConfiguration = "ResultConfiguration"
        case statementType = "StatementType"
        case statistics = "Statistics"
        case status = "Status"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let query = query {
            try encodeContainer.encode(query, forKey: .query)
        }
        if let queryExecutionContext = queryExecutionContext {
            try encodeContainer.encode(queryExecutionContext, forKey: .queryExecutionContext)
        }
        if let queryExecutionId = queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
        if let resultConfiguration = resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
        if let statementType = statementType {
            try encodeContainer.encode(statementType.rawValue, forKey: .statementType)
        }
        if let statistics = statistics {
            try encodeContainer.encode(statistics, forKey: .statistics)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
        let queryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .query)
        query = queryDecoded
        let statementTypeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.StatementType.self, forKey: .statementType)
        statementType = statementTypeDecoded
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let queryExecutionContextDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionContext.self, forKey: .queryExecutionContext)
        queryExecutionContext = queryExecutionContextDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension AthenaClientTypes {
    /// Information about a single instance of a query execution.
    public struct QueryExecution: Swift.Equatable {
        /// The engine version that executed the query.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// The SQL query statements which the query execution ran.
        public var query: Swift.String?
        /// The database in which the query execution occurred.
        public var queryExecutionContext: AthenaClientTypes.QueryExecutionContext?
        /// The unique identifier for each query execution.
        public var queryExecutionId: Swift.String?
        /// The location in Amazon S3 where query results were stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup.
        public var resultConfiguration: AthenaClientTypes.ResultConfiguration?
        /// The type of query statement that was run. DDL indicates DDL query statements. DML indicates DML (Data Manipulation Language) query statements, such as CREATE TABLE AS SELECT. UTILITY indicates query statements other than DDL and DML, such as SHOW CREATE TABLE, or DESCRIBE TABLE.
        public var statementType: AthenaClientTypes.StatementType?
        /// Query execution statistics, such as the amount of data scanned, the amount of time that the query took to process, and the type of statement that was run.
        public var statistics: AthenaClientTypes.QueryExecutionStatistics?
        /// The completion date, current state, submission time, and state change reason (if applicable) for the query execution.
        public var status: AthenaClientTypes.QueryExecutionStatus?
        /// The name of the workgroup in which the query ran.
        public var workGroup: Swift.String?

        public init (
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            query: Swift.String? = nil,
            queryExecutionContext: AthenaClientTypes.QueryExecutionContext? = nil,
            queryExecutionId: Swift.String? = nil,
            resultConfiguration: AthenaClientTypes.ResultConfiguration? = nil,
            statementType: AthenaClientTypes.StatementType? = nil,
            statistics: AthenaClientTypes.QueryExecutionStatistics? = nil,
            status: AthenaClientTypes.QueryExecutionStatus? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.engineVersion = engineVersion
            self.query = query
            self.queryExecutionContext = queryExecutionContext
            self.queryExecutionId = queryExecutionId
            self.resultConfiguration = resultConfiguration
            self.statementType = statementType
            self.statistics = statistics
            self.status = status
            self.workGroup = workGroup
        }
    }

}

extension AthenaClientTypes.QueryExecutionContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case database = "Database"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
    }
}

extension AthenaClientTypes {
    /// The database and data catalog context in which the query execution occurs.
    public struct QueryExecutionContext: Swift.Equatable {
        /// The name of the data catalog used in the query execution.
        public var catalog: Swift.String?
        /// The name of the database used in the query execution. The database must exist in the catalog.
        public var database: Swift.String?

        public init (
            catalog: Swift.String? = nil,
            database: Swift.String? = nil
        )
        {
            self.catalog = catalog
            self.database = database
        }
    }

}

extension AthenaClientTypes {
    public enum QueryExecutionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case queued
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryExecutionState] {
            return [
                .cancelled,
                .failed,
                .queued,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryExecutionState(rawValue: rawValue) ?? QueryExecutionState.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.QueryExecutionStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataManifestLocation = "DataManifestLocation"
        case dataScannedInBytes = "DataScannedInBytes"
        case engineExecutionTimeInMillis = "EngineExecutionTimeInMillis"
        case queryPlanningTimeInMillis = "QueryPlanningTimeInMillis"
        case queryQueueTimeInMillis = "QueryQueueTimeInMillis"
        case serviceProcessingTimeInMillis = "ServiceProcessingTimeInMillis"
        case totalExecutionTimeInMillis = "TotalExecutionTimeInMillis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataManifestLocation = dataManifestLocation {
            try encodeContainer.encode(dataManifestLocation, forKey: .dataManifestLocation)
        }
        if let dataScannedInBytes = dataScannedInBytes {
            try encodeContainer.encode(dataScannedInBytes, forKey: .dataScannedInBytes)
        }
        if let engineExecutionTimeInMillis = engineExecutionTimeInMillis {
            try encodeContainer.encode(engineExecutionTimeInMillis, forKey: .engineExecutionTimeInMillis)
        }
        if let queryPlanningTimeInMillis = queryPlanningTimeInMillis {
            try encodeContainer.encode(queryPlanningTimeInMillis, forKey: .queryPlanningTimeInMillis)
        }
        if let queryQueueTimeInMillis = queryQueueTimeInMillis {
            try encodeContainer.encode(queryQueueTimeInMillis, forKey: .queryQueueTimeInMillis)
        }
        if let serviceProcessingTimeInMillis = serviceProcessingTimeInMillis {
            try encodeContainer.encode(serviceProcessingTimeInMillis, forKey: .serviceProcessingTimeInMillis)
        }
        if let totalExecutionTimeInMillis = totalExecutionTimeInMillis {
            try encodeContainer.encode(totalExecutionTimeInMillis, forKey: .totalExecutionTimeInMillis)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineExecutionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .engineExecutionTimeInMillis)
        engineExecutionTimeInMillis = engineExecutionTimeInMillisDecoded
        let dataScannedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataScannedInBytes)
        dataScannedInBytes = dataScannedInBytesDecoded
        let dataManifestLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataManifestLocation)
        dataManifestLocation = dataManifestLocationDecoded
        let totalExecutionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalExecutionTimeInMillis)
        totalExecutionTimeInMillis = totalExecutionTimeInMillisDecoded
        let queryQueueTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryQueueTimeInMillis)
        queryQueueTimeInMillis = queryQueueTimeInMillisDecoded
        let queryPlanningTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryPlanningTimeInMillis)
        queryPlanningTimeInMillis = queryPlanningTimeInMillisDecoded
        let serviceProcessingTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceProcessingTimeInMillis)
        serviceProcessingTimeInMillis = serviceProcessingTimeInMillisDecoded
    }
}

extension AthenaClientTypes {
    /// The amount of data scanned during the query execution and the amount of time that it took to execute, and the type of statement that was run.
    public struct QueryExecutionStatistics: Swift.Equatable {
        /// The location and file name of a data manifest file. The manifest file is saved to the Athena query results location in Amazon S3. The manifest file tracks files that the query wrote to Amazon S3. If the query fails, the manifest file also tracks files that the query intended to write. The manifest is useful for identifying orphaned files resulting from a failed query. For more information, see [Working with Query Results, Output Files, and Query History](https://docs.aws.amazon.com/athena/latest/ug/querying.html) in the Amazon Athena User Guide.
        public var dataManifestLocation: Swift.String?
        /// The number of bytes in the data that was queried.
        public var dataScannedInBytes: Swift.Int?
        /// The number of milliseconds that the query took to execute.
        public var engineExecutionTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.
        public var queryPlanningTimeInMillis: Swift.Int?
        /// The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.
        public var queryQueueTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.
        public var serviceProcessingTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to run the query.
        public var totalExecutionTimeInMillis: Swift.Int?

        public init (
            dataManifestLocation: Swift.String? = nil,
            dataScannedInBytes: Swift.Int? = nil,
            engineExecutionTimeInMillis: Swift.Int? = nil,
            queryPlanningTimeInMillis: Swift.Int? = nil,
            queryQueueTimeInMillis: Swift.Int? = nil,
            serviceProcessingTimeInMillis: Swift.Int? = nil,
            totalExecutionTimeInMillis: Swift.Int? = nil
        )
        {
            self.dataManifestLocation = dataManifestLocation
            self.dataScannedInBytes = dataScannedInBytes
            self.engineExecutionTimeInMillis = engineExecutionTimeInMillis
            self.queryPlanningTimeInMillis = queryPlanningTimeInMillis
            self.queryQueueTimeInMillis = queryQueueTimeInMillis
            self.serviceProcessingTimeInMillis = serviceProcessingTimeInMillis
            self.totalExecutionTimeInMillis = totalExecutionTimeInMillis
        }
    }

}

extension AthenaClientTypes.QueryExecutionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionDateTime = "CompletionDateTime"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case submissionDateTime = "SubmissionDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionDateTime = completionDateTime {
            try encodeContainer.encode(completionDateTime.timeIntervalSince1970, forKey: .completionDateTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let submissionDateTime = submissionDateTime {
            try encodeContainer.encode(submissionDateTime.timeIntervalSince1970, forKey: .submissionDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionState.self, forKey: .state)
        state = stateDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let submissionDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submissionDateTime)
        submissionDateTime = submissionDateTimeDecoded
        let completionDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionDateTime)
        completionDateTime = completionDateTimeDecoded
    }
}

extension AthenaClientTypes {
    /// The completion date, current state, submission time, and state change reason (if applicable) for the query execution.
    public struct QueryExecutionStatus: Swift.Equatable {
        /// The date and time that the query completed.
        public var completionDateTime: ClientRuntime.Date?
        /// The state of query execution. QUEUED indicates that the query has been submitted to the service, and Athena will execute the query as soon as resources are available. RUNNING indicates that the query is in execution phase. SUCCEEDED indicates that the query completed without errors. FAILED indicates that the query experienced an error and did not complete processing. CANCELLED indicates that a user input interrupted query execution. Athena automatically retries your queries in cases of certain transient errors. As a result, you may see the query state transition from RUNNING or FAILED to QUEUED.
        public var state: AthenaClientTypes.QueryExecutionState?
        /// Further detail about the status of the query.
        public var stateChangeReason: Swift.String?
        /// The date and time that the query was submitted.
        public var submissionDateTime: ClientRuntime.Date?

        public init (
            completionDateTime: ClientRuntime.Date? = nil,
            state: AthenaClientTypes.QueryExecutionState? = nil,
            stateChangeReason: Swift.String? = nil,
            submissionDateTime: ClientRuntime.Date? = nil
        )
        {
            self.completionDateTime = completionDateTime
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.submissionDateTime = submissionDateTime
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource, such as a workgroup, was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension AthenaClientTypes.ResultConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfiguration = "EncryptionConfiguration"
        case outputLocation = "OutputLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// The location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the workgroup settings.
    public struct ResultConfiguration: Swift.Equatable {
        /// If query results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE-KMS or CSE-KMS) and key information. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the encryption configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration?
        /// The location in Amazon S3 where your query results are stored, such as s3://path/to/query/bucket/. To run the query, you must specify the query results location using one of the ways: either for individual queries using either this setting (client-side), or in the workgroup, using [WorkGroupConfiguration]. If none of them is set, Athena issues an error that no output location is provided. For more information, see [Query Results](https://docs.aws.amazon.com/athena/latest/ug/querying.html). If workgroup settings override client-side settings, then the query uses the settings specified for the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
        public var outputLocation: Swift.String?

        public init (
            encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration? = nil,
            outputLocation: Swift.String? = nil
        )
        {
            self.encryptionConfiguration = encryptionConfiguration
            self.outputLocation = outputLocation
        }
    }

}

extension AthenaClientTypes.ResultConfigurationUpdates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfiguration = "EncryptionConfiguration"
        case outputLocation = "OutputLocation"
        case removeEncryptionConfiguration = "RemoveEncryptionConfiguration"
        case removeOutputLocation = "RemoveOutputLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let removeEncryptionConfiguration = removeEncryptionConfiguration {
            try encodeContainer.encode(removeEncryptionConfiguration, forKey: .removeEncryptionConfiguration)
        }
        if let removeOutputLocation = removeOutputLocation {
            try encodeContainer.encode(removeOutputLocation, forKey: .removeOutputLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let removeOutputLocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeOutputLocation)
        removeOutputLocation = removeOutputLocationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let removeEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeEncryptionConfiguration)
        removeEncryptionConfiguration = removeEncryptionConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// The information about the updates in the query results, such as output location and encryption configuration for the query results.
    public struct ResultConfigurationUpdates: Swift.Equatable {
        /// The encryption configuration for the query results.
        public var encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration?
        /// The location in Amazon S3 where your query results are stored, such as s3://path/to/query/bucket/. For more information, see [Query Results](https://docs.aws.amazon.com/athena/latest/ug/querying.html) If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup. The "workgroup settings override" is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
        public var outputLocation: Swift.String?
        /// If set to "true", indicates that the previously-specified encryption configuration (also known as the client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the EncryptionConfiguration in ResultConfigurationUpdates (the client-side setting), the EncryptionConfiguration in the workgroup's ResultConfiguration will be updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeEncryptionConfiguration: Swift.Bool?
        /// If set to "true", indicates that the previously-specified query results location (also known as a client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the OutputLocation in ResultConfigurationUpdates (the client-side setting), the OutputLocation in the workgroup's ResultConfiguration will be updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeOutputLocation: Swift.Bool?

        public init (
            encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration? = nil,
            outputLocation: Swift.String? = nil,
            removeEncryptionConfiguration: Swift.Bool? = nil,
            removeOutputLocation: Swift.Bool? = nil
        )
        {
            self.encryptionConfiguration = encryptionConfiguration
            self.outputLocation = outputLocation
            self.removeEncryptionConfiguration = removeEncryptionConfiguration
            self.removeOutputLocation = removeOutputLocation
        }
    }

}

extension AthenaClientTypes.ResultSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resultSetMetadata = "ResultSetMetadata"
        case rows = "Rows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resultSetMetadata = resultSetMetadata {
            try encodeContainer.encode(resultSetMetadata, forKey: .resultSetMetadata)
        }
        if let rows = rows {
            var rowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rows)
            for rowlist0 in rows {
                try rowsContainer.encode(rowlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Row?].self, forKey: .rows)
        var rowsDecoded0:[AthenaClientTypes.Row]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [AthenaClientTypes.Row]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let resultSetMetadataDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultSetMetadata.self, forKey: .resultSetMetadata)
        resultSetMetadata = resultSetMetadataDecoded
    }
}

extension AthenaClientTypes {
    /// The metadata and rows that comprise a query result set. The metadata describes the column structure and data types. To return a ResultSet object, use [GetQueryResults].
    public struct ResultSet: Swift.Equatable {
        /// The metadata that describes the column structure and data types of a table of query results.
        public var resultSetMetadata: AthenaClientTypes.ResultSetMetadata?
        /// The rows in the table.
        public var rows: [AthenaClientTypes.Row]?

        public init (
            resultSetMetadata: AthenaClientTypes.ResultSetMetadata? = nil,
            rows: [AthenaClientTypes.Row]? = nil
        )
        {
            self.resultSetMetadata = resultSetMetadata
            self.rows = rows
        }
    }

}

extension AthenaClientTypes.ResultSetMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnInfo = "ColumnInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnInfo = columnInfo {
            var columnInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnInfo)
            for columninfolist0 in columnInfo {
                try columnInfoContainer.encode(columninfolist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnInfoContainer = try containerValues.decodeIfPresent([AthenaClientTypes.ColumnInfo?].self, forKey: .columnInfo)
        var columnInfoDecoded0:[AthenaClientTypes.ColumnInfo]? = nil
        if let columnInfoContainer = columnInfoContainer {
            columnInfoDecoded0 = [AthenaClientTypes.ColumnInfo]()
            for structure0 in columnInfoContainer {
                if let structure0 = structure0 {
                    columnInfoDecoded0?.append(structure0)
                }
            }
        }
        columnInfo = columnInfoDecoded0
    }
}

extension AthenaClientTypes {
    /// The metadata that describes the column structure and data types of a table of query results. To return a ResultSetMetadata object, use [GetQueryResults].
    public struct ResultSetMetadata: Swift.Equatable {
        /// Information about the columns returned in a query result metadata.
        public var columnInfo: [AthenaClientTypes.ColumnInfo]?

        public init (
            columnInfo: [AthenaClientTypes.ColumnInfo]? = nil
        )
        {
            self.columnInfo = columnInfo
        }
    }

}

extension AthenaClientTypes.Row: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .data)
            for datumlist0 in data {
                try dataContainer.encode(datumlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Datum?].self, forKey: .data)
        var dataDecoded0:[AthenaClientTypes.Datum]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [AthenaClientTypes.Datum]()
            for structure0 in dataContainer {
                if let structure0 = structure0 {
                    dataDecoded0?.append(structure0)
                }
            }
        }
        data = dataDecoded0
    }
}

extension AthenaClientTypes {
    /// The rows that comprise a query result table.
    public struct Row: Swift.Equatable {
        /// The data that populates a row in a query result table.
        public var data: [AthenaClientTypes.Datum]?

        public init (
            data: [AthenaClientTypes.Datum]? = nil
        )
        {
            self.data = data
        }
    }

}

extension StartQueryExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case queryExecutionContext = "QueryExecutionContext"
        case queryString = "QueryString"
        case resultConfiguration = "ResultConfiguration"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let queryExecutionContext = queryExecutionContext {
            try encodeContainer.encode(queryExecutionContext, forKey: .queryExecutionContext)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let resultConfiguration = resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension StartQueryExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartQueryExecutionInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the query is idempotent (executes only once). If another StartQueryExecution request is received, the same response is returned and another query is not created. If a parameter has changed, for example, the QueryString, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The database within which the query executes.
    public var queryExecutionContext: AthenaClientTypes.QueryExecutionContext?
    /// The SQL query statements to be executed.
    /// This member is required.
    public var queryString: Swift.String?
    /// Specifies information about where and how to save the results of the query execution. If the query runs in a workgroup, then workgroup's settings may override query settings. This affects the query results location. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public var resultConfiguration: AthenaClientTypes.ResultConfiguration?
    /// The name of the workgroup in which the query is being started.
    public var workGroup: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        queryExecutionContext: AthenaClientTypes.QueryExecutionContext? = nil,
        queryString: Swift.String? = nil,
        resultConfiguration: AthenaClientTypes.ResultConfiguration? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.queryExecutionContext = queryExecutionContext
        self.queryString = queryString
        self.resultConfiguration = resultConfiguration
        self.workGroup = workGroup
    }
}

struct StartQueryExecutionInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let clientRequestToken: Swift.String?
    let queryExecutionContext: AthenaClientTypes.QueryExecutionContext?
    let resultConfiguration: AthenaClientTypes.ResultConfiguration?
    let workGroup: Swift.String?
}

extension StartQueryExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case queryExecutionContext = "QueryExecutionContext"
        case queryString = "QueryString"
        case resultConfiguration = "ResultConfiguration"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let queryExecutionContextDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionContext.self, forKey: .queryExecutionContext)
        queryExecutionContext = queryExecutionContextDecoded
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension StartQueryExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartQueryExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartQueryExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartQueryExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartQueryExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryExecutionId = output.queryExecutionId
        } else {
            self.queryExecutionId = nil
        }
    }
}

public struct StartQueryExecutionOutputResponse: Swift.Equatable {
    /// The unique ID of the query that ran as a result of this request.
    public var queryExecutionId: Swift.String?

    public init (
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct StartQueryExecutionOutputResponseBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
}

extension StartQueryExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

extension AthenaClientTypes {
    public enum StatementType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ddl
        case dml
        case utility
        case sdkUnknown(Swift.String)

        public static var allCases: [StatementType] {
            return [
                .ddl,
                .dml,
                .utility,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ddl: return "DDL"
            case .dml: return "DML"
            case .utility: return "UTILITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatementType(rawValue: rawValue) ?? StatementType.sdkUnknown(rawValue)
        }
    }
}

extension StopQueryExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionId = queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

extension StopQueryExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopQueryExecutionInput: Swift.Equatable {
    /// The unique ID of the query execution to stop.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init (
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct StopQueryExecutionInputBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
}

extension StopQueryExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

extension StopQueryExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopQueryExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopQueryExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopQueryExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopQueryExecutionOutputResponse: Swift.Equatable {

}

extension AthenaClientTypes.TableMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
        case createTime = "CreateTime"
        case lastAccessTime = "LastAccessTime"
        case name = "Name"
        case parameters = "Parameters"
        case partitionKeys = "PartitionKeys"
        case tableType = "TableType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columnlist0 in columns {
                try columnsContainer.encode(columnlist0)
            }
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let lastAccessTime = lastAccessTime {
            try encodeContainer.encode(lastAccessTime.timeIntervalSince1970, forKey: .lastAccessTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let partitionKeys = partitionKeys {
            var partitionKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionKeys)
            for columnlist0 in partitionKeys {
                try partitionKeysContainer.encode(columnlist0)
            }
        }
        if let tableType = tableType {
            try encodeContainer.encode(tableType, forKey: .tableType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let lastAccessTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAccessTime)
        lastAccessTime = lastAccessTimeDecoded
        let tableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableType)
        tableType = tableTypeDecoded
        let columnsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Column?].self, forKey: .columns)
        var columnsDecoded0:[AthenaClientTypes.Column]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [AthenaClientTypes.Column]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let partitionKeysContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Column?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[AthenaClientTypes.Column]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [AthenaClientTypes.Column]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains metadata for a table.
    public struct TableMetadata: Swift.Equatable {
        /// A list of the columns in the table.
        public var columns: [AthenaClientTypes.Column]?
        /// The time that the table was created.
        public var createTime: ClientRuntime.Date?
        /// The last time the table was accessed.
        public var lastAccessTime: ClientRuntime.Date?
        /// The name of the table.
        /// This member is required.
        public var name: Swift.String?
        /// A set of custom key/value pairs for table properties.
        public var parameters: [Swift.String:Swift.String]?
        /// A list of the partition keys in the table.
        public var partitionKeys: [AthenaClientTypes.Column]?
        /// The type of table. In Athena, only EXTERNAL_TABLE is supported.
        public var tableType: Swift.String?

        public init (
            columns: [AthenaClientTypes.Column]? = nil,
            createTime: ClientRuntime.Date? = nil,
            lastAccessTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            partitionKeys: [AthenaClientTypes.Column]? = nil,
            tableType: Swift.String? = nil
        )
        {
            self.columns = columns
            self.createTime = createTime
            self.lastAccessTime = lastAccessTime
            self.name = name
            self.parameters = parameters
            self.partitionKeys = partitionKeys
            self.tableType = tableType
        }
    }

}

extension AthenaClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AthenaClientTypes {
    /// A label that you assign to a resource. In Athena, a resource can be a workgroup or data catalog. Each tag consists of a key and an optional value, both of which you define. For example, you can use tags to categorize Athena workgroups or data catalogs by purpose, owner, or environment. Use a consistent set of tag keys to make it easier to search and filter workgroups or data catalogs in your account. For best practices, see [Tagging Best Practices](https://aws.amazon.com/answers/account-management/aws-tagging-strategies/). Tag keys can be from 1 to 128 UTF-8 Unicode characters, and tag values can be from 0 to 256 UTF-8 Unicode characters. Tags can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys and values are case-sensitive. Tag keys must be unique per resource. If you specify more than one tag, separate them by commas.
    public struct Tag: Swift.Equatable {
        /// A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys are case-sensitive and must be unique per resource.
        public var key: Swift.String?
        /// A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag values are case-sensitive.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Specifies the ARN of the Athena resource (workgroup or data catalog) to which tags are to be added.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A collection of one or more tags, separated by commas, to be added to an Athena workgroup or data catalog resource.
    /// This member is required.
    public var tags: [AthenaClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [AthenaClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension AthenaClientTypes {
    /// The reason for the query throttling, for example, when it exceeds the concurrent query limit.
    public enum ThrottleReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concurrentQueryLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ThrottleReason] {
            return [
                .concurrentQueryLimitExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concurrentQueryLimitExceeded: return "CONCURRENT_QUERY_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThrottleReason(rawValue: rawValue) ?? ThrottleReason.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the request was throttled.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The reason for the query throttling, for example, when it exceeds the concurrent query limit.
    public var reason: AthenaClientTypes.ThrottleReason?

    public init (
        message: Swift.String? = nil,
        reason: AthenaClientTypes.ThrottleReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AthenaClientTypes.ThrottleReason?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ThrottleReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension AthenaClientTypes.UnprocessedNamedQueryId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case namedQueryId = "NamedQueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let namedQueryId = namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AthenaClientTypes {
    /// Information about a named query ID that could not be processed.
    public struct UnprocessedNamedQueryId: Swift.Equatable {
        /// The error code returned when the processing request for the named query failed, if applicable.
        public var errorCode: Swift.String?
        /// The error message returned when the processing request for the named query failed, if applicable.
        public var errorMessage: Swift.String?
        /// The unique identifier of the named query.
        public var namedQueryId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            namedQueryId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.namedQueryId = namedQueryId
        }
    }

}

extension AthenaClientTypes.UnprocessedQueryExecutionId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let queryExecutionId = queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AthenaClientTypes {
    /// Describes a query execution that failed to process.
    public struct UnprocessedQueryExecutionId: Swift.Equatable {
        /// The error code returned when the query execution failed to process, if applicable.
        public var errorCode: Swift.String?
        /// The error message returned when the query execution failed to process, if applicable.
        public var errorMessage: Swift.String?
        /// The unique identifier of the query execution.
        public var queryExecutionId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            queryExecutionId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.queryExecutionId = queryExecutionId
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Specifies the ARN of the resource from which tags are to be removed.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A comma-separated list of one or more tag keys whose tags are to be removed from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateDataCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateDataCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDataCatalogInput: Swift.Equatable {
    /// New or modified text that describes the data catalog.
    public var description: Swift.String?
    /// The name of the data catalog to update. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 128 alphanumeric, underscore, at sign, or hyphen characters.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the Lambda function or functions to use for updating the data catalog. This is a mapping whose values depend on the catalog type.
    ///
    /// * For the HIVE data catalog type, use the following syntax. The metadata-function parameter is required. The sdk-version parameter is optional and defaults to the currently supported version. metadata-function=lambda_arn, sdk-version=version_number
    ///
    /// * For the LAMBDA data catalog type, use one of the following sets of required parameters, but not both.
    ///
    /// * If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required. metadata-function=lambda_arn, record-function=lambda_arn
    ///
    /// * If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function. function=lambda_arn
    public var parameters: [Swift.String:Swift.String]?
    /// Specifies the type of data catalog to update. Specify LAMBDA for a federated catalog, HIVE for an external hive metastore, or GLUE for an Glue Data Catalog.
    /// This member is required.
    public var type: AthenaClientTypes.DataCatalogType?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        type: AthenaClientTypes.DataCatalogType? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
        self.type = type
    }
}

struct UpdateDataCatalogInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: AthenaClientTypes.DataCatalogType?
    let description: Swift.String?
    let parameters: [Swift.String:Swift.String]?
}

extension UpdateDataCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalogType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension UpdateDataCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataCatalogOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDataCatalogOutputResponse: Swift.Equatable {

}

extension UpdatePreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let queryStatement = queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension UpdatePreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePreparedStatementInput: Swift.Equatable {
    /// The description of the prepared statement.
    public var description: Swift.String?
    /// The query string for the prepared statement.
    /// This member is required.
    public var queryStatement: Swift.String?
    /// The name of the prepared statement.
    /// This member is required.
    public var statementName: Swift.String?
    /// The workgroup for the prepared statement.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        description: Swift.String? = nil,
        queryStatement: Swift.String? = nil,
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.description = description
        self.queryStatement = queryStatement
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct UpdatePreparedStatementInputBody: Swift.Equatable {
    let statementName: Swift.String?
    let workGroup: Swift.String?
    let queryStatement: Swift.String?
    let description: Swift.String?
}

extension UpdatePreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdatePreparedStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePreparedStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePreparedStatementOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePreparedStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePreparedStatementOutputResponse: Swift.Equatable {

}

extension UpdateWorkGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationUpdates = "ConfigurationUpdates"
        case description = "Description"
        case state = "State"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationUpdates = configurationUpdates {
            try encodeContainer.encode(configurationUpdates, forKey: .configurationUpdates)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension UpdateWorkGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWorkGroupInput: Swift.Equatable {
    /// The workgroup configuration that will be updated for the given workgroup.
    public var configurationUpdates: AthenaClientTypes.WorkGroupConfigurationUpdates?
    /// The workgroup description.
    public var description: Swift.String?
    /// The workgroup state that will be updated for the given workgroup.
    public var state: AthenaClientTypes.WorkGroupState?
    /// The specified workgroup that will be updated.
    /// This member is required.
    public var workGroup: Swift.String?

    public init (
        configurationUpdates: AthenaClientTypes.WorkGroupConfigurationUpdates? = nil,
        description: Swift.String? = nil,
        state: AthenaClientTypes.WorkGroupState? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.configurationUpdates = configurationUpdates
        self.description = description
        self.state = state
        self.workGroup = workGroup
    }
}

struct UpdateWorkGroupInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let description: Swift.String?
    let configurationUpdates: AthenaClientTypes.WorkGroupConfigurationUpdates?
    let state: AthenaClientTypes.WorkGroupState?
}

extension UpdateWorkGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationUpdates = "ConfigurationUpdates"
        case description = "Description"
        case state = "State"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let configurationUpdatesDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupConfigurationUpdates.self, forKey: .configurationUpdates)
        configurationUpdates = configurationUpdatesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupState.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdateWorkGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWorkGroupOutputResponse: Swift.Equatable {

}

extension AthenaClientTypes.WorkGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case creationTime = "CreationTime"
        case description = "Description"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupState.self, forKey: .state)
        state = stateDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AthenaClientTypes {
    /// A workgroup, which contains a name, description, creation time, state, and other configuration, listed under [WorkGroup$Configuration]. Each workgroup enables you to isolate queries for you or your group of users from other queries in the same account, to configure the query results location and the encryption configuration (known as workgroup settings), to enable sending query metrics to Amazon CloudWatch, and to establish per-query data usage control limits for all queries in a workgroup. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public struct WorkGroup: Swift.Equatable {
        /// The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption configuration, if any, used for query results; whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup settings override client-side settings; and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
        public var configuration: AthenaClientTypes.WorkGroupConfiguration?
        /// The date and time the workgroup was created.
        public var creationTime: ClientRuntime.Date?
        /// The workgroup description.
        public var description: Swift.String?
        /// The workgroup name.
        /// This member is required.
        public var name: Swift.String?
        /// The state of the workgroup: ENABLED or DISABLED.
        public var state: AthenaClientTypes.WorkGroupState?

        public init (
            configuration: AthenaClientTypes.WorkGroupConfiguration? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            state: AthenaClientTypes.WorkGroupState? = nil
        )
        {
            self.configuration = configuration
            self.creationTime = creationTime
            self.description = description
            self.name = name
            self.state = state
        }
    }

}

extension AthenaClientTypes.WorkGroupConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesScannedCutoffPerQuery = "BytesScannedCutoffPerQuery"
        case enforceWorkGroupConfiguration = "EnforceWorkGroupConfiguration"
        case engineVersion = "EngineVersion"
        case publishCloudWatchMetricsEnabled = "PublishCloudWatchMetricsEnabled"
        case requesterPaysEnabled = "RequesterPaysEnabled"
        case resultConfiguration = "ResultConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery {
            try encodeContainer.encode(bytesScannedCutoffPerQuery, forKey: .bytesScannedCutoffPerQuery)
        }
        if let enforceWorkGroupConfiguration = enforceWorkGroupConfiguration {
            try encodeContainer.encode(enforceWorkGroupConfiguration, forKey: .enforceWorkGroupConfiguration)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled {
            try encodeContainer.encode(publishCloudWatchMetricsEnabled, forKey: .publishCloudWatchMetricsEnabled)
        }
        if let requesterPaysEnabled = requesterPaysEnabled {
            try encodeContainer.encode(requesterPaysEnabled, forKey: .requesterPaysEnabled)
        }
        if let resultConfiguration = resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let enforceWorkGroupConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforceWorkGroupConfiguration)
        enforceWorkGroupConfiguration = enforceWorkGroupConfigurationDecoded
        let publishCloudWatchMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishCloudWatchMetricsEnabled)
        publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabledDecoded
        let bytesScannedCutoffPerQueryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesScannedCutoffPerQuery)
        bytesScannedCutoffPerQuery = bytesScannedCutoffPerQueryDecoded
        let requesterPaysEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPaysEnabled)
        requesterPaysEnabled = requesterPaysEnabledDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension AthenaClientTypes {
    /// The configuration of the workgroup, which includes the location in Amazon S3 where query results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup and whether workgroup settings override query settings, and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public struct WorkGroupConfiguration: Swift.Equatable {
        /// The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.
        public var bytesScannedCutoffPerQuery: Swift.Int?
        /// If set to "true", the settings for the workgroup override client-side settings. If set to "false", client-side settings are used. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var enforceWorkGroupConfiguration: Swift.Bool?
        /// The engine version that all queries running on the workgroup use. Queries on the AmazonAthenaPreviewFunctionality workgroup run on the preview engine regardless of this setting.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.
        public var publishCloudWatchMetricsEnabled: Swift.Bool?
        /// If set to true, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to false, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false. For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
        public var requesterPaysEnabled: Swift.Bool?
        /// The configuration for the workgroup, which includes the location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. To run the query, you must specify the query results location using one of the ways: either in the workgroup using this setting, or for individual queries (client-side), using [ResultConfiguration$OutputLocation]. If none of them is set, Athena issues an error that no output location is provided. For more information, see [Query Results](https://docs.aws.amazon.com/athena/latest/ug/querying.html).
        public var resultConfiguration: AthenaClientTypes.ResultConfiguration?

        public init (
            bytesScannedCutoffPerQuery: Swift.Int? = nil,
            enforceWorkGroupConfiguration: Swift.Bool? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            publishCloudWatchMetricsEnabled: Swift.Bool? = nil,
            requesterPaysEnabled: Swift.Bool? = nil,
            resultConfiguration: AthenaClientTypes.ResultConfiguration? = nil
        )
        {
            self.bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery
            self.enforceWorkGroupConfiguration = enforceWorkGroupConfiguration
            self.engineVersion = engineVersion
            self.publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled
            self.requesterPaysEnabled = requesterPaysEnabled
            self.resultConfiguration = resultConfiguration
        }
    }

}

extension AthenaClientTypes.WorkGroupConfigurationUpdates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesScannedCutoffPerQuery = "BytesScannedCutoffPerQuery"
        case enforceWorkGroupConfiguration = "EnforceWorkGroupConfiguration"
        case engineVersion = "EngineVersion"
        case publishCloudWatchMetricsEnabled = "PublishCloudWatchMetricsEnabled"
        case removeBytesScannedCutoffPerQuery = "RemoveBytesScannedCutoffPerQuery"
        case requesterPaysEnabled = "RequesterPaysEnabled"
        case resultConfigurationUpdates = "ResultConfigurationUpdates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery {
            try encodeContainer.encode(bytesScannedCutoffPerQuery, forKey: .bytesScannedCutoffPerQuery)
        }
        if let enforceWorkGroupConfiguration = enforceWorkGroupConfiguration {
            try encodeContainer.encode(enforceWorkGroupConfiguration, forKey: .enforceWorkGroupConfiguration)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled {
            try encodeContainer.encode(publishCloudWatchMetricsEnabled, forKey: .publishCloudWatchMetricsEnabled)
        }
        if let removeBytesScannedCutoffPerQuery = removeBytesScannedCutoffPerQuery {
            try encodeContainer.encode(removeBytesScannedCutoffPerQuery, forKey: .removeBytesScannedCutoffPerQuery)
        }
        if let requesterPaysEnabled = requesterPaysEnabled {
            try encodeContainer.encode(requesterPaysEnabled, forKey: .requesterPaysEnabled)
        }
        if let resultConfigurationUpdates = resultConfigurationUpdates {
            try encodeContainer.encode(resultConfigurationUpdates, forKey: .resultConfigurationUpdates)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceWorkGroupConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforceWorkGroupConfiguration)
        enforceWorkGroupConfiguration = enforceWorkGroupConfigurationDecoded
        let resultConfigurationUpdatesDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultConfigurationUpdates.self, forKey: .resultConfigurationUpdates)
        resultConfigurationUpdates = resultConfigurationUpdatesDecoded
        let publishCloudWatchMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishCloudWatchMetricsEnabled)
        publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabledDecoded
        let bytesScannedCutoffPerQueryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesScannedCutoffPerQuery)
        bytesScannedCutoffPerQuery = bytesScannedCutoffPerQueryDecoded
        let removeBytesScannedCutoffPerQueryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeBytesScannedCutoffPerQuery)
        removeBytesScannedCutoffPerQuery = removeBytesScannedCutoffPerQueryDecoded
        let requesterPaysEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPaysEnabled)
        requesterPaysEnabled = requesterPaysEnabledDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension AthenaClientTypes {
    /// The configuration information that will be updated for this workgroup, which includes the location in Amazon S3 where query results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, whether the workgroup settings override the client-side settings, and the data usage limit for the amount of bytes scanned per query, if it is specified.
    public struct WorkGroupConfigurationUpdates: Swift.Equatable {
        /// The upper limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.
        public var bytesScannedCutoffPerQuery: Swift.Int?
        /// If set to "true", the settings for the workgroup override client-side settings. If set to "false" client-side settings are used. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var enforceWorkGroupConfiguration: Swift.Bool?
        /// The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the AmazonAthenaPreviewFunctionality workgroup run on the preview engine regardless of this setting.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// Indicates whether this workgroup enables publishing metrics to Amazon CloudWatch.
        public var publishCloudWatchMetricsEnabled: Swift.Bool?
        /// Indicates that the data usage control limit per query is removed. [WorkGroupConfiguration$BytesScannedCutoffPerQuery]
        public var removeBytesScannedCutoffPerQuery: Swift.Bool?
        /// If set to true, allows members assigned to a workgroup to specify Amazon S3 Requester Pays buckets in queries. If set to false, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false. For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
        public var requesterPaysEnabled: Swift.Bool?
        /// The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.
        public var resultConfigurationUpdates: AthenaClientTypes.ResultConfigurationUpdates?

        public init (
            bytesScannedCutoffPerQuery: Swift.Int? = nil,
            enforceWorkGroupConfiguration: Swift.Bool? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            publishCloudWatchMetricsEnabled: Swift.Bool? = nil,
            removeBytesScannedCutoffPerQuery: Swift.Bool? = nil,
            requesterPaysEnabled: Swift.Bool? = nil,
            resultConfigurationUpdates: AthenaClientTypes.ResultConfigurationUpdates? = nil
        )
        {
            self.bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery
            self.enforceWorkGroupConfiguration = enforceWorkGroupConfiguration
            self.engineVersion = engineVersion
            self.publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled
            self.removeBytesScannedCutoffPerQuery = removeBytesScannedCutoffPerQuery
            self.requesterPaysEnabled = requesterPaysEnabled
            self.resultConfigurationUpdates = resultConfigurationUpdates
        }
    }

}

extension AthenaClientTypes {
    public enum WorkGroupState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkGroupState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkGroupState(rawValue: rawValue) ?? WorkGroupState.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.WorkGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case description = "Description"
        case engineVersion = "EngineVersion"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension AthenaClientTypes {
    /// The summary information for the workgroup, which includes its name, state, description, and the date and time it was created.
    public struct WorkGroupSummary: Swift.Equatable {
        /// The workgroup creation date and time.
        public var creationTime: ClientRuntime.Date?
        /// The workgroup description.
        public var description: Swift.String?
        /// The engine version setting for all queries on the workgroup. Queries on the AmazonAthenaPreviewFunctionality workgroup run on the preview engine regardless of this setting.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// The name of the workgroup.
        public var name: Swift.String?
        /// The state of the workgroup.
        public var state: AthenaClientTypes.WorkGroupState?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            name: Swift.String? = nil,
            state: AthenaClientTypes.WorkGroupState? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.engineVersion = engineVersion
            self.name = name
            self.state = state
        }
    }

}
