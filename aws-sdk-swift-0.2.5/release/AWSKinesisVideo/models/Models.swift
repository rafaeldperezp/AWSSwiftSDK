// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension KinesisVideoClientTypes {
    public enum APIName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case getClip
        case getDashStreamingSessionUrl
        case getHlsStreamingSessionUrl
        case getMedia
        case getMediaForFragmentList
        case listFragments
        case putMedia
        case sdkUnknown(Swift.String)

        public static var allCases: [APIName] {
            return [
                .getClip,
                .getDashStreamingSessionUrl,
                .getHlsStreamingSessionUrl,
                .getMedia,
                .getMediaForFragmentList,
                .listFragments,
                .putMedia,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .getClip: return "GET_CLIP"
            case .getDashStreamingSessionUrl: return "GET_DASH_STREAMING_SESSION_URL"
            case .getHlsStreamingSessionUrl: return "GET_HLS_STREAMING_SESSION_URL"
            case .getMedia: return "GET_MEDIA"
            case .getMediaForFragmentList: return "GET_MEDIA_FOR_FRAGMENT_LIST"
            case .listFragments: return "LIST_FRAGMENTS"
            case .putMedia: return "PUT_MEDIA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = APIName(rawValue: rawValue) ?? APIName.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have required permissions to perform this operation.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountChannelLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccountChannelLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum limit of active signaling channels for this AWS account in this region.
public struct AccountChannelLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountChannelLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountChannelLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountStreamLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccountStreamLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of streams created for the account is too high.
public struct AccountStreamLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountStreamLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountStreamLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.ChannelInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
        case channelStatus = "ChannelStatus"
        case channelType = "ChannelType"
        case creationTime = "CreationTime"
        case singleMasterConfiguration = "SingleMasterConfiguration"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelStatus = channelStatus {
            try encodeContainer.encode(channelStatus.rawValue, forKey: .channelStatus)
        }
        if let channelType = channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let singleMasterConfiguration = singleMasterConfiguration {
            try encodeContainer.encode(singleMasterConfiguration, forKey: .singleMasterConfiguration)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let channelTypeDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let channelStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.Status.self, forKey: .channelStatus)
        channelStatus = channelStatusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let singleMasterConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SingleMasterConfiguration.self, forKey: .singleMasterConfiguration)
        singleMasterConfiguration = singleMasterConfigurationDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A structure that encapsulates a signaling channel's metadata and properties.
    public struct ChannelInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the signaling channel.
        public var channelARN: Swift.String?
        /// The name of the signaling channel.
        public var channelName: Swift.String?
        /// Current status of the signaling channel.
        public var channelStatus: KinesisVideoClientTypes.Status?
        /// The type of the signaling channel.
        public var channelType: KinesisVideoClientTypes.ChannelType?
        /// The time at which the signaling channel was created.
        public var creationTime: ClientRuntime.Date?
        /// A structure that contains the configuration for the SINGLE_MASTER channel type.
        public var singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
        /// The current version of the signaling channel.
        public var version: Swift.String?

        public init (
            channelARN: Swift.String? = nil,
            channelName: Swift.String? = nil,
            channelStatus: KinesisVideoClientTypes.Status? = nil,
            channelType: KinesisVideoClientTypes.ChannelType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration? = nil,
            version: Swift.String? = nil
        )
        {
            self.channelARN = channelARN
            self.channelName = channelName
            self.channelStatus = channelStatus
            self.channelType = channelType
            self.creationTime = creationTime
            self.singleMasterConfiguration = singleMasterConfiguration
            self.version = version
        }
    }

}

extension KinesisVideoClientTypes.ChannelNameCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case comparisonValue = "ComparisonValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let comparisonValue = comparisonValue {
            try encodeContainer.encode(comparisonValue, forKey: .comparisonValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let comparisonValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comparisonValue)
        comparisonValue = comparisonValueDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An optional input parameter for the ListSignalingChannels API. When this parameter is specified while invoking ListSignalingChannels, the API returns only the channels that satisfy a condition specified in ChannelNameCondition.
    public struct ChannelNameCondition: Swift.Equatable {
        /// A comparison operator. Currently, you can only specify the BEGINS_WITH operator, which finds signaling channels whose names begin with a given prefix.
        public var comparisonOperator: KinesisVideoClientTypes.ComparisonOperator?
        /// A value to compare.
        public var comparisonValue: Swift.String?

        public init (
            comparisonOperator: KinesisVideoClientTypes.ComparisonOperator? = nil,
            comparisonValue: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.comparisonValue = comparisonValue
        }
    }

}

extension KinesisVideoClientTypes {
    public enum ChannelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case https
        case wss
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelProtocol] {
            return [
                .https,
                .wss,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .https: return "HTTPS"
            case .wss: return "WSS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelProtocol(rawValue: rawValue) ?? ChannelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum ChannelRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case master
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelRole] {
            return [
                .master,
                .viewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .master: return "MASTER"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelRole(rawValue: rawValue) ?? ChannelRole.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum ChannelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case singleMaster
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .singleMaster,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .singleMaster: return "SINGLE_MASTER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
        }
    }
}

extension ClientLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClientLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Kinesis Video Streams has throttled the request because you have exceeded the limit of allowed client calls. Try making the call later.
public struct ClientLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClientLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClientLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .beginsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension CreateSignalingChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName = "ChannelName"
        case channelType = "ChannelType"
        case singleMasterConfiguration = "SingleMasterConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelType = channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let singleMasterConfiguration = singleMasterConfiguration {
            try encodeContainer.encode(singleMasterConfiguration, forKey: .singleMasterConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagoncreatelist0 in tags {
                try tagsContainer.encode(tagoncreatelist0)
            }
        }
    }
}

extension CreateSignalingChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createSignalingChannel"
    }
}

public struct CreateSignalingChannelInput: Swift.Equatable {
    /// A name for the signaling channel that you are creating. It must be unique for each AWS account and AWS Region.
    /// This member is required.
    public var channelName: Swift.String?
    /// A type of the signaling channel that you are creating. Currently, SINGLE_MASTER is the only supported channel type.
    public var channelType: KinesisVideoClientTypes.ChannelType?
    /// A structure containing the configuration for the SINGLE_MASTER channel type.
    public var singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
    /// A set of tags (key-value pairs) that you want to associate with this channel.
    public var tags: [KinesisVideoClientTypes.Tag]?

    public init (
        channelName: Swift.String? = nil,
        channelType: KinesisVideoClientTypes.ChannelType? = nil,
        singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration? = nil,
        tags: [KinesisVideoClientTypes.Tag]? = nil
    )
    {
        self.channelName = channelName
        self.channelType = channelType
        self.singleMasterConfiguration = singleMasterConfiguration
        self.tags = tags
    }
}

struct CreateSignalingChannelInputBody: Swift.Equatable {
    let channelName: Swift.String?
    let channelType: KinesisVideoClientTypes.ChannelType?
    let singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
    let tags: [KinesisVideoClientTypes.Tag]?
}

extension CreateSignalingChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName = "ChannelName"
        case channelType = "ChannelType"
        case singleMasterConfiguration = "SingleMasterConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelTypeDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let singleMasterConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SingleMasterConfiguration.self, forKey: .singleMasterConfiguration)
        singleMasterConfiguration = singleMasterConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisVideoClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisVideoClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSignalingChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSignalingChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountChannelLimitExceededException" : self = .accountChannelLimitExceededException(try AccountChannelLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsPerResourceExceededLimitException" : self = .tagsPerResourceExceededLimitException(try TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSignalingChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountChannelLimitExceededException(AccountChannelLimitExceededException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case tagsPerResourceExceededLimitException(TagsPerResourceExceededLimitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSignalingChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSignalingChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelARN = output.channelARN
        } else {
            self.channelARN = nil
        }
    }
}

public struct CreateSignalingChannelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created channel.
    public var channelARN: Swift.String?

    public init (
        channelARN: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
    }
}

struct CreateSignalingChannelOutputResponseBody: Swift.Equatable {
    let channelARN: Swift.String?
}

extension CreateSignalingChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
    }
}

extension CreateStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case deviceName = "DeviceName"
        case kmsKeyId = "KmsKeyId"
        case mediaType = "MediaType"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRetentionInHours = dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let mediaType = mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, resourcetags0) in tags {
                try tagsContainer.encode(resourcetags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createStream"
    }
}

public struct CreateStreamInput: Swift.Equatable {
    /// The number of hours that you want to retain the data in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. The default value is 0, indicating that the stream does not persist data. When the DataRetentionInHours value is 0, consumers can still consume the fragments that remain in the service host buffer, which has a retention time limit of 5 minutes and a retention memory limit of 200 MB. Fragments are removed from the buffer when either limit is reached.
    public var dataRetentionInHours: Swift.Int?
    /// The name of the device that is writing to the stream. In the current implementation, Kinesis Video Streams does not use this name.
    public var deviceName: Swift.String?
    /// The ID of the AWS Key Management Service (AWS KMS) key that you want Kinesis Video Streams to use to encrypt stream data. If no key ID is specified, the default, Kinesis Video-managed key (aws/kinesisvideo) is used. For more information, see [DescribeKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters).
    public var kmsKeyId: Swift.String?
    /// The media type of the stream. Consumers of the stream can use this information when processing the stream. For more information about media types, see [Media Types](http://www.iana.org/assignments/media-types/media-types.xhtml). If you choose to specify the MediaType, see [Naming Requirements](https://tools.ietf.org/html/rfc6838#section-4.2) for guidelines. Example valid values include "video/h264" and "video/h264,audio/aac". This parameter is optional; the default value is null (or empty in JSON).
    public var mediaType: Swift.String?
    /// A name for the stream that you are creating. The stream name is an identifier for the stream, and must be unique for each account and region.
    /// This member is required.
    public var streamName: Swift.String?
    /// A list of tags to associate with the specified stream. Each tag is a key-value pair (the value is optional).
    public var tags: [Swift.String:Swift.String]?

    public init (
        dataRetentionInHours: Swift.Int? = nil,
        deviceName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        mediaType: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataRetentionInHours = dataRetentionInHours
        self.deviceName = deviceName
        self.kmsKeyId = kmsKeyId
        self.mediaType = mediaType
        self.streamName = streamName
        self.tags = tags
    }
}

struct CreateStreamInputBody: Swift.Equatable {
    let deviceName: Swift.String?
    let streamName: Swift.String?
    let mediaType: Swift.String?
    let kmsKeyId: Swift.String?
    let dataRetentionInHours: Swift.Int?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case deviceName = "DeviceName"
        case kmsKeyId = "KmsKeyId"
        case mediaType = "MediaType"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountStreamLimitExceededException" : self = .accountStreamLimitExceededException(try AccountStreamLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceStreamLimitExceededException" : self = .deviceStreamLimitExceededException(try DeviceStreamLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeviceException" : self = .invalidDeviceException(try InvalidDeviceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsPerResourceExceededLimitException" : self = .tagsPerResourceExceededLimitException(try TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamOutputError: Swift.Error, Swift.Equatable {
    case accountStreamLimitExceededException(AccountStreamLimitExceededException)
    case clientLimitExceededException(ClientLimitExceededException)
    case deviceStreamLimitExceededException(DeviceStreamLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidDeviceException(InvalidDeviceException)
    case resourceInUseException(ResourceInUseException)
    case tagsPerResourceExceededLimitException(TagsPerResourceExceededLimitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamARN = output.streamARN
        } else {
            self.streamARN = nil
        }
    }
}

public struct CreateStreamOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?

    public init (
        streamARN: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
    }
}

struct CreateStreamOutputResponseBody: Swift.Equatable {
    let streamARN: Swift.String?
}

extension CreateStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DeleteSignalingChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }
}

extension DeleteSignalingChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteSignalingChannel"
    }
}

public struct DeleteSignalingChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signaling channel that you want to delete.
    /// This member is required.
    public var channelARN: Swift.String?
    /// The current version of the signaling channel that you want to delete. You can obtain the current version by invoking the DescribeSignalingChannel or ListSignalingChannels API operations.
    public var currentVersion: Swift.String?

    public init (
        channelARN: Swift.String? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
        self.currentVersion = currentVersion
    }
}

struct DeleteSignalingChannelInputBody: Swift.Equatable {
    let channelARN: Swift.String?
    let currentVersion: Swift.String?
}

extension DeleteSignalingChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension DeleteSignalingChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSignalingChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSignalingChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSignalingChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSignalingChannelOutputResponse: Swift.Equatable {

}

extension DeleteStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }
}

extension DeleteStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteStream"
    }
}

public struct DeleteStreamInput: Swift.Equatable {
    /// Optional: The version of the stream that you want to delete. Specify the version as a safeguard to ensure that your are deleting the correct stream. To get the stream version, use the DescribeStream API. If not specified, only the CreationTime is checked before deleting the stream.
    public var currentVersion: Swift.String?
    /// The Amazon Resource Name (ARN) of the stream that you want to delete.
    /// This member is required.
    public var streamARN: Swift.String?

    public init (
        currentVersion: Swift.String? = nil,
        streamARN: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.streamARN = streamARN
    }
}

struct DeleteStreamInputBody: Swift.Equatable {
    let streamARN: Swift.String?
    let currentVersion: Swift.String?
}

extension DeleteStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case streamARN = "StreamARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension DeleteStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamOutputResponse: Swift.Equatable {

}

extension DescribeSignalingChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
    }
}

extension DescribeSignalingChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeSignalingChannel"
    }
}

public struct DescribeSignalingChannelInput: Swift.Equatable {
    /// The ARN of the signaling channel that you want to describe.
    public var channelARN: Swift.String?
    /// The name of the signaling channel that you want to describe.
    public var channelName: Swift.String?

    public init (
        channelARN: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
        self.channelName = channelName
    }
}

struct DescribeSignalingChannelInputBody: Swift.Equatable {
    let channelName: Swift.String?
    let channelARN: Swift.String?
}

extension DescribeSignalingChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
    }
}

extension DescribeSignalingChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSignalingChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSignalingChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSignalingChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSignalingChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelInfo = output.channelInfo
        } else {
            self.channelInfo = nil
        }
    }
}

public struct DescribeSignalingChannelOutputResponse: Swift.Equatable {
    /// A structure that encapsulates the specified signaling channel's metadata and properties.
    public var channelInfo: KinesisVideoClientTypes.ChannelInfo?

    public init (
        channelInfo: KinesisVideoClientTypes.ChannelInfo? = nil
    )
    {
        self.channelInfo = channelInfo
    }
}

struct DescribeSignalingChannelOutputResponseBody: Swift.Equatable {
    let channelInfo: KinesisVideoClientTypes.ChannelInfo?
}

extension DescribeSignalingChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelInfo = "ChannelInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelInfoDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelInfo.self, forKey: .channelInfo)
        channelInfo = channelInfoDecoded
    }
}

extension DescribeStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension DescribeStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeStream"
    }
}

public struct DescribeStreamInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream.
    public var streamName: Swift.String?

    public init (
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DescribeStreamInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
}

extension DescribeStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DescribeStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStreamOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamInfo = output.streamInfo
        } else {
            self.streamInfo = nil
        }
    }
}

public struct DescribeStreamOutputResponse: Swift.Equatable {
    /// An object that describes the stream.
    public var streamInfo: KinesisVideoClientTypes.StreamInfo?

    public init (
        streamInfo: KinesisVideoClientTypes.StreamInfo? = nil
    )
    {
        self.streamInfo = streamInfo
    }
}

struct DescribeStreamOutputResponseBody: Swift.Equatable {
    let streamInfo: KinesisVideoClientTypes.StreamInfo?
}

extension DescribeStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamInfo = "StreamInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamInfoDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.StreamInfo.self, forKey: .streamInfo)
        streamInfo = streamInfoDecoded
    }
}

extension DeviceStreamLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeviceStreamLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Not implemented.
public struct DeviceStreamLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeviceStreamLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeviceStreamLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetDataEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aPIName = "APIName"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aPIName = aPIName {
            try encodeContainer.encode(aPIName.rawValue, forKey: .aPIName)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension GetDataEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getDataEndpoint"
    }
}

public struct GetDataEndpointInput: Swift.Equatable {
    /// The name of the API action for which to get an endpoint.
    /// This member is required.
    public var aPIName: KinesisVideoClientTypes.APIName?
    /// The Amazon Resource Name (ARN) of the stream that you want to get the endpoint for. You must specify either this parameter or a StreamName in the request.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to get the endpoint for. You must specify either this parameter or a StreamARN in the request.
    public var streamName: Swift.String?

    public init (
        aPIName: KinesisVideoClientTypes.APIName? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.aPIName = aPIName
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct GetDataEndpointInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let aPIName: KinesisVideoClientTypes.APIName?
}

extension GetDataEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aPIName = "APIName"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let aPINameDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.APIName.self, forKey: .aPIName)
        aPIName = aPINameDecoded
    }
}

extension GetDataEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataEndpointOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDataEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataEndpoint = output.dataEndpoint
        } else {
            self.dataEndpoint = nil
        }
    }
}

public struct GetDataEndpointOutputResponse: Swift.Equatable {
    /// The endpoint value. To read data from the stream or to write data to it, specify this endpoint in your application.
    public var dataEndpoint: Swift.String?

    public init (
        dataEndpoint: Swift.String? = nil
    )
    {
        self.dataEndpoint = dataEndpoint
    }
}

struct GetDataEndpointOutputResponseBody: Swift.Equatable {
    let dataEndpoint: Swift.String?
}

extension GetDataEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataEndpoint = "DataEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataEndpoint)
        dataEndpoint = dataEndpointDecoded
    }
}

extension GetSignalingChannelEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case singleMasterChannelEndpointConfiguration = "SingleMasterChannelEndpointConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let singleMasterChannelEndpointConfiguration = singleMasterChannelEndpointConfiguration {
            try encodeContainer.encode(singleMasterChannelEndpointConfiguration, forKey: .singleMasterChannelEndpointConfiguration)
        }
    }
}

extension GetSignalingChannelEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getSignalingChannelEndpoint"
    }
}

public struct GetSignalingChannelEndpointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signalling channel for which you want to get an endpoint.
    /// This member is required.
    public var channelARN: Swift.String?
    /// A structure containing the endpoint configuration for the SINGLE_MASTER channel type.
    public var singleMasterChannelEndpointConfiguration: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration?

    public init (
        channelARN: Swift.String? = nil,
        singleMasterChannelEndpointConfiguration: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.singleMasterChannelEndpointConfiguration = singleMasterChannelEndpointConfiguration
    }
}

struct GetSignalingChannelEndpointInputBody: Swift.Equatable {
    let channelARN: Swift.String?
    let singleMasterChannelEndpointConfiguration: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration?
}

extension GetSignalingChannelEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case singleMasterChannelEndpointConfiguration = "SingleMasterChannelEndpointConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let singleMasterChannelEndpointConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration.self, forKey: .singleMasterChannelEndpointConfiguration)
        singleMasterChannelEndpointConfiguration = singleMasterChannelEndpointConfigurationDecoded
    }
}

extension GetSignalingChannelEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSignalingChannelEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSignalingChannelEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSignalingChannelEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSignalingChannelEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceEndpointList = output.resourceEndpointList
        } else {
            self.resourceEndpointList = nil
        }
    }
}

public struct GetSignalingChannelEndpointOutputResponse: Swift.Equatable {
    /// A list of endpoints for the specified signaling channel.
    public var resourceEndpointList: [KinesisVideoClientTypes.ResourceEndpointListItem]?

    public init (
        resourceEndpointList: [KinesisVideoClientTypes.ResourceEndpointListItem]? = nil
    )
    {
        self.resourceEndpointList = resourceEndpointList
    }
}

struct GetSignalingChannelEndpointOutputResponseBody: Swift.Equatable {
    let resourceEndpointList: [KinesisVideoClientTypes.ResourceEndpointListItem]?
}

extension GetSignalingChannelEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceEndpointList = "ResourceEndpointList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceEndpointListContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.ResourceEndpointListItem?].self, forKey: .resourceEndpointList)
        var resourceEndpointListDecoded0:[KinesisVideoClientTypes.ResourceEndpointListItem]? = nil
        if let resourceEndpointListContainer = resourceEndpointListContainer {
            resourceEndpointListDecoded0 = [KinesisVideoClientTypes.ResourceEndpointListItem]()
            for structure0 in resourceEndpointListContainer {
                if let structure0 = structure0 {
                    resourceEndpointListDecoded0?.append(structure0)
                }
            }
        }
        resourceEndpointList = resourceEndpointListDecoded0
    }
}

extension InvalidArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value for this input parameter is invalid.
public struct InvalidArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeviceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDeviceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Not implemented.
public struct InvalidDeviceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeviceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDeviceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceFormatException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResourceFormatExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The format of the StreamARN is invalid.
public struct InvalidResourceFormatException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceFormatExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceFormatExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListSignalingChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelNameCondition = "ChannelNameCondition"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelNameCondition = channelNameCondition {
            try encodeContainer.encode(channelNameCondition, forKey: .channelNameCondition)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSignalingChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listSignalingChannels"
    }
}

public struct ListSignalingChannelsInput: Swift.Equatable {
    /// Optional: Returns only the channels that satisfy a specific condition.
    public var channelNameCondition: KinesisVideoClientTypes.ChannelNameCondition?
    /// The maximum number of channels to return in the response. The default is 500.
    public var maxResults: Swift.Int?
    /// If you specify this parameter, when the result of a ListSignalingChannels operation is truncated, the call returns the NextToken in the response. To get another batch of channels, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        channelNameCondition: KinesisVideoClientTypes.ChannelNameCondition? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelNameCondition = channelNameCondition
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSignalingChannelsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let channelNameCondition: KinesisVideoClientTypes.ChannelNameCondition?
}

extension ListSignalingChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelNameCondition = "ChannelNameCondition"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelNameConditionDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelNameCondition.self, forKey: .channelNameCondition)
        channelNameCondition = channelNameConditionDecoded
    }
}

extension ListSignalingChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSignalingChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSignalingChannelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSignalingChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSignalingChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelInfoList = output.channelInfoList
            self.nextToken = output.nextToken
        } else {
            self.channelInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListSignalingChannelsOutputResponse: Swift.Equatable {
    /// An array of ChannelInfo objects.
    public var channelInfoList: [KinesisVideoClientTypes.ChannelInfo]?
    /// If the response is truncated, the call returns this element with a token. To get the next batch of streams, use this token in your next request.
    public var nextToken: Swift.String?

    public init (
        channelInfoList: [KinesisVideoClientTypes.ChannelInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelInfoList = channelInfoList
        self.nextToken = nextToken
    }
}

struct ListSignalingChannelsOutputResponseBody: Swift.Equatable {
    let channelInfoList: [KinesisVideoClientTypes.ChannelInfo]?
    let nextToken: Swift.String?
}

extension ListSignalingChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelInfoList = "ChannelInfoList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelInfoListContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.ChannelInfo?].self, forKey: .channelInfoList)
        var channelInfoListDecoded0:[KinesisVideoClientTypes.ChannelInfo]? = nil
        if let channelInfoListContainer = channelInfoListContainer {
            channelInfoListDecoded0 = [KinesisVideoClientTypes.ChannelInfo]()
            for structure0 in channelInfoListContainer {
                if let structure0 = structure0 {
                    channelInfoListDecoded0?.append(structure0)
                }
            }
        }
        channelInfoList = channelInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStreamsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamNameCondition = "StreamNameCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamNameCondition = streamNameCondition {
            try encodeContainer.encode(streamNameCondition, forKey: .streamNameCondition)
        }
    }
}

extension ListStreamsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listStreams"
    }
}

public struct ListStreamsInput: Swift.Equatable {
    /// The maximum number of streams to return in the response. The default is 10,000.
    public var maxResults: Swift.Int?
    /// If you specify this parameter, when the result of a ListStreams operation is truncated, the call returns the NextToken in the response. To get another batch of streams, provide this token in your next request.
    public var nextToken: Swift.String?
    /// Optional: Returns only streams that satisfy a specific condition. Currently, you can specify only the prefix of a stream name as a condition.
    public var streamNameCondition: KinesisVideoClientTypes.StreamNameCondition?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        streamNameCondition: KinesisVideoClientTypes.StreamNameCondition? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.streamNameCondition = streamNameCondition
    }
}

struct ListStreamsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let streamNameCondition: KinesisVideoClientTypes.StreamNameCondition?
}

extension ListStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamNameCondition = "StreamNameCondition"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamNameConditionDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.StreamNameCondition.self, forKey: .streamNameCondition)
        streamNameCondition = streamNameConditionDecoded
    }
}

extension ListStreamsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamsOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamInfoList = output.streamInfoList
        } else {
            self.nextToken = nil
            self.streamInfoList = nil
        }
    }
}

public struct ListStreamsOutputResponse: Swift.Equatable {
    /// If the response is truncated, the call returns this element with a token. To get the next batch of streams, use this token in your next request.
    public var nextToken: Swift.String?
    /// An array of StreamInfo objects.
    public var streamInfoList: [KinesisVideoClientTypes.StreamInfo]?

    public init (
        nextToken: Swift.String? = nil,
        streamInfoList: [KinesisVideoClientTypes.StreamInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamInfoList = streamInfoList
    }
}

struct ListStreamsOutputResponseBody: Swift.Equatable {
    let streamInfoList: [KinesisVideoClientTypes.StreamInfo]?
    let nextToken: Swift.String?
}

extension ListStreamsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case streamInfoList = "StreamInfoList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamInfoListContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.StreamInfo?].self, forKey: .streamInfoList)
        var streamInfoListDecoded0:[KinesisVideoClientTypes.StreamInfo]? = nil
        if let streamInfoListContainer = streamInfoListContainer {
            streamInfoListDecoded0 = [KinesisVideoClientTypes.StreamInfo]()
            for structure0 in streamInfoListContainer {
                if let structure0 = structure0 {
                    streamInfoListDecoded0?.append(structure0)
                }
            }
        }
        streamInfoList = streamInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListTagsForResource"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// If you specify this parameter and the result of a ListTagsForResource call is truncated, the response includes a token that you can use in the next request to fetch the next batch of tags.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the signaling channel for which you want to list tags.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// If you specify this parameter and the result of a ListTagsForResource call is truncated, the response includes a token that you can use in the next request to fetch the next set of tags.
    public var nextToken: Swift.String?
    /// A map of tag keys and values associated with the specified signaling channel.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTagsForStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension ListTagsForStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listTagsForStream"
    }
}

public struct ListTagsForStreamInput: Swift.Equatable {
    /// If you specify this parameter and the result of a ListTagsForStream call is truncated, the response includes a token that you can use in the next request to fetch the next batch of tags.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the stream that you want to list tags for.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to list tags for.
    public var streamName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct ListTagsForStreamInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let streamARN: Swift.String?
    let streamName: Swift.String?
}

extension ListTagsForStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension ListTagsForStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceFormatException" : self = .invalidResourceFormatException(try InvalidResourceFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForStreamOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidResourceFormatException(InvalidResourceFormatException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForStreamOutputResponse: Swift.Equatable {
    /// If you specify this parameter and the result of a ListTags call is truncated, the response includes a token that you can use in the next request to fetch the next set of tags.
    public var nextToken: Swift.String?
    /// A map of tag keys and values associated with the specified stream.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForStreamOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NotAuthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The caller is not authorized to perform this operation.
public struct NotAuthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.ResourceEndpointListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `protocol` = "Protocol"
        case resourceEndpoint = "ResourceEndpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let resourceEndpoint = resourceEndpoint {
            try encodeContainer.encode(resourceEndpoint, forKey: .resourceEndpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let resourceEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceEndpoint)
        resourceEndpoint = resourceEndpointDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An object that describes the endpoint of the signaling channel returned by the GetSignalingChannelEndpoint API.
    public struct ResourceEndpointListItem: Swift.Equatable {
        /// The protocol of the signaling channel returned by the GetSignalingChannelEndpoint API.
        public var `protocol`: KinesisVideoClientTypes.ChannelProtocol?
        /// The endpoint of the signaling channel returned by the GetSignalingChannelEndpoint API.
        public var resourceEndpoint: Swift.String?

        public init (
            `protocol`: KinesisVideoClientTypes.ChannelProtocol? = nil,
            resourceEndpoint: Swift.String? = nil
        )
        {
            self.`protocol` = `protocol`
            self.resourceEndpoint = resourceEndpoint
        }
    }

}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The signaling channel is currently not available for this operation.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Kinesis Video Streams can't find the stream that you specified.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protocols = "Protocols"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for listofprotocols0 in protocols {
                try protocolsContainer.encode(listofprotocols0.rawValue)
            }
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.ChannelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[KinesisVideoClientTypes.ChannelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [KinesisVideoClientTypes.ChannelProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let roleDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An object that contains the endpoint configuration for the SINGLE_MASTER channel type.
    public struct SingleMasterChannelEndpointConfiguration: Swift.Equatable {
        /// This property is used to determine the nature of communication over this SINGLE_MASTER signaling channel. If WSS is specified, this API returns a websocket endpoint. If HTTPS is specified, this API returns an HTTPS endpoint.
        public var protocols: [KinesisVideoClientTypes.ChannelProtocol]?
        /// This property is used to determine messaging permissions in this SINGLE_MASTER signaling channel. If MASTER is specified, this API returns an endpoint that a client can use to receive offers from and send answers to any of the viewers on this signaling channel. If VIEWER is specified, this API returns an endpoint that a client can use only to send offers to another MASTER client on this signaling channel.
        public var role: KinesisVideoClientTypes.ChannelRole?

        public init (
            protocols: [KinesisVideoClientTypes.ChannelProtocol]? = nil,
            role: KinesisVideoClientTypes.ChannelRole? = nil
        )
        {
            self.protocols = protocols
            self.role = role
        }
    }

}

extension KinesisVideoClientTypes.SingleMasterConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageTtlSeconds = "MessageTtlSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageTtlSeconds = messageTtlSeconds {
            try encodeContainer.encode(messageTtlSeconds, forKey: .messageTtlSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTtlSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .messageTtlSeconds)
        messageTtlSeconds = messageTtlSecondsDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A structure that contains the configuration for the SINGLE_MASTER channel type.
    public struct SingleMasterConfiguration: Swift.Equatable {
        /// The period of time a signaling channel retains underlivered messages before they are discarded.
        public var messageTtlSeconds: Swift.Int?

        public init (
            messageTtlSeconds: Swift.Int? = nil
        )
        {
            self.messageTtlSeconds = messageTtlSeconds
        }
    }

}

extension KinesisVideoClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .creating,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes.StreamInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataRetentionInHours = "DataRetentionInHours"
        case deviceName = "DeviceName"
        case kmsKeyId = "KmsKeyId"
        case mediaType = "MediaType"
        case status = "Status"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let dataRetentionInHours = dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let mediaType = mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An object describing a Kinesis video stream.
    public struct StreamInfo: Swift.Equatable {
        /// A time stamp that indicates when the stream was created.
        public var creationTime: ClientRuntime.Date?
        /// How long the stream retains data, in hours.
        public var dataRetentionInHours: Swift.Int?
        /// The name of the device that is associated with the stream.
        public var deviceName: Swift.String?
        /// The ID of the AWS Key Management Service (AWS KMS) key that Kinesis Video Streams uses to encrypt data on the stream.
        public var kmsKeyId: Swift.String?
        /// The MediaType of the stream.
        public var mediaType: Swift.String?
        /// The status of the stream.
        public var status: KinesisVideoClientTypes.Status?
        /// The Amazon Resource Name (ARN) of the stream.
        public var streamARN: Swift.String?
        /// The name of the stream.
        public var streamName: Swift.String?
        /// The version of the stream.
        public var version: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            dataRetentionInHours: Swift.Int? = nil,
            deviceName: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            mediaType: Swift.String? = nil,
            status: KinesisVideoClientTypes.Status? = nil,
            streamARN: Swift.String? = nil,
            streamName: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.dataRetentionInHours = dataRetentionInHours
            self.deviceName = deviceName
            self.kmsKeyId = kmsKeyId
            self.mediaType = mediaType
            self.status = status
            self.streamARN = streamARN
            self.streamName = streamName
            self.version = version
        }
    }

}

extension KinesisVideoClientTypes.StreamNameCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case comparisonValue = "ComparisonValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let comparisonValue = comparisonValue {
            try encodeContainer.encode(comparisonValue, forKey: .comparisonValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let comparisonValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comparisonValue)
        comparisonValue = comparisonValueDecoded
    }
}

extension KinesisVideoClientTypes {
    /// Specifies the condition that streams must satisfy to be returned when you list streams (see the ListStreams API). A condition has a comparison operation and a value. Currently, you can specify only the BEGINS_WITH operator, which finds streams whose names start with a given prefix.
    public struct StreamNameCondition: Swift.Equatable {
        /// A comparison operator. Currently, you can specify only the BEGINS_WITH operator, which finds streams whose names start with a given prefix.
        public var comparisonOperator: KinesisVideoClientTypes.ComparisonOperator?
        /// A value to compare.
        public var comparisonValue: Swift.String?

        public init (
            comparisonOperator: KinesisVideoClientTypes.ComparisonOperator? = nil,
            comparisonValue: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.comparisonValue = comparisonValue
        }
    }

}

extension KinesisVideoClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A key and value pair that is associated with the specified signaling channel.
    public struct Tag: Swift.Equatable {
        /// The key of the tag that is associated with the specified signaling channel.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag that is associated with the specified signaling channel.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TagResource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signaling channel to which you want to add tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags to associate with the specified signaling channel. Each tag is a key-value pair.
    /// This member is required.
    public var tags: [KinesisVideoClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [KinesisVideoClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [KinesisVideoClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisVideoClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisVideoClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsPerResourceExceededLimitException" : self = .tagsPerResourceExceededLimitException(try TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagsPerResourceExceededLimitException(TagsPerResourceExceededLimitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension TagStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, resourcetags0) in tags {
                try tagsContainer.encode(resourcetags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tagStream"
    }
}

public struct TagStreamInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to add the tag or tags to.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to add the tag or tags to.
    public var streamName: Swift.String?
    /// A list of tags to associate with the specified stream. Each tag is a key-value pair (the value is optional).
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
        self.tags = tags
    }
}

struct TagStreamInputBody: Swift.Equatable {
    let streamARN: Swift.String?
    let streamName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceFormatException" : self = .invalidResourceFormatException(try InvalidResourceFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsPerResourceExceededLimitException" : self = .tagsPerResourceExceededLimitException(try TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagStreamOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidResourceFormatException(InvalidResourceFormatException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagsPerResourceExceededLimitException(TagsPerResourceExceededLimitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagStreamOutputResponse: Swift.Equatable {

}

extension TagsPerResourceExceededLimitException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagsPerResourceExceededLimitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the limit of tags that you can associate with the resource. Kinesis video streams support up to 50 tags.
public struct TagsPerResourceExceededLimitException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagsPerResourceExceededLimitExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagsPerResourceExceededLimitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkeylist0 in tagKeyList {
                try tagKeyListContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UntagResource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signaling channel from which you want to remove tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of the keys of the tags that you want to remove.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeyList = tagKeyList
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeyList: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UntagStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkeylist0 in tagKeyList {
                try tagKeyListContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/untagStream"
    }
}

public struct UntagStreamInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the stream that you want to remove tags from.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to remove tags from.
    public var streamName: Swift.String?
    /// A list of the keys of the tags that you want to remove.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init (
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
        self.tagKeyList = tagKeyList
    }
}

struct UntagStreamInputBody: Swift.Equatable {
    let streamARN: Swift.String?
    let streamName: Swift.String?
    let tagKeyList: [Swift.String]?
}

extension UntagStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceFormatException" : self = .invalidResourceFormatException(try InvalidResourceFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagStreamOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidResourceFormatException(InvalidResourceFormatException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagStreamOutputResponse: Swift.Equatable {

}

extension UpdateDataRetentionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case dataRetentionChangeInHours = "DataRetentionChangeInHours"
        case operation = "Operation"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let dataRetentionChangeInHours = dataRetentionChangeInHours {
            try encodeContainer.encode(dataRetentionChangeInHours, forKey: .dataRetentionChangeInHours)
        }
        if let operation = operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension UpdateDataRetentionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateDataRetention"
    }
}

public struct UpdateDataRetentionInput: Swift.Equatable {
    /// The version of the stream whose retention period you want to change. To get the version, call either the DescribeStream or the ListStreams API.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The retention period, in hours. The value you specify replaces the current value. The maximum value for this parameter is 87600 (ten years).
    /// This member is required.
    public var dataRetentionChangeInHours: Swift.Int?
    /// Indicates whether you want to increase or decrease the retention period.
    /// This member is required.
    public var operation: KinesisVideoClientTypes.UpdateDataRetentionOperation?
    /// The Amazon Resource Name (ARN) of the stream whose retention period you want to change.
    public var streamARN: Swift.String?
    /// The name of the stream whose retention period you want to change.
    public var streamName: Swift.String?

    public init (
        currentVersion: Swift.String? = nil,
        dataRetentionChangeInHours: Swift.Int? = nil,
        operation: KinesisVideoClientTypes.UpdateDataRetentionOperation? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.dataRetentionChangeInHours = dataRetentionChangeInHours
        self.operation = operation
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct UpdateDataRetentionInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let currentVersion: Swift.String?
    let operation: KinesisVideoClientTypes.UpdateDataRetentionOperation?
    let dataRetentionChangeInHours: Swift.Int?
}

extension UpdateDataRetentionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case dataRetentionChangeInHours = "DataRetentionChangeInHours"
        case operation = "Operation"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let operationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.UpdateDataRetentionOperation.self, forKey: .operation)
        operation = operationDecoded
        let dataRetentionChangeInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionChangeInHours)
        dataRetentionChangeInHours = dataRetentionChangeInHoursDecoded
    }
}

extension KinesisVideoClientTypes {
    public enum UpdateDataRetentionOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case decreaseDataRetention
        case increaseDataRetention
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateDataRetentionOperation] {
            return [
                .decreaseDataRetention,
                .increaseDataRetention,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .decreaseDataRetention: return "DECREASE_DATA_RETENTION"
            case .increaseDataRetention: return "INCREASE_DATA_RETENTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateDataRetentionOperation(rawValue: rawValue) ?? UpdateDataRetentionOperation.sdkUnknown(rawValue)
        }
    }
}

extension UpdateDataRetentionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataRetentionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataRetentionOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataRetentionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDataRetentionOutputResponse: Swift.Equatable {

}

extension UpdateSignalingChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
        case singleMasterConfiguration = "SingleMasterConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let singleMasterConfiguration = singleMasterConfiguration {
            try encodeContainer.encode(singleMasterConfiguration, forKey: .singleMasterConfiguration)
        }
    }
}

extension UpdateSignalingChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateSignalingChannel"
    }
}

public struct UpdateSignalingChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signaling channel that you want to update.
    /// This member is required.
    public var channelARN: Swift.String?
    /// The current version of the signaling channel that you want to update.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The structure containing the configuration for the SINGLE_MASTER type of the signaling channel that you want to update.
    public var singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?

    public init (
        channelARN: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.currentVersion = currentVersion
        self.singleMasterConfiguration = singleMasterConfiguration
    }
}

struct UpdateSignalingChannelInputBody: Swift.Equatable {
    let channelARN: Swift.String?
    let currentVersion: Swift.String?
    let singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
}

extension UpdateSignalingChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
        case singleMasterConfiguration = "SingleMasterConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let singleMasterConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SingleMasterConfiguration.self, forKey: .singleMasterConfiguration)
        singleMasterConfiguration = singleMasterConfigurationDecoded
    }
}

extension UpdateSignalingChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSignalingChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSignalingChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSignalingChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSignalingChannelOutputResponse: Swift.Equatable {

}

extension UpdateStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case deviceName = "DeviceName"
        case mediaType = "MediaType"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let mediaType = mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension UpdateStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateStream"
    }
}

public struct UpdateStreamInput: Swift.Equatable {
    /// The version of the stream whose metadata you want to update.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The name of the device that is writing to the stream. In the current implementation, Kinesis Video Streams does not use this name.
    public var deviceName: Swift.String?
    /// The stream's media type. Use MediaType to specify the type of content that the stream contains to the consumers of the stream. For more information about media types, see [Media Types](http://www.iana.org/assignments/media-types/media-types.xhtml). If you choose to specify the MediaType, see [Naming Requirements](https://tools.ietf.org/html/rfc6838#section-4.2). To play video on the console, you must specify the correct video type. For example, if the video in the stream is H.264, specify video/h264 as the MediaType.
    public var mediaType: Swift.String?
    /// The ARN of the stream whose metadata you want to update.
    public var streamARN: Swift.String?
    /// The name of the stream whose metadata you want to update. The stream name is an identifier for the stream, and must be unique for each account and region.
    public var streamName: Swift.String?

    public init (
        currentVersion: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        mediaType: Swift.String? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.deviceName = deviceName
        self.mediaType = mediaType
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct UpdateStreamInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let currentVersion: Swift.String?
    let deviceName: Swift.String?
    let mediaType: Swift.String?
}

extension UpdateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case deviceName = "DeviceName"
        case mediaType = "MediaType"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
    }
}

extension UpdateStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStreamOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateStreamOutputResponse: Swift.Equatable {

}

extension VersionMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: VersionMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The stream version that you specified is not the latest version. To get the latest version, use the [DescribeStream](https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_DescribeStream.html) API.
public struct VersionMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct VersionMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension VersionMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
