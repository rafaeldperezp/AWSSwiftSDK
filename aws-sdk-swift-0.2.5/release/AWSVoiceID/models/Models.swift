// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient permissions to perform this action. Check the error message and try again.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIdClientTypes.AuthenticationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptanceThreshold = "AcceptanceThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptanceThreshold = acceptanceThreshold {
            try encodeContainer.encode(acceptanceThreshold, forKey: .acceptanceThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptanceThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .acceptanceThreshold)
        acceptanceThreshold = acceptanceThresholdDecoded
    }
}

extension VoiceIdClientTypes {
    /// The configuration used to authenticate a speaker during a session.
    public struct AuthenticationConfiguration: Swift.Equatable {
        /// The minimum threshold needed to successfully authenticate a speaker.
        /// This member is required.
        public var acceptanceThreshold: Swift.Int?

        public init (
            acceptanceThreshold: Swift.Int? = nil
        )
        {
            self.acceptanceThreshold = acceptanceThreshold
        }
    }

}

extension VoiceIdClientTypes {
    public enum AuthenticationDecision: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accept
        case notEnoughSpeech
        case reject
        case speakerIdNotProvided
        case speakerNotEnrolled
        case speakerOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationDecision] {
            return [
                .accept,
                .notEnoughSpeech,
                .reject,
                .speakerIdNotProvided,
                .speakerNotEnrolled,
                .speakerOptedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accept: return "ACCEPT"
            case .notEnoughSpeech: return "NOT_ENOUGH_SPEECH"
            case .reject: return "REJECT"
            case .speakerIdNotProvided: return "SPEAKER_ID_NOT_PROVIDED"
            case .speakerNotEnrolled: return "SPEAKER_NOT_ENROLLED"
            case .speakerOptedOut: return "SPEAKER_OPTED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationDecision(rawValue: rawValue) ?? AuthenticationDecision.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.AuthenticationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioAggregationEndedAt = "AudioAggregationEndedAt"
        case audioAggregationStartedAt = "AudioAggregationStartedAt"
        case authenticationResultId = "AuthenticationResultId"
        case configuration = "Configuration"
        case customerSpeakerId = "CustomerSpeakerId"
        case decision = "Decision"
        case generatedSpeakerId = "GeneratedSpeakerId"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioAggregationEndedAt = audioAggregationEndedAt {
            try encodeContainer.encode(audioAggregationEndedAt.timeIntervalSince1970, forKey: .audioAggregationEndedAt)
        }
        if let audioAggregationStartedAt = audioAggregationStartedAt {
            try encodeContainer.encode(audioAggregationStartedAt.timeIntervalSince1970, forKey: .audioAggregationStartedAt)
        }
        if let authenticationResultId = authenticationResultId {
            try encodeContainer.encode(authenticationResultId, forKey: .authenticationResultId)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let customerSpeakerId = customerSpeakerId {
            try encodeContainer.encode(customerSpeakerId, forKey: .customerSpeakerId)
        }
        if let decision = decision {
            try encodeContainer.encode(decision.rawValue, forKey: .decision)
        }
        if let generatedSpeakerId = generatedSpeakerId {
            try encodeContainer.encode(generatedSpeakerId, forKey: .generatedSpeakerId)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationResultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationResultId)
        authenticationResultId = authenticationResultIdDecoded
        let audioAggregationStartedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .audioAggregationStartedAt)
        audioAggregationStartedAt = audioAggregationStartedAtDecoded
        let audioAggregationEndedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .audioAggregationEndedAt)
        audioAggregationEndedAt = audioAggregationEndedAtDecoded
        let customerSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerSpeakerId)
        customerSpeakerId = customerSpeakerIdDecoded
        let generatedSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedSpeakerId)
        generatedSpeakerId = generatedSpeakerIdDecoded
        let decisionDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.AuthenticationDecision.self, forKey: .decision)
        decision = decisionDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .score)
        score = scoreDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.AuthenticationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension VoiceIdClientTypes {
    /// The authentication result produced by Voice ID, processed against the current session state and streamed audio of the speaker.
    public struct AuthenticationResult: Swift.Equatable {
        /// A timestamp indicating when audio aggregation ended for this authentication result.
        public var audioAggregationEndedAt: ClientRuntime.Date?
        /// A timestamp indicating when audio aggregation started for this authentication result.
        public var audioAggregationStartedAt: ClientRuntime.Date?
        /// The unique identifier for this authentication result. Because there can be multiple authentications for a given session, this field helps to identify if the returned result is from a previous streaming activity or a new result. Note that in absence of any new streaming activity, AcceptanceThreshold changes, or SpeakerId changes, Voice ID always returns cached Authentication Result for this API.
        public var authenticationResultId: Swift.String?
        /// The AuthenticationConfiguration used to generate this authentication result.
        public var configuration: VoiceIdClientTypes.AuthenticationConfiguration?
        /// The client-provided identifier for the speaker whose authentication result is produced. Only present if a SpeakerId is provided for the session.
        public var customerSpeakerId: Swift.String?
        /// The authentication decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.
        public var decision: VoiceIdClientTypes.AuthenticationDecision?
        /// The service-generated identifier for the speaker whose authentication result is produced.
        public var generatedSpeakerId: Swift.String?
        /// The authentication score for the speaker whose authentication result is produced. This value is only present if the authentication decision is either ACCEPT or REJECT.
        public var score: Swift.Int?

        public init (
            audioAggregationEndedAt: ClientRuntime.Date? = nil,
            audioAggregationStartedAt: ClientRuntime.Date? = nil,
            authenticationResultId: Swift.String? = nil,
            configuration: VoiceIdClientTypes.AuthenticationConfiguration? = nil,
            customerSpeakerId: Swift.String? = nil,
            decision: VoiceIdClientTypes.AuthenticationDecision? = nil,
            generatedSpeakerId: Swift.String? = nil,
            score: Swift.Int? = nil
        )
        {
            self.audioAggregationEndedAt = audioAggregationEndedAt
            self.audioAggregationStartedAt = audioAggregationStartedAt
            self.authenticationResultId = authenticationResultId
            self.configuration = configuration
            self.customerSpeakerId = customerSpeakerId
            self.decision = decision
            self.generatedSpeakerId = generatedSpeakerId
            self.score = score
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.conflictType = output.conflictType
            self.message = output.message
        } else {
            self.conflictType = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed due to a conflict. Check the ConflictType and error message for more details.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The type of conflict which caused a ConflictException. Possible types and the corresponding error messages are as follows:
    ///
    /// * DOMAIN_NOT_ACTIVE: The domain is not active.
    ///
    /// * CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT: You cannot change the speaker ID after an enrollment has been requested.
    ///
    /// * ENROLLMENT_ALREADY_EXISTS: There is already an enrollment for this session.
    ///
    /// * SPEAKER_NOT_SET: You must set the speaker ID before requesting an enrollment.
    ///
    /// * SPEAKER_OPTED_OUT: You cannot request an enrollment for an opted out speaker.
    ///
    /// * CONCURRENT_CHANGES: The request could not be processed as the resource was modified by another request during execution.
    public var conflictType: VoiceIdClientTypes.ConflictType?
    public var message: Swift.String?

    public init (
        conflictType: VoiceIdClientTypes.ConflictType? = nil,
        message: Swift.String? = nil
    )
    {
        self.conflictType = conflictType
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let conflictType: VoiceIdClientTypes.ConflictType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictType = "ConflictType"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let conflictTypeDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ConflictType.self, forKey: .conflictType)
        conflictType = conflictTypeDecoded
    }
}

extension VoiceIdClientTypes {
    public enum ConflictType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anotherActiveStream
        case cannotChangeSpeakerAfterEnrollment
        case concurrentChanges
        case domainNotActive
        case enrollmentAlreadyExists
        case speakerNotSet
        case speakerOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictType] {
            return [
                .anotherActiveStream,
                .cannotChangeSpeakerAfterEnrollment,
                .concurrentChanges,
                .domainNotActive,
                .enrollmentAlreadyExists,
                .speakerNotSet,
                .speakerOptedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anotherActiveStream: return "ANOTHER_ACTIVE_STREAM"
            case .cannotChangeSpeakerAfterEnrollment: return "CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT"
            case .concurrentChanges: return "CONCURRENT_CHANGES"
            case .domainNotActive: return "DOMAIN_NOT_ACTIVE"
            case .enrollmentAlreadyExists: return "ENROLLMENT_ALREADY_EXISTS"
            case .speakerNotSet: return "SPEAKER_NOT_SET"
            case .speakerOptedOut: return "SPEAKER_OPTED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictType(rawValue: rawValue) ?? ConflictType.sdkUnknown(rawValue)
        }
    }
}

extension CreateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDomainInput: Swift.Equatable {
    /// The idempotency token for creating a new domain. If not provided, Amazon Web Services SDK populates this field.
    public var clientToken: Swift.String?
    /// A brief description of this domain.
    public var description: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration, containing the KMS Key Identifier, to be used by Voice ID for the server-side encryption of your data. Refer to [ Amazon Connect VoiceID encryption at rest](https://docs.aws.amazon.com/connect/latest/adminguide/encryption-at-rest.html#encryption-at-rest-voiceid) for more details on how the KMS Key is used.
    /// This member is required.
    public var serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration?
    /// A list of tags you want added to the domain.
    public var tags: [VoiceIdClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [VoiceIdClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration?
    let clientToken: Swift.String?
    let tags: [VoiceIdClientTypes.Tag]?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[VoiceIdClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [VoiceIdClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct CreateDomainOutputResponse: Swift.Equatable {
    /// Information about the newly created domain.
    public var domain: VoiceIdClientTypes.Domain?

    public init (
        domain: VoiceIdClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

struct CreateDomainOutputResponseBody: Swift.Equatable {
    let domain: VoiceIdClientTypes.Domain?
}

extension CreateDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DeleteDomainInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDomainInput: Swift.Equatable {
    /// The identifier of the domain you want to delete.
    /// This member is required.
    public var domainId: Swift.String?

    public init (
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
}

extension DeleteDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDomainOutputResponse: Swift.Equatable {

}

extension DeleteFraudsterInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteFraudsterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFraudsterInput: Swift.Equatable {
    /// The identifier of the domain containing the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster you want to delete.
    /// This member is required.
    public var fraudsterId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
    }
}

struct DeleteFraudsterInputBody: Swift.Equatable {
}

extension DeleteFraudsterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFraudsterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFraudsterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFraudsterOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFraudsterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFraudsterOutputResponse: Swift.Equatable {

}

extension DeleteSpeakerInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteSpeakerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSpeakerInput: Swift.Equatable {
    /// The identifier of the domain containing the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you want to delete.
    /// This member is required.
    public var speakerId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

struct DeleteSpeakerInputBody: Swift.Equatable {
}

extension DeleteSpeakerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSpeakerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSpeakerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSpeakerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSpeakerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSpeakerOutputResponse: Swift.Equatable {

}

extension DescribeDomainInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDomainInput: Swift.Equatable {
    /// The identifier of the domain you are describing.
    /// This member is required.
    public var domainId: Swift.String?

    public init (
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct DescribeDomainInputBody: Swift.Equatable {
}

extension DescribeDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct DescribeDomainOutputResponse: Swift.Equatable {
    /// Information about the specified domain.
    public var domain: VoiceIdClientTypes.Domain?

    public init (
        domain: VoiceIdClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

struct DescribeDomainOutputResponseBody: Swift.Equatable {
    let domain: VoiceIdClientTypes.Domain?
}

extension DescribeDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DescribeFraudsterInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeFraudsterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFraudsterInput: Swift.Equatable {
    /// The identifier of the domain containing the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster you are describing.
    /// This member is required.
    public var fraudsterId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
    }
}

struct DescribeFraudsterInputBody: Swift.Equatable {
}

extension DescribeFraudsterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFraudsterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFraudsterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFraudsterOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFraudsterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFraudsterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fraudster = output.fraudster
        } else {
            self.fraudster = nil
        }
    }
}

public struct DescribeFraudsterOutputResponse: Swift.Equatable {
    /// Information about the specified fraudster.
    public var fraudster: VoiceIdClientTypes.Fraudster?

    public init (
        fraudster: VoiceIdClientTypes.Fraudster? = nil
    )
    {
        self.fraudster = fraudster
    }
}

struct DescribeFraudsterOutputResponseBody: Swift.Equatable {
    let fraudster: VoiceIdClientTypes.Fraudster?
}

extension DescribeFraudsterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fraudster = "Fraudster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudsterDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.Fraudster.self, forKey: .fraudster)
        fraudster = fraudsterDecoded
    }
}

extension DescribeFraudsterRegistrationJobInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeFraudsterRegistrationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFraudsterRegistrationJobInput: Swift.Equatable {
    /// The identifier for the domain containing the fraudster registration job.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier for the fraudster registration job you are describing.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobId = jobId
    }
}

struct DescribeFraudsterRegistrationJobInputBody: Swift.Equatable {
}

extension DescribeFraudsterRegistrationJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFraudsterRegistrationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFraudsterRegistrationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFraudsterRegistrationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFraudsterRegistrationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFraudsterRegistrationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct DescribeFraudsterRegistrationJobOutputResponse: Swift.Equatable {
    /// Contains details about the specified fraudster registration job.
    public var job: VoiceIdClientTypes.FraudsterRegistrationJob?

    public init (
        job: VoiceIdClientTypes.FraudsterRegistrationJob? = nil
    )
    {
        self.job = job
    }
}

struct DescribeFraudsterRegistrationJobOutputResponseBody: Swift.Equatable {
    let job: VoiceIdClientTypes.FraudsterRegistrationJob?
}

extension DescribeFraudsterRegistrationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudsterRegistrationJob.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeSpeakerEnrollmentJobInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeSpeakerEnrollmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSpeakerEnrollmentJobInput: Swift.Equatable {
    /// The identifier of the domain containing the speaker enrollment job.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker enrollment job you are describing.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobId = jobId
    }
}

struct DescribeSpeakerEnrollmentJobInputBody: Swift.Equatable {
}

extension DescribeSpeakerEnrollmentJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSpeakerEnrollmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSpeakerEnrollmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSpeakerEnrollmentJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSpeakerEnrollmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSpeakerEnrollmentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct DescribeSpeakerEnrollmentJobOutputResponse: Swift.Equatable {
    /// Contains details about the specified speaker enrollment job.
    public var job: VoiceIdClientTypes.SpeakerEnrollmentJob?

    public init (
        job: VoiceIdClientTypes.SpeakerEnrollmentJob? = nil
    )
    {
        self.job = job
    }
}

struct DescribeSpeakerEnrollmentJobOutputResponseBody: Swift.Equatable {
    let job: VoiceIdClientTypes.SpeakerEnrollmentJob?
}

extension DescribeSpeakerEnrollmentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.SpeakerEnrollmentJob.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeSpeakerInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeSpeakerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSpeakerInput: Swift.Equatable {
    /// The identifier of the domain that contains the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you are describing.
    /// This member is required.
    public var speakerId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

struct DescribeSpeakerInputBody: Swift.Equatable {
}

extension DescribeSpeakerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSpeakerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSpeakerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSpeakerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSpeakerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSpeakerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.speaker = output.speaker
        } else {
            self.speaker = nil
        }
    }
}

public struct DescribeSpeakerOutputResponse: Swift.Equatable {
    /// Information about the specified speaker.
    public var speaker: VoiceIdClientTypes.Speaker?

    public init (
        speaker: VoiceIdClientTypes.Speaker? = nil
    )
    {
        self.speaker = speaker
    }
}

struct DescribeSpeakerOutputResponseBody: Swift.Equatable {
    let speaker: VoiceIdClientTypes.Speaker?
}

extension DescribeSpeakerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speaker = "Speaker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.Speaker.self, forKey: .speaker)
        speaker = speakerDecoded
    }
}

extension VoiceIdClientTypes.Domain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case domainId = "DomainId"
        case domainStatus = "DomainStatus"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let domainStatus = domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension VoiceIdClientTypes {
    /// Contains all the information about a domain.
    public struct Domain: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the domain.
        public var arn: Swift.String?
        /// The timestamp at which the domain is created.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided description of the domain.
        public var description: Swift.String?
        /// The service-generated identifier for the domain.
        public var domainId: Swift.String?
        /// The current status of the domain.
        public var domainStatus: VoiceIdClientTypes.DomainStatus?
        /// The client-provided name for the domain.
        public var name: Swift.String?
        /// The server-side encryption configuration containing the KMS Key Identifier you want Voice ID to use to encrypt your data.
        public var serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration?
        /// The timestamp showing the domain's last update.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            domainStatus: VoiceIdClientTypes.DomainStatus? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension VoiceIdClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case pending
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .pending,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .pending: return "PENDING"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.DomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case domainId = "DomainId"
        case domainStatus = "DomainStatus"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let domainStatus = domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension VoiceIdClientTypes {
    /// Contains a summary of information about a domain.
    public struct DomainSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the domain.
        public var arn: Swift.String?
        /// The timestamp showing when the domain is created.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided description of the domain.
        public var description: Swift.String?
        /// The service-generated identifier for the domain.
        public var domainId: Swift.String?
        /// The current status of the domain.
        public var domainStatus: VoiceIdClientTypes.DomainStatus?
        /// The client-provided name for the domain.
        public var name: Swift.String?
        /// The server-side encryption configuration containing the KMS Key Identifier you want Voice ID to use to encrypt your data..
        public var serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration?
        /// The timestamp showing the domain's last update.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            domainStatus: VoiceIdClientTypes.DomainStatus? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension VoiceIdClientTypes {
    public enum DuplicateRegistrationAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case registerAsNew
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [DuplicateRegistrationAction] {
            return [
                .registerAsNew,
                .skip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .registerAsNew: return "REGISTER_AS_NEW"
            case .skip: return "SKIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DuplicateRegistrationAction(rawValue: rawValue) ?? DuplicateRegistrationAction.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.EnrollmentConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case existingEnrollmentAction = "ExistingEnrollmentAction"
        case fraudDetectionConfig = "FraudDetectionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let existingEnrollmentAction = existingEnrollmentAction {
            try encodeContainer.encode(existingEnrollmentAction.rawValue, forKey: .existingEnrollmentAction)
        }
        if let fraudDetectionConfig = fraudDetectionConfig {
            try encodeContainer.encode(fraudDetectionConfig, forKey: .fraudDetectionConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let existingEnrollmentActionDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ExistingEnrollmentAction.self, forKey: .existingEnrollmentAction)
        existingEnrollmentAction = existingEnrollmentActionDecoded
        let fraudDetectionConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.EnrollmentJobFraudDetectionConfig.self, forKey: .fraudDetectionConfig)
        fraudDetectionConfig = fraudDetectionConfigDecoded
    }
}

extension VoiceIdClientTypes {
    /// Contains configurations defining enrollment behavior for the batch job.
    public struct EnrollmentConfig: Swift.Equatable {
        /// The action to take when the specified speaker is already enrolled in the specified domain. The default value is SKIP, which skips the enrollment for the existing speaker. Setting the value to OVERWRITE replaces the existing voice prints and enrollment audio stored for that speaker with new data generated from the latest audio.
        public var existingEnrollmentAction: VoiceIdClientTypes.ExistingEnrollmentAction?
        /// The fraud detection configuration to use for the speaker enrollment job.
        public var fraudDetectionConfig: VoiceIdClientTypes.EnrollmentJobFraudDetectionConfig?

        public init (
            existingEnrollmentAction: VoiceIdClientTypes.ExistingEnrollmentAction? = nil,
            fraudDetectionConfig: VoiceIdClientTypes.EnrollmentJobFraudDetectionConfig? = nil
        )
        {
            self.existingEnrollmentAction = existingEnrollmentAction
            self.fraudDetectionConfig = fraudDetectionConfig
        }
    }

}

extension VoiceIdClientTypes.EnrollmentJobFraudDetectionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fraudDetectionAction = "FraudDetectionAction"
        case riskThreshold = "RiskThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fraudDetectionAction = fraudDetectionAction {
            try encodeContainer.encode(fraudDetectionAction.rawValue, forKey: .fraudDetectionAction)
        }
        if let riskThreshold = riskThreshold {
            try encodeContainer.encode(riskThreshold, forKey: .riskThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudDetectionActionDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudDetectionAction.self, forKey: .fraudDetectionAction)
        fraudDetectionAction = fraudDetectionActionDecoded
        let riskThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskThreshold)
        riskThreshold = riskThresholdDecoded
    }
}

extension VoiceIdClientTypes {
    /// The configuration defining the action to take when a speaker is flagged by the fraud detection system during a batch speaker enrollment job, and the risk threshold to use for identification.
    public struct EnrollmentJobFraudDetectionConfig: Swift.Equatable {
        /// The action to take when the given speaker is flagged by the fraud detection system. The default value is FAIL, which fails the speaker enrollment. Changing this value to IGNORE results in the speaker being enrolled even if they are flagged by the fraud detection system.
        public var fraudDetectionAction: VoiceIdClientTypes.FraudDetectionAction?
        /// Threshold value for determining whether the speaker is a high risk to be fraudulent. If the detected risk score calculated by Voice ID is greater than or equal to the threshold, the speaker is considered a fraudster.
        public var riskThreshold: Swift.Int?

        public init (
            fraudDetectionAction: VoiceIdClientTypes.FraudDetectionAction? = nil,
            riskThreshold: Swift.Int? = nil
        )
        {
            self.fraudDetectionAction = fraudDetectionAction
            self.riskThreshold = riskThreshold
        }
    }

}

extension EvaluateSessionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension EvaluateSessionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        return items
    }
}

extension EvaluateSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EvaluateSessionInput: Swift.Equatable {
    /// The identifier of the domain where the session started.
    /// This member is required.
    public var domainId: Swift.String?
    /// The session identifier, or name of the session, that you want to evaluate. In Voice ID integration, this is the Contact-Id.
    /// This member is required.
    public var sessionNameOrId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        sessionNameOrId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.sessionNameOrId = sessionNameOrId
    }
}

struct EvaluateSessionInputBody: Swift.Equatable {
}

extension EvaluateSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EvaluateSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EvaluateSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EvaluateSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EvaluateSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EvaluateSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authenticationResult = output.authenticationResult
            self.domainId = output.domainId
            self.fraudDetectionResult = output.fraudDetectionResult
            self.sessionId = output.sessionId
            self.sessionName = output.sessionName
            self.streamingStatus = output.streamingStatus
        } else {
            self.authenticationResult = nil
            self.domainId = nil
            self.fraudDetectionResult = nil
            self.sessionId = nil
            self.sessionName = nil
            self.streamingStatus = nil
        }
    }
}

public struct EvaluateSessionOutputResponse: Swift.Equatable {
    /// Details resulting from the authentication process, such as authentication decision and authentication score.
    public var authenticationResult: VoiceIdClientTypes.AuthenticationResult?
    /// The identifier of the domain containing the session.
    public var domainId: Swift.String?
    /// Details resulting from the fraud detection process, such as fraud detection decision and risk score.
    public var fraudDetectionResult: VoiceIdClientTypes.FraudDetectionResult?
    /// The service-generated identifier of the session.
    public var sessionId: Swift.String?
    /// The client-provided name of the session.
    public var sessionName: Swift.String?
    /// The current status of audio streaming for this session. This field is useful to infer next steps when the Authentication or Fraud Detection results are empty or the decision is NOT_ENOUGH_SPEECH. In this situation, if the StreamingStatus is ONGOING/PENDING_CONFIGURATION, it can mean that the client should call the API again later, once Voice ID has enough audio to produce a result. If the decision remains NOT_ENOUGH_SPEECH even after StreamingStatus is ENDED, it means that the previously streamed session did not have enough speech to perform evaluation, and a new streaming session is needed to try again.
    public var streamingStatus: VoiceIdClientTypes.StreamingStatus?

    public init (
        authenticationResult: VoiceIdClientTypes.AuthenticationResult? = nil,
        domainId: Swift.String? = nil,
        fraudDetectionResult: VoiceIdClientTypes.FraudDetectionResult? = nil,
        sessionId: Swift.String? = nil,
        sessionName: Swift.String? = nil,
        streamingStatus: VoiceIdClientTypes.StreamingStatus? = nil
    )
    {
        self.authenticationResult = authenticationResult
        self.domainId = domainId
        self.fraudDetectionResult = fraudDetectionResult
        self.sessionId = sessionId
        self.sessionName = sessionName
        self.streamingStatus = streamingStatus
    }
}

struct EvaluateSessionOutputResponseBody: Swift.Equatable {
    let domainId: Swift.String?
    let sessionId: Swift.String?
    let sessionName: Swift.String?
    let streamingStatus: VoiceIdClientTypes.StreamingStatus?
    let authenticationResult: VoiceIdClientTypes.AuthenticationResult?
    let fraudDetectionResult: VoiceIdClientTypes.FraudDetectionResult?
}

extension EvaluateSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationResult = "AuthenticationResult"
        case domainId = "DomainId"
        case fraudDetectionResult = "FraudDetectionResult"
        case sessionId = "SessionId"
        case sessionName = "SessionName"
        case streamingStatus = "StreamingStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let sessionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionName)
        sessionName = sessionNameDecoded
        let streamingStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.StreamingStatus.self, forKey: .streamingStatus)
        streamingStatus = streamingStatusDecoded
        let authenticationResultDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.AuthenticationResult.self, forKey: .authenticationResult)
        authenticationResult = authenticationResultDecoded
        let fraudDetectionResultDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudDetectionResult.self, forKey: .fraudDetectionResult)
        fraudDetectionResult = fraudDetectionResultDecoded
    }
}

extension VoiceIdClientTypes {
    public enum ExistingEnrollmentAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case overwrite
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [ExistingEnrollmentAction] {
            return [
                .overwrite,
                .skip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .overwrite: return "OVERWRITE"
            case .skip: return "SKIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExistingEnrollmentAction(rawValue: rawValue) ?? ExistingEnrollmentAction.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.FailureDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIdClientTypes {
    /// Contains error details for a failed batch job.
    public struct FailureDetails: Swift.Equatable {
        /// A description of the error that caused the batch job failure.
        public var message: Swift.String?
        /// An HTTP status code representing the nature of the error.
        public var statusCode: Swift.Int?

        public init (
            message: Swift.String? = nil,
            statusCode: Swift.Int? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }

}

extension VoiceIdClientTypes {
    public enum FraudDetectionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fail
        case ignore
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionAction] {
            return [
                .fail,
                .ignore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .ignore: return "IGNORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudDetectionAction(rawValue: rawValue) ?? FraudDetectionAction.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.FraudDetectionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case riskThreshold = "RiskThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let riskThreshold = riskThreshold {
            try encodeContainer.encode(riskThreshold, forKey: .riskThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskThreshold)
        riskThreshold = riskThresholdDecoded
    }
}

extension VoiceIdClientTypes {
    /// The configuration used for performing fraud detection over a speaker during a session.
    public struct FraudDetectionConfiguration: Swift.Equatable {
        /// Threshold value for determining whether the speaker is a fraudster. If the detected risk score calculated by Voice ID is higher than the threshold, the speaker is considered a fraudster.
        /// This member is required.
        public var riskThreshold: Swift.Int?

        public init (
            riskThreshold: Swift.Int? = nil
        )
        {
            self.riskThreshold = riskThreshold
        }
    }

}

extension VoiceIdClientTypes {
    public enum FraudDetectionDecision: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case highRisk
        case lowRisk
        case notEnoughSpeech
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionDecision] {
            return [
                .highRisk,
                .lowRisk,
                .notEnoughSpeech,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .highRisk: return "HIGH_RISK"
            case .lowRisk: return "LOW_RISK"
            case .notEnoughSpeech: return "NOT_ENOUGH_SPEECH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudDetectionDecision(rawValue: rawValue) ?? FraudDetectionDecision.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes {
    public enum FraudDetectionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knownFraudster
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionReason] {
            return [
                .knownFraudster,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knownFraudster: return "KNOWN_FRAUDSTER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudDetectionReason(rawValue: rawValue) ?? FraudDetectionReason.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.FraudDetectionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioAggregationEndedAt = "AudioAggregationEndedAt"
        case audioAggregationStartedAt = "AudioAggregationStartedAt"
        case configuration = "Configuration"
        case decision = "Decision"
        case fraudDetectionResultId = "FraudDetectionResultId"
        case reasons = "Reasons"
        case riskDetails = "RiskDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioAggregationEndedAt = audioAggregationEndedAt {
            try encodeContainer.encode(audioAggregationEndedAt.timeIntervalSince1970, forKey: .audioAggregationEndedAt)
        }
        if let audioAggregationStartedAt = audioAggregationStartedAt {
            try encodeContainer.encode(audioAggregationStartedAt.timeIntervalSince1970, forKey: .audioAggregationStartedAt)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let decision = decision {
            try encodeContainer.encode(decision.rawValue, forKey: .decision)
        }
        if let fraudDetectionResultId = fraudDetectionResultId {
            try encodeContainer.encode(fraudDetectionResultId, forKey: .fraudDetectionResultId)
        }
        if let reasons = reasons {
            var reasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reasons)
            for frauddetectionreasons0 in reasons {
                try reasonsContainer.encode(frauddetectionreasons0.rawValue)
            }
        }
        if let riskDetails = riskDetails {
            try encodeContainer.encode(riskDetails, forKey: .riskDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudDetectionResultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fraudDetectionResultId)
        fraudDetectionResultId = fraudDetectionResultIdDecoded
        let audioAggregationStartedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .audioAggregationStartedAt)
        audioAggregationStartedAt = audioAggregationStartedAtDecoded
        let audioAggregationEndedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .audioAggregationEndedAt)
        audioAggregationEndedAt = audioAggregationEndedAtDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudDetectionConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let decisionDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudDetectionDecision.self, forKey: .decision)
        decision = decisionDecoded
        let reasonsContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.FraudDetectionReason?].self, forKey: .reasons)
        var reasonsDecoded0:[VoiceIdClientTypes.FraudDetectionReason]? = nil
        if let reasonsContainer = reasonsContainer {
            reasonsDecoded0 = [VoiceIdClientTypes.FraudDetectionReason]()
            for string0 in reasonsContainer {
                if let string0 = string0 {
                    reasonsDecoded0?.append(string0)
                }
            }
        }
        reasons = reasonsDecoded0
        let riskDetailsDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudRiskDetails.self, forKey: .riskDetails)
        riskDetails = riskDetailsDecoded
    }
}

extension VoiceIdClientTypes {
    /// The fraud detection result produced by Voice ID, processed against the current session state and streamed audio of the speaker.
    public struct FraudDetectionResult: Swift.Equatable {
        /// A timestamp indicating when audio aggregation ended for this fraud detection result.
        public var audioAggregationEndedAt: ClientRuntime.Date?
        /// A timestamp indicating when audio aggregation started for this fraud detection result.
        public var audioAggregationStartedAt: ClientRuntime.Date?
        /// The FraudDetectionConfiguration used to generate this fraud detection result.
        public var configuration: VoiceIdClientTypes.FraudDetectionConfiguration?
        /// The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.
        public var decision: VoiceIdClientTypes.FraudDetectionDecision?
        /// The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.
        public var fraudDetectionResultId: Swift.String?
        /// The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is HIGH_RISK, and only has one possible value: KNOWN_FRAUDSTER.
        public var reasons: [VoiceIdClientTypes.FraudDetectionReason]?
        /// Details about each risk analyzed for this speaker.
        public var riskDetails: VoiceIdClientTypes.FraudRiskDetails?

        public init (
            audioAggregationEndedAt: ClientRuntime.Date? = nil,
            audioAggregationStartedAt: ClientRuntime.Date? = nil,
            configuration: VoiceIdClientTypes.FraudDetectionConfiguration? = nil,
            decision: VoiceIdClientTypes.FraudDetectionDecision? = nil,
            fraudDetectionResultId: Swift.String? = nil,
            reasons: [VoiceIdClientTypes.FraudDetectionReason]? = nil,
            riskDetails: VoiceIdClientTypes.FraudRiskDetails? = nil
        )
        {
            self.audioAggregationEndedAt = audioAggregationEndedAt
            self.audioAggregationStartedAt = audioAggregationStartedAt
            self.configuration = configuration
            self.decision = decision
            self.fraudDetectionResultId = fraudDetectionResultId
            self.reasons = reasons
            self.riskDetails = riskDetails
        }
    }

}

extension VoiceIdClientTypes.FraudRiskDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knownFraudsterRisk = "KnownFraudsterRisk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let knownFraudsterRisk = knownFraudsterRisk {
            try encodeContainer.encode(knownFraudsterRisk, forKey: .knownFraudsterRisk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knownFraudsterRiskDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.KnownFraudsterRisk.self, forKey: .knownFraudsterRisk)
        knownFraudsterRisk = knownFraudsterRiskDecoded
    }
}

extension VoiceIdClientTypes {
    /// Details regarding various fraud risk analyses performed against the current session state and streamed audio of the speaker.
    public struct FraudRiskDetails: Swift.Equatable {
        /// The details resulting from 'Known Fraudster Risk' analysis of the speaker.
        /// This member is required.
        public var knownFraudsterRisk: VoiceIdClientTypes.KnownFraudsterRisk?

        public init (
            knownFraudsterRisk: VoiceIdClientTypes.KnownFraudsterRisk? = nil
        )
        {
            self.knownFraudsterRisk = knownFraudsterRisk
        }
    }

}

extension VoiceIdClientTypes.Fraudster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case generatedFraudsterId = "GeneratedFraudsterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedFraudsterId = generatedFraudsterId {
            try encodeContainer.encode(generatedFraudsterId, forKey: .generatedFraudsterId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let generatedFraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFraudsterId)
        generatedFraudsterId = generatedFraudsterIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension VoiceIdClientTypes {
    /// Contains all the information about a fraudster.
    public struct Fraudster: Swift.Equatable {
        /// The timestamp when Voice ID identified the fraudster.
        public var createdAt: ClientRuntime.Date?
        /// The identifier for the domain containing the fraudster.
        public var domainId: Swift.String?
        /// The service-generated identifier for the fraudster.
        public var generatedFraudsterId: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            generatedFraudsterId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.generatedFraudsterId = generatedFraudsterId
        }
    }

}

extension VoiceIdClientTypes.FraudsterRegistrationJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case failureDetails = "FailureDetails"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
        case outputDataConfig = "OutputDataConfig"
        case registrationConfig = "RegistrationConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.timeIntervalSince1970, forKey: .endedAt)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let registrationConfig = registrationConfig {
            try encodeContainer.encode(registrationConfig, forKey: .registrationConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudsterRegistrationJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let registrationConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIdClientTypes {
    /// Contains all the information about a fraudster registration job.
    public struct FraudsterRegistrationJob: Swift.Equatable {
        /// A timestamp showing the creation time of the fraudster registration job.
        public var createdAt: ClientRuntime.Date?
        /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.
        public var dataAccessRoleArn: Swift.String?
        /// The identifier of the domain containing the fraudster registration job.
        public var domainId: Swift.String?
        /// A timestamp showing when the fraudster registration job ended.
        public var endedAt: ClientRuntime.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIdClientTypes.FailureDetails?
        /// The input data config containing an S3 URI for the input manifest file that contains the list of fraudster registration job requests.
        public var inputDataConfig: VoiceIdClientTypes.InputDataConfig?
        /// The service-generated identifier for the fraudster registration job.
        public var jobId: Swift.String?
        /// The client-provied name for the fraudster registration job.
        public var jobName: Swift.String?
        /// Shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIdClientTypes.JobProgress?
        /// The current status of the fraudster registration job.
        public var jobStatus: VoiceIdClientTypes.FraudsterRegistrationJobStatus?
        /// The output data config containing the S3 location where you want Voice ID to write your job output file; you must also include a KMS Key ID in order to encrypt the file.
        public var outputDataConfig: VoiceIdClientTypes.OutputDataConfig?
        /// The registration config containing details such as the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster.
        public var registrationConfig: VoiceIdClientTypes.RegistrationConfig?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureDetails: VoiceIdClientTypes.FailureDetails? = nil,
            inputDataConfig: VoiceIdClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIdClientTypes.JobProgress? = nil,
            jobStatus: VoiceIdClientTypes.FraudsterRegistrationJobStatus? = nil,
            outputDataConfig: VoiceIdClientTypes.OutputDataConfig? = nil,
            registrationConfig: VoiceIdClientTypes.RegistrationConfig? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAccessRoleArn = dataAccessRoleArn
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
            self.outputDataConfig = outputDataConfig
            self.registrationConfig = registrationConfig
        }
    }

}

extension VoiceIdClientTypes {
    public enum FraudsterRegistrationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudsterRegistrationJobStatus] {
            return [
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudsterRegistrationJobStatus(rawValue: rawValue) ?? FraudsterRegistrationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.FraudsterRegistrationJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case failureDetails = "FailureDetails"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.timeIntervalSince1970, forKey: .endedAt)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudsterRegistrationJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIdClientTypes {
    /// Contains a summary of information about a fraudster registration job.
    public struct FraudsterRegistrationJobSummary: Swift.Equatable {
        /// A timestamp showing when the fraudster registration job is created.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the domain containing the fraudster registration job.
        public var domainId: Swift.String?
        /// A timestamp showing when the fraudster registration job ended.
        public var endedAt: ClientRuntime.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIdClientTypes.FailureDetails?
        /// The service-generated identifier for the fraudster registration job.
        public var jobId: Swift.String?
        /// The client-provied name for the fraudster registration job.
        public var jobName: Swift.String?
        /// Shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIdClientTypes.JobProgress?
        /// The current status of the fraudster registration job.
        public var jobStatus: VoiceIdClientTypes.FraudsterRegistrationJobStatus?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureDetails: VoiceIdClientTypes.FailureDetails? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIdClientTypes.JobProgress? = nil,
            jobStatus: VoiceIdClientTypes.FraudsterRegistrationJobStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
        }
    }

}

extension VoiceIdClientTypes.InputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension VoiceIdClientTypes {
    /// The configuration containing input file information for a batch job.
    public struct InputDataConfig: Swift.Equatable {
        /// The S3 location for the input manifest file that contains the list of individual enrollment or registration job requests.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed due to an unknown error on the server side.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIdClientTypes.JobProgress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentComplete = "PercentComplete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentComplete = percentComplete {
            try encodeContainer.encode(percentComplete, forKey: .percentComplete)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentCompleteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentComplete)
        percentComplete = percentCompleteDecoded
    }
}

extension VoiceIdClientTypes {
    /// Indicates the completion progress for a batch job.
    public struct JobProgress: Swift.Equatable {
        /// Shows the completed percentage of enrollment or registration requests listed in the input file.
        public var percentComplete: Swift.Int?

        public init (
            percentComplete: Swift.Int? = nil
        )
        {
            self.percentComplete = percentComplete
        }
    }

}

extension VoiceIdClientTypes.KnownFraudsterRisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedFraudsterId = "GeneratedFraudsterId"
        case riskScore = "RiskScore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedFraudsterId = generatedFraudsterId {
            try encodeContainer.encode(generatedFraudsterId, forKey: .generatedFraudsterId)
        }
        if let riskScore = riskScore {
            try encodeContainer.encode(riskScore, forKey: .riskScore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskScoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskScore)
        riskScore = riskScoreDecoded
        let generatedFraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFraudsterId)
        generatedFraudsterId = generatedFraudsterIdDecoded
    }
}

extension VoiceIdClientTypes {
    /// Contains details produced as a result of performing known fraudster risk analysis on a speaker.
    public struct KnownFraudsterRisk: Swift.Equatable {
        /// The identifier of the fraudster that is the closest match to the speaker. If there are no fraudsters registered in a given domain, or if there are no fraudsters with a non-zero RiskScore, this value is null.
        public var generatedFraudsterId: Swift.String?
        /// The score indicating the likelihood the speaker is a known fraudster.
        /// This member is required.
        public var riskScore: Swift.Int?

        public init (
            generatedFraudsterId: Swift.String? = nil,
            riskScore: Swift.Int? = nil
        )
        {
            self.generatedFraudsterId = generatedFraudsterId
            self.riskScore = riskScore
        }
    }

}

extension ListDomainsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListDomainsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        return items
    }
}

extension ListDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDomainsInput: Swift.Equatable {
    /// The maximum number of results that are returned per call. You can use NextToken to obtain further pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
}

extension ListDomainsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainSummaries = output.domainSummaries
            self.nextToken = output.nextToken
        } else {
            self.domainSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutputResponse: Swift.Equatable {
    /// A list containing details about each domain in the Amazon Web Services account.
    public var domainSummaries: [VoiceIdClientTypes.DomainSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        domainSummaries: [VoiceIdClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainSummaries = domainSummaries
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputResponseBody: Swift.Equatable {
    let domainSummaries: [VoiceIdClientTypes.DomainSummary]?
    let nextToken: Swift.String?
}

extension ListDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainSummaries = "DomainSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainSummariesContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.DomainSummary?].self, forKey: .domainSummaries)
        var domainSummariesDecoded0:[VoiceIdClientTypes.DomainSummary]? = nil
        if let domainSummariesContainer = domainSummariesContainer {
            domainSummariesDecoded0 = [VoiceIdClientTypes.DomainSummary]()
            for structure0 in domainSummariesContainer {
                if let structure0 = structure0 {
                    domainSummariesDecoded0?.append(structure0)
                }
            }
        }
        domainSummaries = domainSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFraudsterRegistrationJobsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListFraudsterRegistrationJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        return items
    }
}

extension ListFraudsterRegistrationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFraudsterRegistrationJobsInput: Swift.Equatable {
    /// The identifier of the domain containing the fraudster registration Jobs.
    /// This member is required.
    public var domainId: Swift.String?
    /// Provides the status of your fraudster registration job.
    public var jobStatus: VoiceIdClientTypes.FraudsterRegistrationJobStatus?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain further pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        jobStatus: VoiceIdClientTypes.FraudsterRegistrationJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFraudsterRegistrationJobsInputBody: Swift.Equatable {
}

extension ListFraudsterRegistrationJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFraudsterRegistrationJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFraudsterRegistrationJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFraudsterRegistrationJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFraudsterRegistrationJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFraudsterRegistrationJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListFraudsterRegistrationJobsOutputResponse: Swift.Equatable {
    /// A list containing details about each specified fraudster registration job.
    public var jobSummaries: [VoiceIdClientTypes.FraudsterRegistrationJobSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        jobSummaries: [VoiceIdClientTypes.FraudsterRegistrationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListFraudsterRegistrationJobsOutputResponseBody: Swift.Equatable {
    let jobSummaries: [VoiceIdClientTypes.FraudsterRegistrationJobSummary]?
    let nextToken: Swift.String?
}

extension ListFraudsterRegistrationJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummaries = "JobSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.FraudsterRegistrationJobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[VoiceIdClientTypes.FraudsterRegistrationJobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [VoiceIdClientTypes.FraudsterRegistrationJobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpeakerEnrollmentJobsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListSpeakerEnrollmentJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        return items
    }
}

extension ListSpeakerEnrollmentJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSpeakerEnrollmentJobsInput: Swift.Equatable {
    /// The identifier of the domain containing the speaker enrollment jobs.
    /// This member is required.
    public var domainId: Swift.String?
    /// Provides the status of your speaker enrollment Job.
    public var jobStatus: VoiceIdClientTypes.SpeakerEnrollmentJobStatus?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain further pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        jobStatus: VoiceIdClientTypes.SpeakerEnrollmentJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSpeakerEnrollmentJobsInputBody: Swift.Equatable {
}

extension ListSpeakerEnrollmentJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSpeakerEnrollmentJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSpeakerEnrollmentJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSpeakerEnrollmentJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSpeakerEnrollmentJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSpeakerEnrollmentJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListSpeakerEnrollmentJobsOutputResponse: Swift.Equatable {
    /// A list containing details about each specified speaker enrollment job.
    public var jobSummaries: [VoiceIdClientTypes.SpeakerEnrollmentJobSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        jobSummaries: [VoiceIdClientTypes.SpeakerEnrollmentJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListSpeakerEnrollmentJobsOutputResponseBody: Swift.Equatable {
    let jobSummaries: [VoiceIdClientTypes.SpeakerEnrollmentJobSummary]?
    let nextToken: Swift.String?
}

extension ListSpeakerEnrollmentJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummaries = "JobSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.SpeakerEnrollmentJobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[VoiceIdClientTypes.SpeakerEnrollmentJobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [VoiceIdClientTypes.SpeakerEnrollmentJobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpeakersInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListSpeakersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        return items
    }
}

extension ListSpeakersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSpeakersInput: Swift.Equatable {
    /// The identifier of the domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain further pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSpeakersInputBody: Swift.Equatable {
}

extension ListSpeakersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSpeakersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSpeakersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSpeakersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSpeakersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSpeakersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.speakerSummaries = output.speakerSummaries
        } else {
            self.nextToken = nil
            self.speakerSummaries = nil
        }
    }
}

public struct ListSpeakersOutputResponse: Swift.Equatable {
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?
    /// A list containing details about each speaker in the Amazon Web Services account.
    public var speakerSummaries: [VoiceIdClientTypes.SpeakerSummary]?

    public init (
        nextToken: Swift.String? = nil,
        speakerSummaries: [VoiceIdClientTypes.SpeakerSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.speakerSummaries = speakerSummaries
    }
}

struct ListSpeakersOutputResponseBody: Swift.Equatable {
    let speakerSummaries: [VoiceIdClientTypes.SpeakerSummary]?
    let nextToken: Swift.String?
}

extension ListSpeakersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case speakerSummaries = "SpeakerSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSummariesContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.SpeakerSummary?].self, forKey: .speakerSummaries)
        var speakerSummariesDecoded0:[VoiceIdClientTypes.SpeakerSummary]? = nil
        if let speakerSummariesContainer = speakerSummariesContainer {
            speakerSummariesDecoded0 = [VoiceIdClientTypes.SpeakerSummary]()
            for structure0 in speakerSummariesContainer {
                if let structure0 = structure0 {
                    speakerSummariesDecoded0?.append(structure0)
                }
            }
        }
        speakerSummaries = speakerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource for which you want to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags associated with the specified resource.
    public var tags: [VoiceIdClientTypes.Tag]?

    public init (
        tags: [VoiceIdClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [VoiceIdClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[VoiceIdClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [VoiceIdClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OptOutSpeakerInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension OptOutSpeakerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct OptOutSpeakerInput: Swift.Equatable {
    /// The identifier of the domain containing the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you want opted-out.
    /// This member is required.
    public var speakerId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

struct OptOutSpeakerInputBody: Swift.Equatable {
}

extension OptOutSpeakerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension OptOutSpeakerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension OptOutSpeakerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum OptOutSpeakerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension OptOutSpeakerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OptOutSpeakerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.speaker = output.speaker
        } else {
            self.speaker = nil
        }
    }
}

public struct OptOutSpeakerOutputResponse: Swift.Equatable {
    /// Details about the opted-out speaker.
    public var speaker: VoiceIdClientTypes.Speaker?

    public init (
        speaker: VoiceIdClientTypes.Speaker? = nil
    )
    {
        self.speaker = speaker
    }
}

struct OptOutSpeakerOutputResponseBody: Swift.Equatable {
    let speaker: VoiceIdClientTypes.Speaker?
}

extension OptOutSpeakerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speaker = "Speaker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.Speaker.self, forKey: .speaker)
        speaker = speakerDecoded
    }
}

extension VoiceIdClientTypes.OutputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension VoiceIdClientTypes {
    /// The configuration containing output file information for a batch job.
    public struct OutputDataConfig: Swift.Equatable {
        /// the identifier of the KMS key you want Voice ID to use to encrypt the output file of the fraudster registration job.
        public var kmsKeyId: Swift.String?
        /// The S3 path of the folder to which Voice ID writes the job output file, which has a *.out extension. For example, if the input file name is input-file.json and the output folder path is s3://output-bucket/output-folder, the full output file path is s3://output-bucket/output-folder/job-Id/input-file.json.out.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }

}

extension VoiceIdClientTypes.RegistrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duplicateRegistrationAction = "DuplicateRegistrationAction"
        case fraudsterSimilarityThreshold = "FraudsterSimilarityThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duplicateRegistrationAction = duplicateRegistrationAction {
            try encodeContainer.encode(duplicateRegistrationAction.rawValue, forKey: .duplicateRegistrationAction)
        }
        if let fraudsterSimilarityThreshold = fraudsterSimilarityThreshold {
            try encodeContainer.encode(fraudsterSimilarityThreshold, forKey: .fraudsterSimilarityThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let duplicateRegistrationActionDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.DuplicateRegistrationAction.self, forKey: .duplicateRegistrationAction)
        duplicateRegistrationAction = duplicateRegistrationActionDecoded
        let fraudsterSimilarityThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fraudsterSimilarityThreshold)
        fraudsterSimilarityThreshold = fraudsterSimilarityThresholdDecoded
    }
}

extension VoiceIdClientTypes {
    /// The configuration definining the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster during a batch fraudster registration job.
    public struct RegistrationConfig: Swift.Equatable {
        /// The action to take when a fraudster is identified as a duplicate. The default action is SKIP, which skips registering the duplicate fraudster. Setting the value to REGISTER_AS_NEW always registers a new fraudster into the specified domain.
        public var duplicateRegistrationAction: VoiceIdClientTypes.DuplicateRegistrationAction?
        /// The minimum similarity score between the new and old fraudsters in order to consider the new fraudster a duplicate.
        public var fraudsterSimilarityThreshold: Swift.Int?

        public init (
            duplicateRegistrationAction: VoiceIdClientTypes.DuplicateRegistrationAction? = nil,
            fraudsterSimilarityThreshold: Swift.Int? = nil
        )
        {
            self.duplicateRegistrationAction = duplicateRegistrationAction
            self.fraudsterSimilarityThreshold = fraudsterSimilarityThreshold
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource cannot be found. Check the ResourceType and error message for more details.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The type of resource which cannot not be found. Possible types are BATCH_JOB, COMPLIANCE_CONSENT, DOMAIN, FRAUDSTER, SESSION and SPEAKER.
    public var resourceType: VoiceIdClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceType: VoiceIdClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: VoiceIdClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension VoiceIdClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case batchJob
        case complianceConsent
        case domain
        case fraudster
        case session
        case speaker
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .batchJob,
                .complianceConsent,
                .domain,
                .fraudster,
                .session,
                .speaker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .batchJob: return "BATCH_JOB"
            case .complianceConsent: return "COMPLIANCE_CONSENT"
            case .domain: return "DOMAIN"
            case .fraudster: return "FRAUDSTER"
            case .session: return "SESSION"
            case .speaker: return "SPEAKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.ServerSideEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension VoiceIdClientTypes {
    /// The configuration containing information about the customer-managed KMS Key used for encrypting customer data.
    public struct ServerSideEncryptionConfiguration: Swift.Equatable {
        /// The identifier of the KMS Key you want Voice ID to use to encrypt your data.
        /// This member is required.
        public var kmsKeyId: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeded the service quota. Refer to [Voice ID Service Quotas](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#voiceid-quotas) and try your request again.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIdClientTypes.Speaker: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case customerSpeakerId = "CustomerSpeakerId"
        case domainId = "DomainId"
        case generatedSpeakerId = "GeneratedSpeakerId"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let customerSpeakerId = customerSpeakerId {
            try encodeContainer.encode(customerSpeakerId, forKey: .customerSpeakerId)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedSpeakerId = generatedSpeakerId {
            try encodeContainer.encode(generatedSpeakerId, forKey: .generatedSpeakerId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let customerSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerSpeakerId)
        customerSpeakerId = customerSpeakerIdDecoded
        let generatedSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedSpeakerId)
        generatedSpeakerId = generatedSpeakerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.SpeakerStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension VoiceIdClientTypes {
    /// Contains all the information about a speaker.
    public struct Speaker: Swift.Equatable {
        /// A timestamp showing when the speaker is created.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided identifier for the speaker.
        public var customerSpeakerId: Swift.String?
        /// The identifier of the domain that contains the speaker.
        public var domainId: Swift.String?
        /// The service-generated identifier for the speaker.
        public var generatedSpeakerId: Swift.String?
        /// The current status of the speaker.
        public var status: VoiceIdClientTypes.SpeakerStatus?
        /// A timestamp showing the speaker's last update.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            customerSpeakerId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            generatedSpeakerId: Swift.String? = nil,
            status: VoiceIdClientTypes.SpeakerStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.customerSpeakerId = customerSpeakerId
            self.domainId = domainId
            self.generatedSpeakerId = generatedSpeakerId
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension VoiceIdClientTypes.SpeakerEnrollmentJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case enrollmentConfig = "EnrollmentConfig"
        case failureDetails = "FailureDetails"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.timeIntervalSince1970, forKey: .endedAt)
        }
        if let enrollmentConfig = enrollmentConfig {
            try encodeContainer.encode(enrollmentConfig, forKey: .enrollmentConfig)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.SpeakerEnrollmentJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let enrollmentConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.EnrollmentConfig.self, forKey: .enrollmentConfig)
        enrollmentConfig = enrollmentConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIdClientTypes {
    /// Contains all the information about a speaker enrollment job.
    public struct SpeakerEnrollmentJob: Swift.Equatable {
        /// A timestamp showing the creation of the speaker enrollment job.
        public var createdAt: ClientRuntime.Date?
        /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.
        public var dataAccessRoleArn: Swift.String?
        /// The identifier of the domain that contains the speaker enrollment job.
        public var domainId: Swift.String?
        /// A timestamp showing when the speaker enrollment job ended.
        public var endedAt: ClientRuntime.Date?
        /// The configuration that defines the action to take when the speaker is already enrolled in Voice ID, and the FraudDetectionConfig to use.
        public var enrollmentConfig: VoiceIdClientTypes.EnrollmentConfig?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIdClientTypes.FailureDetails?
        /// The input data config containing an S3 URI for the input manifest file that contains the list of speaker enrollment job requests.
        public var inputDataConfig: VoiceIdClientTypes.InputDataConfig?
        /// The service-generated identifier for the speaker enrollment job.
        public var jobId: Swift.String?
        /// The client-provided name for the speaker enrollment job.
        public var jobName: Swift.String?
        /// Provides details on job progress. This field shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIdClientTypes.JobProgress?
        /// The current status of the speaker enrollment job.
        public var jobStatus: VoiceIdClientTypes.SpeakerEnrollmentJobStatus?
        /// The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS Key ID to encrypt the file.
        public var outputDataConfig: VoiceIdClientTypes.OutputDataConfig?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            enrollmentConfig: VoiceIdClientTypes.EnrollmentConfig? = nil,
            failureDetails: VoiceIdClientTypes.FailureDetails? = nil,
            inputDataConfig: VoiceIdClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIdClientTypes.JobProgress? = nil,
            jobStatus: VoiceIdClientTypes.SpeakerEnrollmentJobStatus? = nil,
            outputDataConfig: VoiceIdClientTypes.OutputDataConfig? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAccessRoleArn = dataAccessRoleArn
            self.domainId = domainId
            self.endedAt = endedAt
            self.enrollmentConfig = enrollmentConfig
            self.failureDetails = failureDetails
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
            self.outputDataConfig = outputDataConfig
        }
    }

}

extension VoiceIdClientTypes {
    public enum SpeakerEnrollmentJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeakerEnrollmentJobStatus] {
            return [
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpeakerEnrollmentJobStatus(rawValue: rawValue) ?? SpeakerEnrollmentJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.SpeakerEnrollmentJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case failureDetails = "FailureDetails"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.timeIntervalSince1970, forKey: .endedAt)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.SpeakerEnrollmentJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIdClientTypes {
    /// Contains a summary of information about a speaker enrollment job.
    public struct SpeakerEnrollmentJobSummary: Swift.Equatable {
        /// A timestamp showing the creation time of the speaker enrollment job.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the domain that contains the speaker enrollment job.
        public var domainId: Swift.String?
        /// A timestamp showing when the speaker enrollment job ended.
        public var endedAt: ClientRuntime.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIdClientTypes.FailureDetails?
        /// The service-generated identifier for the speaker enrollment job.
        public var jobId: Swift.String?
        /// The client-provided name for the speaker enrollment job.
        public var jobName: Swift.String?
        /// Provides details regarding job progress. This field shows the completed percentage of enrollment requests listed in the input file.
        public var jobProgress: VoiceIdClientTypes.JobProgress?
        /// The current status of the speaker enrollment job.
        public var jobStatus: VoiceIdClientTypes.SpeakerEnrollmentJobStatus?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureDetails: VoiceIdClientTypes.FailureDetails? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIdClientTypes.JobProgress? = nil,
            jobStatus: VoiceIdClientTypes.SpeakerEnrollmentJobStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
        }
    }

}

extension VoiceIdClientTypes {
    public enum SpeakerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enrolled
        case expired
        case optedOut
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeakerStatus] {
            return [
                .enrolled,
                .expired,
                .optedOut,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enrolled: return "ENROLLED"
            case .expired: return "EXPIRED"
            case .optedOut: return "OPTED_OUT"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpeakerStatus(rawValue: rawValue) ?? SpeakerStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.SpeakerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case customerSpeakerId = "CustomerSpeakerId"
        case domainId = "DomainId"
        case generatedSpeakerId = "GeneratedSpeakerId"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let customerSpeakerId = customerSpeakerId {
            try encodeContainer.encode(customerSpeakerId, forKey: .customerSpeakerId)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedSpeakerId = generatedSpeakerId {
            try encodeContainer.encode(generatedSpeakerId, forKey: .generatedSpeakerId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let customerSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerSpeakerId)
        customerSpeakerId = customerSpeakerIdDecoded
        let generatedSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedSpeakerId)
        generatedSpeakerId = generatedSpeakerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.SpeakerStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension VoiceIdClientTypes {
    /// Contains a summary of information about a speaker.
    public struct SpeakerSummary: Swift.Equatable {
        /// A timestamp showing the speaker's creation time.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided identifier for the speaker.
        public var customerSpeakerId: Swift.String?
        /// The identifier of the domain that contains the speaker.
        public var domainId: Swift.String?
        /// The service-generated identifier for the speaker.
        public var generatedSpeakerId: Swift.String?
        /// The current status of the speaker.
        public var status: VoiceIdClientTypes.SpeakerStatus?
        /// A timestamp showing the speaker's last update.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            customerSpeakerId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            generatedSpeakerId: Swift.String? = nil,
            status: VoiceIdClientTypes.SpeakerStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.customerSpeakerId = customerSpeakerId
            self.domainId = domainId
            self.generatedSpeakerId = generatedSpeakerId
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension StartFraudsterRegistrationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case registrationConfig = "RegistrationConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let registrationConfig = registrationConfig {
            try encodeContainer.encode(registrationConfig, forKey: .registrationConfig)
        }
    }
}

extension StartFraudsterRegistrationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartFraudsterRegistrationJobInput: Swift.Equatable {
    /// The idempotency token for starting a new fraudster registration job. If not provided, Amazon Web Services SDK populates this field.
    public var clientToken: Swift.String?
    /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the Job output file. Refer to the [Create and edit a fraudster watchlist](https://docs.aws.amazon.com/connect/latest/adminguide/voiceid-fraudster-watchlist.html) documentation for the permissions needed in this role.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The identifier of the domain containing the fraudster registration job and in which the fraudsters are registered.
    /// This member is required.
    public var domainId: Swift.String?
    /// The input data config containing an S3 URI for the input manifest file that contains the list of fraudster registration requests.
    /// This member is required.
    public var inputDataConfig: VoiceIdClientTypes.InputDataConfig?
    /// The name of the new fraudster registration job.
    public var jobName: Swift.String?
    /// The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS Key ID to encrypt the file.
    /// This member is required.
    public var outputDataConfig: VoiceIdClientTypes.OutputDataConfig?
    /// The registration config containing details such as the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster.
    public var registrationConfig: VoiceIdClientTypes.RegistrationConfig?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        inputDataConfig: VoiceIdClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: VoiceIdClientTypes.OutputDataConfig? = nil,
        registrationConfig: VoiceIdClientTypes.RegistrationConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.domainId = domainId
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.registrationConfig = registrationConfig
    }
}

struct StartFraudsterRegistrationJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let jobName: Swift.String?
    let dataAccessRoleArn: Swift.String?
    let registrationConfig: VoiceIdClientTypes.RegistrationConfig?
    let inputDataConfig: VoiceIdClientTypes.InputDataConfig?
    let outputDataConfig: VoiceIdClientTypes.OutputDataConfig?
}

extension StartFraudsterRegistrationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case registrationConfig = "RegistrationConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let registrationConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
    }
}

extension StartFraudsterRegistrationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFraudsterRegistrationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFraudsterRegistrationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFraudsterRegistrationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartFraudsterRegistrationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartFraudsterRegistrationJobOutputResponse: Swift.Equatable {
    /// Details about the started fraudster registration job.
    public var job: VoiceIdClientTypes.FraudsterRegistrationJob?

    public init (
        job: VoiceIdClientTypes.FraudsterRegistrationJob? = nil
    )
    {
        self.job = job
    }
}

struct StartFraudsterRegistrationJobOutputResponseBody: Swift.Equatable {
    let job: VoiceIdClientTypes.FraudsterRegistrationJob?
}

extension StartFraudsterRegistrationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudsterRegistrationJob.self, forKey: .job)
        job = jobDecoded
    }
}

extension StartSpeakerEnrollmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case enrollmentConfig = "EnrollmentConfig"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let enrollmentConfig = enrollmentConfig {
            try encodeContainer.encode(enrollmentConfig, forKey: .enrollmentConfig)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartSpeakerEnrollmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSpeakerEnrollmentJobInput: Swift.Equatable {
    /// The idempotency token for starting a new speaker enrollment Job. If not provided, Amazon Web Services SDK populates this field.
    public var clientToken: Swift.String?
    /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file. Refer to [Batch enrollment using audio data from prior calls](https://docs.aws.amazon.com/connect/latest/adminguide/voiceid-batch-enrollment.html) documentation for the permissions needed in this role.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The identifier of the domain that contains the speaker enrollment job and in which the speakers are enrolled.
    /// This member is required.
    public var domainId: Swift.String?
    /// The enrollment config that contains details such as the action to take when a speaker is already enrolled in the Voice ID system or when a speaker is identified as a fraudster.
    public var enrollmentConfig: VoiceIdClientTypes.EnrollmentConfig?
    /// The input data config containing the S3 location for the input manifest file that contains the list of speaker enrollment requests.
    /// This member is required.
    public var inputDataConfig: VoiceIdClientTypes.InputDataConfig?
    /// A name for your speaker enrollment job.
    public var jobName: Swift.String?
    /// The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS Key ID to encrypt the file.
    /// This member is required.
    public var outputDataConfig: VoiceIdClientTypes.OutputDataConfig?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enrollmentConfig: VoiceIdClientTypes.EnrollmentConfig? = nil,
        inputDataConfig: VoiceIdClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: VoiceIdClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.domainId = domainId
        self.enrollmentConfig = enrollmentConfig
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
    }
}

struct StartSpeakerEnrollmentJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let jobName: Swift.String?
    let dataAccessRoleArn: Swift.String?
    let enrollmentConfig: VoiceIdClientTypes.EnrollmentConfig?
    let inputDataConfig: VoiceIdClientTypes.InputDataConfig?
    let outputDataConfig: VoiceIdClientTypes.OutputDataConfig?
}

extension StartSpeakerEnrollmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case enrollmentConfig = "EnrollmentConfig"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let enrollmentConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.EnrollmentConfig.self, forKey: .enrollmentConfig)
        enrollmentConfig = enrollmentConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
    }
}

extension StartSpeakerEnrollmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSpeakerEnrollmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSpeakerEnrollmentJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSpeakerEnrollmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSpeakerEnrollmentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartSpeakerEnrollmentJobOutputResponse: Swift.Equatable {
    /// Details about the started speaker enrollment job.
    public var job: VoiceIdClientTypes.SpeakerEnrollmentJob?

    public init (
        job: VoiceIdClientTypes.SpeakerEnrollmentJob? = nil
    )
    {
        self.job = job
    }
}

struct StartSpeakerEnrollmentJobOutputResponseBody: Swift.Equatable {
    let job: VoiceIdClientTypes.SpeakerEnrollmentJob?
}

extension StartSpeakerEnrollmentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.SpeakerEnrollmentJob.self, forKey: .job)
        job = jobDecoded
    }
}

extension VoiceIdClientTypes {
    public enum StreamingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ended
        case ongoing
        case pendingConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingStatus] {
            return [
                .ended,
                .ongoing,
                .pendingConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ended: return "ENDED"
            case .ongoing: return "ONGOING"
            case .pendingConfiguration: return "PENDING_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingStatus(rawValue: rawValue) ?? StreamingStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension VoiceIdClientTypes {
    /// A tag that can be assigned to a Voice ID resource.
    public struct Tag: Swift.Equatable {
        /// The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag ‘Department’:’Sales’, the key is 'Department'.
        /// This member is required.
        public var key: Swift.String?
        /// The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag ‘Department’:’Sales’, the value is 'Sales'.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags to assign to the specified resource.
    /// This member is required.
    public var tags: [VoiceIdClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [VoiceIdClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [VoiceIdClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[VoiceIdClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [VoiceIdClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling. Please slow down your request rate. Refer to [ Amazon Connect Voice ID Service API throttling quotas ](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html##voiceid-api-quotas) and try your request again.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource you want to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
    }
}

extension UpdateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDomainInput: Swift.Equatable {
    /// A brief description about this domain.
    public var description: Swift.String?
    /// The identifier of the domain to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration, containing the KMS Key Identifier, to be used by Voice ID for the server-side encryption of your data. Note that all the existing data in the domain are still encrypted using the existing key, only the data added to domain after updating the key is encrypted using the new key.
    /// This member is required.
    public var serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration?

    public init (
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
    }
}

struct UpdateDomainInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration?
}

extension UpdateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension UpdateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct UpdateDomainOutputResponse: Swift.Equatable {
    /// Details about the updated domain
    public var domain: VoiceIdClientTypes.Domain?

    public init (
        domain: VoiceIdClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

struct UpdateDomainOutputResponseBody: Swift.Equatable {
    let domain: VoiceIdClientTypes.Domain?
}

extension UpdateDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed one or more validations; check the error message for more details.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
