// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListHealthChecksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListHealthChecksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListHealthChecksOutputResponse`
extension Route53Client {
    public func listHealthChecksPaginated(input: ListHealthChecksInput) -> ClientRuntime.PaginatorSequence<ListHealthChecksInput, ListHealthChecksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListHealthChecksInput, ListHealthChecksOutputResponse>(input: input, inputKey: \ListHealthChecksInput.marker, outputKey: \ListHealthChecksOutputResponse.nextMarker, paginationFunction: self.listHealthChecks(input:))
    }
}

extension ListHealthChecksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHealthChecksInput {
        return ListHealthChecksInput(
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listHealthChecksPaginated`
/// to access the nested member `[Route53ClientTypes.HealthCheck]`
/// - Returns: `[Route53ClientTypes.HealthCheck]`
extension PaginatorSequence where Input == ListHealthChecksInput, Output == ListHealthChecksOutputResponse {
    func healthChecks() async throws -> [Route53ClientTypes.HealthCheck] {
        return try await self.asyncCompactMap { item in item.healthChecks }
    }
}

/// Paginate over `[ListHostedZonesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListHostedZonesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListHostedZonesOutputResponse`
extension Route53Client {
    public func listHostedZonesPaginated(input: ListHostedZonesInput) -> ClientRuntime.PaginatorSequence<ListHostedZonesInput, ListHostedZonesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListHostedZonesInput, ListHostedZonesOutputResponse>(input: input, inputKey: \ListHostedZonesInput.marker, outputKey: \ListHostedZonesOutputResponse.nextMarker, paginationFunction: self.listHostedZones(input:))
    }
}

extension ListHostedZonesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHostedZonesInput {
        return ListHostedZonesInput(
            delegationSetId: self.delegationSetId,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listHostedZonesPaginated`
/// to access the nested member `[Route53ClientTypes.HostedZone]`
/// - Returns: `[Route53ClientTypes.HostedZone]`
extension PaginatorSequence where Input == ListHostedZonesInput, Output == ListHostedZonesOutputResponse {
    func hostedZones() async throws -> [Route53ClientTypes.HostedZone] {
        return try await self.asyncCompactMap { item in item.hostedZones }
    }
}

/// Paginate over `[ListQueryLoggingConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListQueryLoggingConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListQueryLoggingConfigsOutputResponse`
extension Route53Client {
    public func listQueryLoggingConfigsPaginated(input: ListQueryLoggingConfigsInput) -> ClientRuntime.PaginatorSequence<ListQueryLoggingConfigsInput, ListQueryLoggingConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListQueryLoggingConfigsInput, ListQueryLoggingConfigsOutputResponse>(input: input, inputKey: \ListQueryLoggingConfigsInput.nextToken, outputKey: \ListQueryLoggingConfigsOutputResponse.nextToken, paginationFunction: self.listQueryLoggingConfigs(input:))
    }
}

extension ListQueryLoggingConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQueryLoggingConfigsInput {
        return ListQueryLoggingConfigsInput(
            hostedZoneId: self.hostedZoneId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listQueryLoggingConfigsPaginated`
/// to access the nested member `[Route53ClientTypes.QueryLoggingConfig]`
/// - Returns: `[Route53ClientTypes.QueryLoggingConfig]`
extension PaginatorSequence where Input == ListQueryLoggingConfigsInput, Output == ListQueryLoggingConfigsOutputResponse {
    func queryLoggingConfigs() async throws -> [Route53ClientTypes.QueryLoggingConfig] {
        return try await self.asyncCompactMap { item in item.queryLoggingConfigs }
    }
}
