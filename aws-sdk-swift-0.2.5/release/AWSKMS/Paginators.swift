// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListAliasesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAliasesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAliasesOutputResponse`
extension KmsClient {
    public func listAliasesPaginated(input: ListAliasesInput) -> ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutputResponse>(input: input, inputKey: \ListAliasesInput.marker, outputKey: \ListAliasesOutputResponse.nextMarker, paginationFunction: self.listAliases(input:))
    }
}

extension ListAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAliasesInput {
        return ListAliasesInput(
            keyId: self.keyId,
            limit: self.limit,
            marker: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAliasesPaginated`
/// to access the nested member `[KmsClientTypes.AliasListEntry]`
/// - Returns: `[KmsClientTypes.AliasListEntry]`
extension PaginatorSequence where Input == ListAliasesInput, Output == ListAliasesOutputResponse {
    func aliases() async throws -> [KmsClientTypes.AliasListEntry] {
        return try await self.asyncCompactMap { item in item.aliases }
    }
}

/// Paginate over `[ListGrantsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListGrantsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListGrantsOutputResponse`
extension KmsClient {
    public func listGrantsPaginated(input: ListGrantsInput) -> ClientRuntime.PaginatorSequence<ListGrantsInput, ListGrantsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListGrantsInput, ListGrantsOutputResponse>(input: input, inputKey: \ListGrantsInput.marker, outputKey: \ListGrantsOutputResponse.nextMarker, paginationFunction: self.listGrants(input:))
    }
}

extension ListGrantsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGrantsInput {
        return ListGrantsInput(
            grantId: self.grantId,
            granteePrincipal: self.granteePrincipal,
            keyId: self.keyId,
            limit: self.limit,
            marker: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listGrantsPaginated`
/// to access the nested member `[KmsClientTypes.GrantListEntry]`
/// - Returns: `[KmsClientTypes.GrantListEntry]`
extension PaginatorSequence where Input == ListGrantsInput, Output == ListGrantsOutputResponse {
    func grants() async throws -> [KmsClientTypes.GrantListEntry] {
        return try await self.asyncCompactMap { item in item.grants }
    }
}

/// Paginate over `[ListKeyPoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListKeyPoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListKeyPoliciesOutputResponse`
extension KmsClient {
    public func listKeyPoliciesPaginated(input: ListKeyPoliciesInput) -> ClientRuntime.PaginatorSequence<ListKeyPoliciesInput, ListKeyPoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListKeyPoliciesInput, ListKeyPoliciesOutputResponse>(input: input, inputKey: \ListKeyPoliciesInput.marker, outputKey: \ListKeyPoliciesOutputResponse.nextMarker, paginationFunction: self.listKeyPolicies(input:))
    }
}

extension ListKeyPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListKeyPoliciesInput {
        return ListKeyPoliciesInput(
            keyId: self.keyId,
            limit: self.limit,
            marker: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listKeyPoliciesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListKeyPoliciesInput, Output == ListKeyPoliciesOutputResponse {
    func policyNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.policyNames }
    }
}

/// Paginate over `[ListKeysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListKeysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListKeysOutputResponse`
extension KmsClient {
    public func listKeysPaginated(input: ListKeysInput) -> ClientRuntime.PaginatorSequence<ListKeysInput, ListKeysOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListKeysInput, ListKeysOutputResponse>(input: input, inputKey: \ListKeysInput.marker, outputKey: \ListKeysOutputResponse.nextMarker, paginationFunction: self.listKeys(input:))
    }
}

extension ListKeysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListKeysInput {
        return ListKeysInput(
            limit: self.limit,
            marker: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listKeysPaginated`
/// to access the nested member `[KmsClientTypes.KeyListEntry]`
/// - Returns: `[KmsClientTypes.KeyListEntry]`
extension PaginatorSequence where Input == ListKeysInput, Output == ListKeysOutputResponse {
    func keys() async throws -> [KmsClientTypes.KeyListEntry] {
        return try await self.asyncCompactMap { item in item.keys }
    }
}
