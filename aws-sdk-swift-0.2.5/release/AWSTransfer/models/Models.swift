// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the UpdateServer is called for a file transfer protocol-enabled server that has VPC as the endpoint type and the server's VpcEndpointID is not in the available state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferClientTypes.CopyStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationFileLocation = "DestinationFileLocation"
        case name = "Name"
        case overwriteExisting = "OverwriteExisting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationFileLocation = destinationFileLocation {
            try encodeContainer.encode(destinationFileLocation, forKey: .destinationFileLocation)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overwriteExisting = overwriteExisting {
            try encodeContainer.encode(overwriteExisting.rawValue, forKey: .overwriteExisting)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.InputFileLocation.self, forKey: .destinationFileLocation)
        destinationFileLocation = destinationFileLocationDecoded
        let overwriteExistingDecoded = try containerValues.decodeIfPresent(TransferClientTypes.OverwriteExisting.self, forKey: .overwriteExisting)
        overwriteExisting = overwriteExistingDecoded
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure.
    public struct CopyStepDetails: Swift.Equatable {
        /// Specifies the location for the file being copied. Only applicable for the Copy type of workflow steps.
        public var destinationFileLocation: TransferClientTypes.InputFileLocation?
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE.
        public var overwriteExisting: TransferClientTypes.OverwriteExisting?

        public init (
            destinationFileLocation: TransferClientTypes.InputFileLocation? = nil,
            name: Swift.String? = nil,
            overwriteExisting: TransferClientTypes.OverwriteExisting? = nil
        )
        {
            self.destinationFileLocation = destinationFileLocation
            self.name = name
            self.overwriteExisting = overwriteExisting
        }
    }

}

extension CreateAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension CreateAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAccessInput: Swift.Equatable {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity and Access Management (IAM) role provides access to paths in Target. This value can only be set when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock down your user to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ] If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place holders for your directory. If using the CLI, use the s3api or efsapi call instead of s3 or efs so you can use the put-object operation. For example, you use the following: aws s3api put-object --bucket bucketname --key path/to/folder/. Make sure that the end of the key name ends in a / for it to be considered a folder.
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) you want your users' home directory to be when they log into the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or EFS paths visible to your users.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This only applies when the domain of ServerId is S3. EFS does not use session policies. For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument.
    ///
    ///
    /// For an example of a session policy, see [Example session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web Services Security Token Service API Reference.
    public var policy: Swift.String?
    /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    /// This member is required.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
    }
}

struct CreateAccessInputBody: Swift.Equatable {
    let homeDirectory: Swift.String?
    let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    let policy: Swift.String?
    let posixProfile: TransferClientTypes.PosixProfile?
    let role: Swift.String?
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension CreateAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension CreateAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.externalId = output.externalId
            self.serverId = output.serverId
        } else {
            self.externalId = nil
            self.serverId = nil
        }
    }
}

public struct CreateAccessOutputResponse: Swift.Equatable {
    /// The external ID of the group whose users have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Amazon Web Services Transfer Family.
    /// This member is required.
    public var externalId: Swift.String?
    /// The ID of the server that the user is attached to.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct CreateAccessOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension CreateAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension CreateServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case tags = "Tags"
        case workflowDetails = "WorkflowDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointDetails = endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKey = hostKey {
            try encodeContainer.encode(hostKey, forKey: .hostKey)
        }
        if let identityProviderDetails = identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let workflowDetails = workflowDetails {
            try encodeContainer.encode(workflowDetails, forKey: .workflowDetails)
        }
    }
}

extension CreateServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Web Services Certificate Manager (ACM) certificate. Required when Protocols is set to FTPS. To request a new public certificate, see [Request a public certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) in the Amazon Web Services Certificate Manager User Guide. To import an existing certificate into ACM, see [Importing certificates into ACM](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the Amazon Web Services Certificate Manager User Guide. To request a private certificate to use FTPS through private IP addresses, see [Request a private certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html) in the Amazon Web Services Certificate Manager User Guide. Certificates with the following cryptographic algorithms and key sizes are supported:
    ///
    /// * 2048-bit RSA (RSA_2048)
    ///
    /// * 4096-bit RSA (RSA_4096)
    ///
    /// * Elliptic Prime Curve 256 bit (EC_prime256v1)
    ///
    /// * Elliptic Prime Curve 384 bit (EC_secp384r1)
    ///
    /// * Elliptic Prime Curve 521 bit (EC_secp521r1)
    ///
    ///
    /// The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP address specified and information about the issuer.
    public var certificate: Swift.String?
    /// The domain of the storage system that is used for file transfers. There are two domains available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The default value is S3. After the server is created, the domain cannot be changed.
    public var domain: TransferClientTypes.Domain?
    /// The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make it accessible only to resources within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
    public var endpointDetails: TransferClientTypes.EndpointDetails?
    /// The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC) or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it. After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Services account if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Services account on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint. It is recommended that you use VPC as the EndpointType. With this endpoint type, you have the option to directly associate up to three Elastic IPv4 addresses (BYO IP included) with your server's endpoint and use VPC security groups to restrict traffic by the client's public IP address. This is not possible with EndpointType set to VPC_ENDPOINT.
    public var endpointType: TransferClientTypes.EndpointType?
    /// The RSA private key as generated by the ssh-keygen -N "" -m PEM -f my-new-server-key command. If you aren't planning to migrate existing users from an existing SFTP-enabled server to a new server, don't update the host key. Accidentally changing a server's host key can be disruptive. For more information, see [Change the host key for your SFTP-enabled server](https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key) in the Amazon Web Services Transfer Family User Guide.
    public var hostKey: Swift.String?
    /// Required when IdentityProviderType is set to AWS_DIRECTORY_SERVICE or API_GATEWAY. Accepts an array containing all of the information required to use a directory in AWS_DIRECTORY_SERVICE or invoke a customer-supplied authentication API, including the API Gateway URL. Not required when IdentityProviderType is set to SERVICE_MANAGED.
    public var identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    /// Specifies the mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Amazon Web Services Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to provide a Directory ID using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an API Gateway endpoint URL to call for authentication using the IdentityProviderDetails parameter. Use the LAMBDA value to directly use a Lambda function as your identity provider. If you choose this value, you must specify the ARN for the lambda function in the Function parameter for the IdentityProviderDetails data type.
    public var identityProviderType: TransferClientTypes.IdentityProviderType?
    /// Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
    ///
    /// * SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH
    ///
    /// * FTPS (File Transfer Protocol Secure): File transfer with TLS encryption
    ///
    /// * FTP (File Transfer Protocol): Unencrypted file transfer
    ///
    ///
    /// If you select FTPS, you must choose a certificate stored in Amazon Web Services Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS. If Protocol includes either FTP or FTPS, then the EndpointType must be VPC and the IdentityProviderType must be AWS_DIRECTORY_SERVICE or API_GATEWAY. If Protocol includes FTP, then AddressAllocationIds cannot be associated. If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the IdentityProviderType can be set to SERVICE_MANAGED.
    public var protocols: [TransferClientTypes.ModelProtocol]?
    /// Specifies the name of the security policy that is attached to the server.
    public var securityPolicyName: Swift.String?
    /// Key-value pairs that can be used to group and search for servers.
    public var tags: [TransferClientTypes.Tag]?
    /// Specifies the workflow ID for the workflow to assign and the execution role used for executing the workflow.
    public var workflowDetails: TransferClientTypes.WorkflowDetails?

    public init (
        certificate: Swift.String? = nil,
        domain: TransferClientTypes.Domain? = nil,
        endpointDetails: TransferClientTypes.EndpointDetails? = nil,
        endpointType: TransferClientTypes.EndpointType? = nil,
        hostKey: Swift.String? = nil,
        identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
        identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
        loggingRole: Swift.String? = nil,
        protocols: [TransferClientTypes.ModelProtocol]? = nil,
        securityPolicyName: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        workflowDetails: TransferClientTypes.WorkflowDetails? = nil
    )
    {
        self.certificate = certificate
        self.domain = domain
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKey = hostKey
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderType = identityProviderType
        self.loggingRole = loggingRole
        self.protocols = protocols
        self.securityPolicyName = securityPolicyName
        self.tags = tags
        self.workflowDetails = workflowDetails
    }
}

struct CreateServerInputBody: Swift.Equatable {
    let certificate: Swift.String?
    let domain: TransferClientTypes.Domain?
    let endpointDetails: TransferClientTypes.EndpointDetails?
    let endpointType: TransferClientTypes.EndpointType?
    let hostKey: Swift.String?
    let identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    let identityProviderType: TransferClientTypes.IdentityProviderType?
    let loggingRole: Swift.String?
    let protocols: [TransferClientTypes.ModelProtocol]?
    let securityPolicyName: Swift.String?
    let tags: [TransferClientTypes.Tag]?
    let workflowDetails: TransferClientTypes.WorkflowDetails?
}

extension CreateServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case tags = "Tags"
        case workflowDetails = "WorkflowDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let domainDecoded = try containerValues.decodeIfPresent(TransferClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKey)
        hostKey = hostKeyDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.ModelProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let workflowDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowDetails.self, forKey: .workflowDetails)
        workflowDetails = workflowDetailsDecoded
    }
}

extension CreateServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
        } else {
            self.serverId = nil
        }
    }
}

public struct CreateServerOutputResponse: Swift.Equatable {
    /// The service-assigned ID of the server that is created.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct CreateServerOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension CreateServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyBody = sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity and Access Management (IAM) role provides access to paths in Target. This value can only be set when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock your user down to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ] If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place holders for your directory. If using the CLI, use the s3api or efsapi call instead of s3 or efs so you can use the put-object operation. For example, you use the following: aws s3api put-object --bucket bucketname --key path/to/folder/. Make sure that the end of the key name ends in a / for it to be considered a folder.
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) you want your users' home directory to be when they log into the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or EFS paths visible to your users.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This only applies when the domain of ServerId is S3. EFS does not use session policies. For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Example session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web Services Security Token Service API Reference.
    public var policy: Swift.String?
    /// Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in Amazon EFS determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    /// This member is required.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
    /// This member is required.
    public var serverId: Swift.String?
    /// The public portion of the Secure Shell (SSH) key used to authenticate the user to the server.
    public var sshPublicKeyBody: Swift.String?
    /// Key-value pairs that can be used to group and search for users. Tags are metadata attached to users for any purpose.
    public var tags: [TransferClientTypes.Tag]?
    /// A unique string that identifies a user and is associated with a ServerId. This user name must be a minimum of 3 and a maximum of 100 characters long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen '-', period '.', and at sign '@'. The user name can't start with a hyphen, period, or at sign.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil,
        sshPublicKeyBody: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.tags = tags
        self.userName = userName
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let homeDirectory: Swift.String?
    let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    let policy: Swift.String?
    let posixProfile: TransferClientTypes.PosixProfile?
    let role: Swift.String?
    let serverId: Swift.String?
    let sshPublicKeyBody: Swift.String?
    let tags: [TransferClientTypes.Tag]?
    let userName: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case tags = "Tags"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.userName = nil
        }
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {
    /// The ID of the server that the user is attached to.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique string that identifies a user account associated with a server.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct CreateUserOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension CreateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension CreateWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case onExceptionSteps = "OnExceptionSteps"
        case steps = "Steps"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let onExceptionSteps = onExceptionSteps {
            var onExceptionStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onExceptionSteps)
            for workflowsteps0 in onExceptionSteps {
                try onExceptionStepsContainer.encode(workflowsteps0)
            }
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for workflowsteps0 in steps {
                try stepsContainer.encode(workflowsteps0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

extension CreateWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkflowInput: Swift.Equatable {
    /// A textual description for the workflow.
    public var description: Swift.String?
    /// Specifies the steps (actions) to take if errors are encountered during execution of the workflow. For custom steps, the lambda function needs to send FAILURE to the call back API to kick off the exception steps. Additionally, if the lambda does not send SUCCESS before it times out, the exception steps are executed.
    public var onExceptionSteps: [TransferClientTypes.WorkflowStep]?
    /// Specifies the details for the steps that are in the specified workflow. The TYPE specifies which of the following actions is being taken for this step.
    ///
    /// * Copy: copy the file to another location
    ///
    /// * Custom: custom step with a lambda target
    ///
    /// * Delete: delete the file
    ///
    /// * Tag: add a tag to the file
    ///
    ///
    /// Currently, copying and tagging are supported only on S3. For file location, you specify either the S3 bucket and key, or the EFS filesystem ID and path.
    /// This member is required.
    public var steps: [TransferClientTypes.WorkflowStep]?
    /// Key-value pairs that can be used to group and search for workflows. Tags are metadata attached to workflows for any purpose.
    public var tags: [TransferClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        onExceptionSteps: [TransferClientTypes.WorkflowStep]? = nil,
        steps: [TransferClientTypes.WorkflowStep]? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.onExceptionSteps = onExceptionSteps
        self.steps = steps
        self.tags = tags
    }
}

struct CreateWorkflowInputBody: Swift.Equatable {
    let description: Swift.String?
    let steps: [TransferClientTypes.WorkflowStep]?
    let onExceptionSteps: [TransferClientTypes.WorkflowStep]?
    let tags: [TransferClientTypes.Tag]?
}

extension CreateWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case onExceptionSteps = "OnExceptionSteps"
        case steps = "Steps"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowStep?].self, forKey: .steps)
        var stepsDecoded0:[TransferClientTypes.WorkflowStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [TransferClientTypes.WorkflowStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let onExceptionStepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowStep?].self, forKey: .onExceptionSteps)
        var onExceptionStepsDecoded0:[TransferClientTypes.WorkflowStep]? = nil
        if let onExceptionStepsContainer = onExceptionStepsContainer {
            onExceptionStepsDecoded0 = [TransferClientTypes.WorkflowStep]()
            for structure0 in onExceptionStepsContainer {
                if let structure0 = structure0 {
                    onExceptionStepsDecoded0?.append(structure0)
                }
            }
        }
        onExceptionSteps = onExceptionStepsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workflowId = output.workflowId
        } else {
            self.workflowId = nil
        }
    }
}

public struct CreateWorkflowOutputResponse: Swift.Equatable {
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        workflowId: Swift.String? = nil
    )
    {
        self.workflowId = workflowId
    }
}

struct CreateWorkflowOutputResponseBody: Swift.Equatable {
    let workflowId: Swift.String?
}

extension CreateWorkflowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension TransferClientTypes.CustomStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case target = "Target"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let timeoutSeconds = timeoutSeconds {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure.
    public struct CustomStepDetails: Swift.Equatable {
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// The ARN for the lambda function that is being called.
        public var target: Swift.String?
        /// Timeout, in seconds, for the step.
        public var timeoutSeconds: Swift.Int?

        public init (
            name: Swift.String? = nil,
            target: Swift.String? = nil,
            timeoutSeconds: Swift.Int? = nil
        )
        {
            self.name = name
            self.target = target
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension TransferClientTypes {
    public enum CustomStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failure
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomStepStatus] {
            return [
                .failure,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failure: return "FAILURE"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomStepStatus(rawValue: rawValue) ?? CustomStepStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DeleteAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccessInput: Swift.Equatable {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// A system-assigned unique identifier for a server that has this user assigned.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct DeleteAccessInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension DeleteAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension DeleteAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessOutputResponse: Swift.Equatable {

}

extension DeleteServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DeleteServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServerInput: Swift.Equatable {
    /// A unique system-assigned identifier for a server instance.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct DeleteServerInputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension DeleteServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DeleteServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServerOutputResponse: Swift.Equatable {

}

extension DeleteSshPublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyId = sshPublicKeyId {
            try encodeContainer.encode(sshPublicKeyId, forKey: .sshPublicKeyId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DeleteSshPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSshPublicKeyInput: Swift.Equatable {
    /// A system-assigned unique identifier for a file transfer protocol-enabled server instance that has the user assigned to it.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique identifier used to reference your user's specific SSH key.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// A unique string that identifies a user whose public key is being deleted.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct DeleteSshPublicKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let sshPublicKeyId: Swift.String?
    let userName: Swift.String?
}

extension DeleteSshPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteSshPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSshPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSshPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSshPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSshPublicKeyOutputResponse: Swift.Equatable {

}

extension TransferClientTypes.DeleteStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension TransferClientTypes {
    /// The name of the step, used to identify the delete step.
    public struct DeleteStepDetails: Swift.Equatable {
        /// The name of the step, used as an identifier.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server instance that has the user assigned to it.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique string that identifies a user that is being deleted from a server.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

}

extension DeleteWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workflowId = workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension DeleteWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkflowInput: Swift.Equatable {
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        workflowId: Swift.String? = nil
    )
    {
        self.workflowId = workflowId
    }
}

struct DeleteWorkflowInputBody: Swift.Equatable {
    let workflowId: Swift.String?
}

extension DeleteWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension DeleteWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkflowOutputResponse: Swift.Equatable {

}

extension DescribeAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DescribeAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccessInput: Swift.Equatable {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// A system-assigned unique identifier for a server that has this access assigned.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct DescribeAccessInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension DescribeAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension DescribeAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.access = output.access
            self.serverId = output.serverId
        } else {
            self.access = nil
            self.serverId = nil
        }
    }
}

public struct DescribeAccessOutputResponse: Swift.Equatable {
    /// The external ID of the server that the access is attached to.
    /// This member is required.
    public var access: TransferClientTypes.DescribedAccess?
    /// A system-assigned unique identifier for a server that has this access assigned.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        access: TransferClientTypes.DescribedAccess? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.access = access
        self.serverId = serverId
    }
}

struct DescribeAccessOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let access: TransferClientTypes.DescribedAccess?
}

extension DescribeAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case access = "Access"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let accessDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedAccess.self, forKey: .access)
        access = accessDecoded
    }
}

extension DescribeExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let workflowId = workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension DescribeExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExecutionInput: Swift.Equatable {
    /// A unique identifier for the execution of a workflow.
    /// This member is required.
    public var executionId: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        executionId: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.executionId = executionId
        self.workflowId = workflowId
    }
}

struct DescribeExecutionInputBody: Swift.Equatable {
    let executionId: Swift.String?
    let workflowId: Swift.String?
}

extension DescribeExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension DescribeExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExecutionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.execution = output.execution
            self.workflowId = output.workflowId
        } else {
            self.execution = nil
            self.workflowId = nil
        }
    }
}

public struct DescribeExecutionOutputResponse: Swift.Equatable {
    /// The structure that contains the details of the workflow' execution.
    /// This member is required.
    public var execution: TransferClientTypes.DescribedExecution?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        execution: TransferClientTypes.DescribedExecution? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.execution = execution
        self.workflowId = workflowId
    }
}

struct DescribeExecutionOutputResponseBody: Swift.Equatable {
    let workflowId: Swift.String?
    let execution: TransferClientTypes.DescribedExecution?
}

extension DescribeExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case execution = "Execution"
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let executionDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedExecution.self, forKey: .execution)
        execution = executionDecoded
    }
}

extension DescribeSecurityPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyName = "SecurityPolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
    }
}

extension DescribeSecurityPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSecurityPolicyInput: Swift.Equatable {
    /// Specifies the name of the security policy that is attached to the server.
    /// This member is required.
    public var securityPolicyName: Swift.String?

    public init (
        securityPolicyName: Swift.String? = nil
    )
    {
        self.securityPolicyName = securityPolicyName
    }
}

struct DescribeSecurityPolicyInputBody: Swift.Equatable {
    let securityPolicyName: Swift.String?
}

extension DescribeSecurityPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyName = "SecurityPolicyName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
    }
}

extension DescribeSecurityPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSecurityPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSecurityPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSecurityPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSecurityPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityPolicy = output.securityPolicy
        } else {
            self.securityPolicy = nil
        }
    }
}

public struct DescribeSecurityPolicyOutputResponse: Swift.Equatable {
    /// An array containing the properties of the security policy.
    /// This member is required.
    public var securityPolicy: TransferClientTypes.DescribedSecurityPolicy?

    public init (
        securityPolicy: TransferClientTypes.DescribedSecurityPolicy? = nil
    )
    {
        self.securityPolicy = securityPolicy
    }
}

struct DescribeSecurityPolicyOutputResponseBody: Swift.Equatable {
    let securityPolicy: TransferClientTypes.DescribedSecurityPolicy?
}

extension DescribeSecurityPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicy = "SecurityPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedSecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
    }
}

extension DescribeServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension DescribeServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeServerInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct DescribeServerInputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension DescribeServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DescribeServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct DescribeServerOutputResponse: Swift.Equatable {
    /// An array containing the properties of a server with the ServerID you specified.
    /// This member is required.
    public var server: TransferClientTypes.DescribedServer?

    public init (
        server: TransferClientTypes.DescribedServer? = nil
    )
    {
        self.server = server
    }
}

struct DescribeServerOutputResponseBody: Swift.Equatable {
    let server: TransferClientTypes.DescribedServer?
}

extension DescribeServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedServer.self, forKey: .server)
        server = serverDecoded
    }
}

extension DescribeUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DescribeUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server that has this user assigned.
    /// This member is required.
    public var serverId: Swift.String?
    /// The name of the user assigned to one or more servers. User names are part of the sign-in credentials to use the Amazon Web Services Transfer Family service and perform file transfer tasks.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct DescribeUserInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension DescribeUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DescribeUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.user = output.user
        } else {
            self.serverId = nil
            self.user = nil
        }
    }
}

public struct DescribeUserOutputResponse: Swift.Equatable {
    /// A system-assigned unique identifier for a server that has this user assigned.
    /// This member is required.
    public var serverId: Swift.String?
    /// An array containing the properties of the user account for the ServerID value that you specified.
    /// This member is required.
    public var user: TransferClientTypes.DescribedUser?

    public init (
        serverId: Swift.String? = nil,
        user: TransferClientTypes.DescribedUser? = nil
    )
    {
        self.serverId = serverId
        self.user = user
    }
}

struct DescribeUserOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let user: TransferClientTypes.DescribedUser?
}

extension DescribeUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedUser.self, forKey: .user)
        user = userDecoded
    }
}

extension DescribeWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workflowId = workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension DescribeWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkflowInput: Swift.Equatable {
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        workflowId: Swift.String? = nil
    )
    {
        self.workflowId = workflowId
    }
}

struct DescribeWorkflowInputBody: Swift.Equatable {
    let workflowId: Swift.String?
}

extension DescribeWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension DescribeWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkflowOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workflow = output.workflow
        } else {
            self.workflow = nil
        }
    }
}

public struct DescribeWorkflowOutputResponse: Swift.Equatable {
    /// The structure that contains the details of the workflow.
    /// This member is required.
    public var workflow: TransferClientTypes.DescribedWorkflow?

    public init (
        workflow: TransferClientTypes.DescribedWorkflow? = nil
    )
    {
        self.workflow = workflow
    }
}

struct DescribeWorkflowOutputResponseBody: Swift.Equatable {
    let workflow: TransferClientTypes.DescribedWorkflow?
}

extension DescribeWorkflowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workflow = "Workflow"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedWorkflow.self, forKey: .workflow)
        workflow = workflowDecoded
    }
}

extension TransferClientTypes.DescribedAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension TransferClientTypes {
    /// Describes the properties of the access that was specified.
    public struct DescribedAccess: Swift.Equatable {
        /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
        public var externalId: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
        public var homeDirectory: Swift.String?
        /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity and Access Management (IAM) role provides access to paths in Target. This value can only be set when HomeDirectoryType is set to LOGICAL. In most cases, you can use this value instead of the session policy to lock down the associated access to the designated home directory ("chroot"). To do this, you can set Entry to '/' and set Target to the HomeDirectory parameter value.
        public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
        /// The type of landing directory (folder) you want your users' home directory to be when they log into the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or EFS paths visible to your users.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}.
        public var policy: Swift.String?
        /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
        public var posixProfile: TransferClientTypes.PosixProfile?
        /// Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
        public var role: Swift.String?

        public init (
            externalId: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            policy: Swift.String? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            role: Swift.String? = nil
        )
        {
            self.externalId = externalId
            self.homeDirectory = homeDirectory
            self.homeDirectoryMappings = homeDirectoryMappings
            self.homeDirectoryType = homeDirectoryType
            self.policy = policy
            self.posixProfile = posixProfile
            self.role = role
        }
    }

}

extension TransferClientTypes.DescribedExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case executionRole = "ExecutionRole"
        case initialFileLocation = "InitialFileLocation"
        case loggingConfiguration = "LoggingConfiguration"
        case posixProfile = "PosixProfile"
        case results = "Results"
        case serviceMetadata = "ServiceMetadata"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let executionRole = executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let initialFileLocation = initialFileLocation {
            try encodeContainer.encode(initialFileLocation, forKey: .initialFileLocation)
        }
        if let loggingConfiguration = loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let results = results {
            try encodeContainer.encode(results, forKey: .results)
        }
        if let serviceMetadata = serviceMetadata {
            try encodeContainer.encode(serviceMetadata, forKey: .serviceMetadata)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let initialFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.FileLocation.self, forKey: .initialFileLocation)
        initialFileLocation = initialFileLocationDecoded
        let serviceMetadataDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ServiceMetadata.self, forKey: .serviceMetadata)
        serviceMetadata = serviceMetadataDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionResults.self, forKey: .results)
        results = resultsDecoded
    }
}

extension TransferClientTypes {
    /// The details for an execution object.
    public struct DescribedExecution: Swift.Equatable {
        /// A unique identifier for the execution of a workflow.
        public var executionId: Swift.String?
        /// The IAM role associated with the execution.
        public var executionRole: Swift.String?
        /// A structure that describes the Amazon S3 or EFS file location. This is the file location when the execution begins: if the file is being copied, this is the initial (as opposed to destination) file location.
        public var initialFileLocation: TransferClientTypes.FileLocation?
        /// The IAM logging role associated with the execution.
        public var loggingConfiguration: TransferClientTypes.LoggingConfiguration?
        /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
        public var posixProfile: TransferClientTypes.PosixProfile?
        /// A structure that describes the execution results. This includes a list of the steps along with the details of each step, error type and message (if any), and the OnExceptionSteps structure.
        public var results: TransferClientTypes.ExecutionResults?
        /// A container object for the session details associated with a workflow.
        public var serviceMetadata: TransferClientTypes.ServiceMetadata?
        /// The status is one of the execution. Can be in progress, completed, exception encountered, or handling the exception.
        public var status: TransferClientTypes.ExecutionStatus?

        public init (
            executionId: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            initialFileLocation: TransferClientTypes.FileLocation? = nil,
            loggingConfiguration: TransferClientTypes.LoggingConfiguration? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            results: TransferClientTypes.ExecutionResults? = nil,
            serviceMetadata: TransferClientTypes.ServiceMetadata? = nil,
            status: TransferClientTypes.ExecutionStatus? = nil
        )
        {
            self.executionId = executionId
            self.executionRole = executionRole
            self.initialFileLocation = initialFileLocation
            self.loggingConfiguration = loggingConfiguration
            self.posixProfile = posixProfile
            self.results = results
            self.serviceMetadata = serviceMetadata
            self.status = status
        }
    }

}

extension TransferClientTypes.DescribedSecurityPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fips = "Fips"
        case securityPolicyName = "SecurityPolicyName"
        case sshCiphers = "SshCiphers"
        case sshKexs = "SshKexs"
        case sshMacs = "SshMacs"
        case tlsCiphers = "TlsCiphers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fips = fips {
            try encodeContainer.encode(fips, forKey: .fips)
        }
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let sshCiphers = sshCiphers {
            var sshCiphersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshCiphers)
            for securitypolicyoptions0 in sshCiphers {
                try sshCiphersContainer.encode(securitypolicyoptions0)
            }
        }
        if let sshKexs = sshKexs {
            var sshKexsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshKexs)
            for securitypolicyoptions0 in sshKexs {
                try sshKexsContainer.encode(securitypolicyoptions0)
            }
        }
        if let sshMacs = sshMacs {
            var sshMacsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshMacs)
            for securitypolicyoptions0 in sshMacs {
                try sshMacsContainer.encode(securitypolicyoptions0)
            }
        }
        if let tlsCiphers = tlsCiphers {
            var tlsCiphersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tlsCiphers)
            for securitypolicyoptions0 in tlsCiphers {
                try tlsCiphersContainer.encode(securitypolicyoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fipsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fips)
        fips = fipsDecoded
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let sshCiphersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshCiphers)
        var sshCiphersDecoded0:[Swift.String]? = nil
        if let sshCiphersContainer = sshCiphersContainer {
            sshCiphersDecoded0 = [Swift.String]()
            for string0 in sshCiphersContainer {
                if let string0 = string0 {
                    sshCiphersDecoded0?.append(string0)
                }
            }
        }
        sshCiphers = sshCiphersDecoded0
        let sshKexsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshKexs)
        var sshKexsDecoded0:[Swift.String]? = nil
        if let sshKexsContainer = sshKexsContainer {
            sshKexsDecoded0 = [Swift.String]()
            for string0 in sshKexsContainer {
                if let string0 = string0 {
                    sshKexsDecoded0?.append(string0)
                }
            }
        }
        sshKexs = sshKexsDecoded0
        let sshMacsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshMacs)
        var sshMacsDecoded0:[Swift.String]? = nil
        if let sshMacsContainer = sshMacsContainer {
            sshMacsDecoded0 = [Swift.String]()
            for string0 in sshMacsContainer {
                if let string0 = string0 {
                    sshMacsDecoded0?.append(string0)
                }
            }
        }
        sshMacs = sshMacsDecoded0
        let tlsCiphersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tlsCiphers)
        var tlsCiphersDecoded0:[Swift.String]? = nil
        if let tlsCiphersContainer = tlsCiphersContainer {
            tlsCiphersDecoded0 = [Swift.String]()
            for string0 in tlsCiphersContainer {
                if let string0 = string0 {
                    tlsCiphersDecoded0?.append(string0)
                }
            }
        }
        tlsCiphers = tlsCiphersDecoded0
    }
}

extension TransferClientTypes {
    /// Describes the properties of a security policy that was specified. For more information about security policies, see [Working with security policies](https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html).
    public struct DescribedSecurityPolicy: Swift.Equatable {
        /// Specifies whether this policy enables Federal Information Processing Standards (FIPS).
        public var fips: Swift.Bool?
        /// Specifies the name of the security policy that is attached to the server.
        /// This member is required.
        public var securityPolicyName: Swift.String?
        /// Specifies the enabled Secure Shell (SSH) cipher encryption algorithms in the security policy that is attached to the server.
        public var sshCiphers: [Swift.String]?
        /// Specifies the enabled SSH key exchange (KEX) encryption algorithms in the security policy that is attached to the server.
        public var sshKexs: [Swift.String]?
        /// Specifies the enabled SSH message authentication code (MAC) encryption algorithms in the security policy that is attached to the server.
        public var sshMacs: [Swift.String]?
        /// Specifies the enabled Transport Layer Security (TLS) cipher encryption algorithms in the security policy that is attached to the server.
        public var tlsCiphers: [Swift.String]?

        public init (
            fips: Swift.Bool? = nil,
            securityPolicyName: Swift.String? = nil,
            sshCiphers: [Swift.String]? = nil,
            sshKexs: [Swift.String]? = nil,
            sshMacs: [Swift.String]? = nil,
            tlsCiphers: [Swift.String]? = nil
        )
        {
            self.fips = fips
            self.securityPolicyName = securityPolicyName
            self.sshCiphers = sshCiphers
            self.sshKexs = sshKexs
            self.sshMacs = sshMacs
            self.tlsCiphers = tlsCiphers
        }
    }

}

extension TransferClientTypes.DescribedServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKeyFingerprint = "HostKeyFingerprint"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
        case state = "State"
        case tags = "Tags"
        case userCount = "UserCount"
        case workflowDetails = "WorkflowDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointDetails = endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKeyFingerprint = hostKeyFingerprint {
            try encodeContainer.encode(hostKeyFingerprint, forKey: .hostKeyFingerprint)
        }
        if let identityProviderDetails = identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let protocolDetails = protocolDetails {
            try encodeContainer.encode(protocolDetails, forKey: .protocolDetails)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let userCount = userCount {
            try encodeContainer.encode(userCount, forKey: .userCount)
        }
        if let workflowDetails = workflowDetails {
            try encodeContainer.encode(workflowDetails, forKey: .workflowDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let protocolDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProtocolDetails.self, forKey: .protocolDetails)
        protocolDetails = protocolDetailsDecoded
        let domainDecoded = try containerValues.decodeIfPresent(TransferClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyFingerprint)
        hostKeyFingerprint = hostKeyFingerprintDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.ModelProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TransferClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userCount)
        userCount = userCountDecoded
        let workflowDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowDetails.self, forKey: .workflowDetails)
        workflowDetails = workflowDetailsDecoded
    }
}

extension TransferClientTypes {
    /// Describes the properties of a file transfer protocol-enabled server that was specified.
    public struct DescribedServer: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) of the server.
        /// This member is required.
        public var arn: Swift.String?
        /// Specifies the ARN of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when Protocols is set to FTPS.
        public var certificate: Swift.String?
        /// Specifies the domain of the storage system that is used for file transfers.
        public var domain: TransferClientTypes.Domain?
        /// The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make it accessible only to resources within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
        public var endpointDetails: TransferClientTypes.EndpointDetails?
        /// Defines the type of endpoint that your server is connected to. If your server is connected to a VPC endpoint, your server isn't accessible over the public internet.
        public var endpointType: TransferClientTypes.EndpointType?
        /// Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value is equivalent to the output of the ssh-keygen -l -f my-new-server-key command.
        public var hostKeyFingerprint: Swift.String?
        /// Specifies information to call a customer-supplied authentication API. This field is not populated when the IdentityProviderType of a server is AWS_DIRECTORY_SERVICE or SERVICE_MANAGED.
        public var identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
        /// Specifies the mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Amazon Web Services Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to provide a Directory ID using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an API Gateway endpoint URL to call for authentication using the IdentityProviderDetails parameter. Use the LAMBDA value to directly use a Lambda function as your identity provider. If you choose this value, you must specify the ARN for the lambda function in the Function parameter for the IdentityProviderDetails data type.
        public var identityProviderType: TransferClientTypes.IdentityProviderType?
        /// Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in your CloudWatch logs.
        public var loggingRole: Swift.String?
        /// The protocol settings that are configured for your server. Use the PassiveIp parameter to indicate passive mode. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
        public var protocolDetails: TransferClientTypes.ProtocolDetails?
        /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
        ///
        /// * SFTP (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH
        ///
        /// * FTPS (File Transfer Protocol Secure): File transfer with TLS encryption
        ///
        /// * FTP (File Transfer Protocol): Unencrypted file transfer
        public var protocols: [TransferClientTypes.ModelProtocol]?
        /// Specifies the name of the security policy that is attached to the server.
        public var securityPolicyName: Swift.String?
        /// Specifies the unique system-assigned identifier for a server that you instantiate.
        public var serverId: Swift.String?
        /// Specifies the condition of a server for the server that was described. A value of ONLINE indicates that the server can accept jobs and transfer files. A State value of OFFLINE means that the server cannot perform file transfer operations. The states of STARTING and STOPPING indicate that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of START_FAILED or STOP_FAILED can indicate an error condition.
        public var state: TransferClientTypes.State?
        /// Specifies the key-value pairs that you can use to search for and group servers that were assigned to the server that was described.
        public var tags: [TransferClientTypes.Tag]?
        /// Specifies the number of users that are assigned to a server you specified with the ServerId.
        public var userCount: Swift.Int?
        /// Specifies the workflow ID for the workflow to assign and the execution role used for executing the workflow.
        public var workflowDetails: TransferClientTypes.WorkflowDetails?

        public init (
            arn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            domain: TransferClientTypes.Domain? = nil,
            endpointDetails: TransferClientTypes.EndpointDetails? = nil,
            endpointType: TransferClientTypes.EndpointType? = nil,
            hostKeyFingerprint: Swift.String? = nil,
            identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
            identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
            loggingRole: Swift.String? = nil,
            protocolDetails: TransferClientTypes.ProtocolDetails? = nil,
            protocols: [TransferClientTypes.ModelProtocol]? = nil,
            securityPolicyName: Swift.String? = nil,
            serverId: Swift.String? = nil,
            state: TransferClientTypes.State? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            userCount: Swift.Int? = nil,
            workflowDetails: TransferClientTypes.WorkflowDetails? = nil
        )
        {
            self.arn = arn
            self.certificate = certificate
            self.domain = domain
            self.endpointDetails = endpointDetails
            self.endpointType = endpointType
            self.hostKeyFingerprint = hostKeyFingerprint
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderType = identityProviderType
            self.loggingRole = loggingRole
            self.protocolDetails = protocolDetails
            self.protocols = protocols
            self.securityPolicyName = securityPolicyName
            self.serverId = serverId
            self.state = state
            self.tags = tags
            self.userCount = userCount
            self.workflowDetails = workflowDetails
        }
    }

}

extension TransferClientTypes.DescribedUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case sshPublicKeys = "SshPublicKeys"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sshPublicKeys = sshPublicKeys {
            var sshPublicKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshPublicKeys)
            for sshpublickeys0 in sshPublicKeys {
                try sshPublicKeysContainer.encode(sshpublickeys0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let sshPublicKeysContainer = try containerValues.decodeIfPresent([TransferClientTypes.SshPublicKey?].self, forKey: .sshPublicKeys)
        var sshPublicKeysDecoded0:[TransferClientTypes.SshPublicKey]? = nil
        if let sshPublicKeysContainer = sshPublicKeysContainer {
            sshPublicKeysDecoded0 = [TransferClientTypes.SshPublicKey]()
            for structure0 in sshPublicKeysContainer {
                if let structure0 = structure0 {
                    sshPublicKeysDecoded0?.append(structure0)
                }
            }
        }
        sshPublicKeys = sshPublicKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension TransferClientTypes {
    /// Describes the properties of a user that was specified.
    public struct DescribedUser: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) for the user that was requested to be described.
        /// This member is required.
        public var arn: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
        public var homeDirectory: Swift.String?
        /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity and Access Management (IAM) role provides access to paths in Target. This value can only be set when HomeDirectoryType is set to LOGICAL. In most cases, you can use this value instead of the session policy to lock your user down to the designated home directory ("chroot"). To do this, you can set Entry to '/' and set Target to the HomeDirectory parameter value.
        public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
        /// The type of landing directory (folder) you want your users' home directory to be when they log into the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or EFS paths visible to your users.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}.
        public var policy: Swift.String?
        /// Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon Elastic File System (Amazon EFS) file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
        public var posixProfile: TransferClientTypes.PosixProfile?
        /// Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
        public var role: Swift.String?
        /// Specifies the public key portion of the Secure Shell (SSH) keys stored for the described user.
        public var sshPublicKeys: [TransferClientTypes.SshPublicKey]?
        /// Specifies the key-value pairs for the user requested. Tag can be used to search for and group users for a variety of purposes.
        public var tags: [TransferClientTypes.Tag]?
        /// Specifies the name of the user that was requested to be described. User names are used for authentication purposes. This is the string that will be used by your user when they log in to your server.
        public var userName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            policy: Swift.String? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            role: Swift.String? = nil,
            sshPublicKeys: [TransferClientTypes.SshPublicKey]? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.homeDirectory = homeDirectory
            self.homeDirectoryMappings = homeDirectoryMappings
            self.homeDirectoryType = homeDirectoryType
            self.policy = policy
            self.posixProfile = posixProfile
            self.role = role
            self.sshPublicKeys = sshPublicKeys
            self.tags = tags
            self.userName = userName
        }
    }

}

extension TransferClientTypes.DescribedWorkflow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case onExceptionSteps = "OnExceptionSteps"
        case steps = "Steps"
        case tags = "Tags"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let onExceptionSteps = onExceptionSteps {
            var onExceptionStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onExceptionSteps)
            for workflowsteps0 in onExceptionSteps {
                try onExceptionStepsContainer.encode(workflowsteps0)
            }
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for workflowsteps0 in steps {
                try stepsContainer.encode(workflowsteps0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let workflowId = workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowStep?].self, forKey: .steps)
        var stepsDecoded0:[TransferClientTypes.WorkflowStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [TransferClientTypes.WorkflowStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let onExceptionStepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowStep?].self, forKey: .onExceptionSteps)
        var onExceptionStepsDecoded0:[TransferClientTypes.WorkflowStep]? = nil
        if let onExceptionStepsContainer = onExceptionStepsContainer {
            onExceptionStepsDecoded0 = [TransferClientTypes.WorkflowStep]()
            for structure0 in onExceptionStepsContainer {
                if let structure0 = structure0 {
                    onExceptionStepsDecoded0?.append(structure0)
                }
            }
        }
        onExceptionSteps = onExceptionStepsDecoded0
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes {
    /// Describes the properties of the specified workflow
    public struct DescribedWorkflow: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) for the workflow.
        /// This member is required.
        public var arn: Swift.String?
        /// Specifies the text description for the workflow.
        public var description: Swift.String?
        /// Specifies the steps (actions) to take if errors are encountered during execution of the workflow.
        public var onExceptionSteps: [TransferClientTypes.WorkflowStep]?
        /// Specifies the details for the steps that are in the specified workflow.
        public var steps: [TransferClientTypes.WorkflowStep]?
        /// Key-value pairs that can be used to group and search for workflows. Tags are metadata attached to workflows for any purpose.
        public var tags: [TransferClientTypes.Tag]?
        /// A unique identifier for the workflow.
        public var workflowId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            onExceptionSteps: [TransferClientTypes.WorkflowStep]? = nil,
            steps: [TransferClientTypes.WorkflowStep]? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.onExceptionSteps = onExceptionSteps
            self.steps = steps
            self.tags = tags
            self.workflowId = workflowId
        }
    }

}

extension TransferClientTypes {
    public enum Domain: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case efs
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .efs,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .efs: return "EFS"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Domain(rawValue: rawValue) ?? Domain.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.EfsFileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension TransferClientTypes {
    /// Reserved for future use.
    public struct EfsFileLocation: Swift.Equatable {
        /// The ID of the file system, assigned by Amazon EFS.
        public var fileSystemId: Swift.String?
        /// The pathname for the folder being used by a workflow.
        public var path: Swift.String?

        public init (
            fileSystemId: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.fileSystemId = fileSystemId
            self.path = path
        }
    }

}

extension TransferClientTypes.EndpointDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressAllocationIds = "AddressAllocationIds"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcEndpointId = "VpcEndpointId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressAllocationIds = addressAllocationIds {
            var addressAllocationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addressAllocationIds)
            for addressallocationids0 in addressAllocationIds {
                try addressAllocationIdsContainer.encode(addressallocationids0)
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcEndpointId = vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressAllocationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .addressAllocationIds)
        var addressAllocationIdsDecoded0:[Swift.String]? = nil
        if let addressAllocationIdsContainer = addressAllocationIdsContainer {
            addressAllocationIdsDecoded0 = [Swift.String]()
            for string0 in addressAllocationIdsContainer {
                if let string0 = string0 {
                    addressAllocationIdsDecoded0?.append(string0)
                }
            }
        }
        addressAllocationIds = addressAllocationIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension TransferClientTypes {
    /// The virtual private cloud (VPC) endpoint settings that are configured for your file transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server and resources only within your VPC. To control incoming internet traffic, invoke the UpdateServer API and attach an Elastic IP address to your server's endpoint. After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.
    public struct EndpointDetails: Swift.Equatable {
        /// A list of address allocation IDs that are required to attach an Elastic IP address to your server's endpoint. This property can only be set when EndpointType is set to VPC and it is only valid in the UpdateServer API.
        public var addressAllocationIds: [Swift.String]?
        /// A list of security groups IDs that are available to attach to your server's endpoint. This property can only be set when EndpointType is set to VPC. You can edit the SecurityGroupIds property in the [UpdateServer](https://docs.aws.amazon.com/transfer/latest/userguide/API_UpdateServer.html) API only if you are changing the EndpointType from PUBLIC or VPC_ENDPOINT to VPC. To change security groups associated with your server's VPC endpoint after creation, use the Amazon EC2 [ModifyVpcEndpoint](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyVpcEndpoint.html) API.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs that are required to host your server endpoint in your VPC. This property can only be set when EndpointType is set to VPC.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC endpoint. This property can only be set when EndpointType is set to VPC_ENDPOINT. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.
        public var vpcEndpointId: Swift.String?
        /// The VPC ID of the VPC in which a server's endpoint will be hosted. This property can only be set when EndpointType is set to VPC.
        public var vpcId: Swift.String?

        public init (
            addressAllocationIds: [Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.addressAllocationIds = addressAllocationIds
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension TransferClientTypes {
    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `public`
        case vpc
        case vpcEndpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .public,
                .vpc,
                .vpcEndpoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .public: return "PUBLIC"
            case .vpc: return "VPC"
            case .vpcEndpoint: return "VPC_ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.ExecutionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the error message and type, for an error that occurs during the execution of the workflow.
    public struct ExecutionError: Swift.Equatable {
        /// Specifies the descriptive message that corresponds to the ErrorType.
        /// This member is required.
        public var message: Swift.String?
        /// Specifies the error type: currently, the only valid value is PERMISSION_DENIED, which occurs if your policy does not contain the correct permissions to complete one or more of the steps in the workflow.
        /// This member is required.
        public var type: TransferClientTypes.ExecutionErrorType?

        public init (
            message: Swift.String? = nil,
            type: TransferClientTypes.ExecutionErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension TransferClientTypes {
    public enum ExecutionErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case permissionDenied
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionErrorType] {
            return [
                .permissionDenied,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .permissionDenied: return "PERMISSION_DENIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionErrorType(rawValue: rawValue) ?? ExecutionErrorType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.ExecutionResults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onExceptionSteps = "OnExceptionSteps"
        case steps = "Steps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onExceptionSteps = onExceptionSteps {
            var onExceptionStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onExceptionSteps)
            for executionstepresults0 in onExceptionSteps {
                try onExceptionStepsContainer.encode(executionstepresults0)
            }
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for executionstepresults0 in steps {
                try stepsContainer.encode(executionstepresults0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ExecutionStepResult?].self, forKey: .steps)
        var stepsDecoded0:[TransferClientTypes.ExecutionStepResult]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [TransferClientTypes.ExecutionStepResult]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let onExceptionStepsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ExecutionStepResult?].self, forKey: .onExceptionSteps)
        var onExceptionStepsDecoded0:[TransferClientTypes.ExecutionStepResult]? = nil
        if let onExceptionStepsContainer = onExceptionStepsContainer {
            onExceptionStepsDecoded0 = [TransferClientTypes.ExecutionStepResult]()
            for structure0 in onExceptionStepsContainer {
                if let structure0 = structure0 {
                    onExceptionStepsDecoded0?.append(structure0)
                }
            }
        }
        onExceptionSteps = onExceptionStepsDecoded0
    }
}

extension TransferClientTypes {
    /// Specifies the steps in the workflow, as well as the steps to execute in case of any errors during workflow execution.
    public struct ExecutionResults: Swift.Equatable {
        /// Specifies the steps (actions) to take if errors are encountered during execution of the workflow.
        public var onExceptionSteps: [TransferClientTypes.ExecutionStepResult]?
        /// Specifies the details for the steps that are in the specified workflow.
        public var steps: [TransferClientTypes.ExecutionStepResult]?

        public init (
            onExceptionSteps: [TransferClientTypes.ExecutionStepResult]? = nil,
            steps: [TransferClientTypes.ExecutionStepResult]? = nil
        )
        {
            self.onExceptionSteps = onExceptionSteps
            self.steps = steps
        }
    }

}

extension TransferClientTypes {
    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case exception
        case handlingException
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .completed,
                .exception,
                .handlingException,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .exception: return "EXCEPTION"
            case .handlingException: return "HANDLING_EXCEPTION"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.ExecutionStepResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case outputs = "Outputs"
        case stepType = "StepType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let outputs = outputs {
            try encodeContainer.encode(outputs, forKey: .outputs)
        }
        if let stepType = stepType {
            try encodeContainer.encode(stepType.rawValue, forKey: .stepType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowStepType.self, forKey: .stepType)
        stepType = stepTypeDecoded
        let outputsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputs)
        outputs = outputsDecoded
        let errorDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionError.self, forKey: .error)
        error = errorDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the following details for the step: error (if any), outputs (if any), and the step type.
    public struct ExecutionStepResult: Swift.Equatable {
        /// Specifies the details for an error, if it occurred during execution of the specified workfow step.
        public var error: TransferClientTypes.ExecutionError?
        /// The values for the key/value pair applied as a tag to the file. Only applicable if the step type is TAG.
        public var outputs: Swift.String?
        /// One of the available step types.
        ///
        /// * Copy: copy the file to another location
        ///
        /// * Custom: custom step with a lambda target
        ///
        /// * Delete: delete the file
        ///
        /// * Tag: add a tag to the file
        public var stepType: TransferClientTypes.WorkflowStepType?

        public init (
            error: TransferClientTypes.ExecutionError? = nil,
            outputs: Swift.String? = nil,
            stepType: TransferClientTypes.WorkflowStepType? = nil
        )
        {
            self.error = error
            self.outputs = outputs
            self.stepType = stepType
        }
    }

}

extension TransferClientTypes.FileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case efsFileLocation = "EfsFileLocation"
        case s3FileLocation = "S3FileLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let efsFileLocation = efsFileLocation {
            try encodeContainer.encode(efsFileLocation, forKey: .efsFileLocation)
        }
        if let s3FileLocation = s3FileLocation {
            try encodeContainer.encode(s3FileLocation, forKey: .s3FileLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3FileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.S3FileLocation.self, forKey: .s3FileLocation)
        s3FileLocation = s3FileLocationDecoded
        let efsFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EfsFileLocation.self, forKey: .efsFileLocation)
        efsFileLocation = efsFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the Amazon S3 or EFS file details to be used in the step.
    public struct FileLocation: Swift.Equatable {
        /// Specifies the Amazon EFS ID and the path for the file being used.
        public var efsFileLocation: TransferClientTypes.EfsFileLocation?
        /// Specifies the S3 details for the file being used, such as bucket, Etag, and so forth.
        public var s3FileLocation: TransferClientTypes.S3FileLocation?

        public init (
            efsFileLocation: TransferClientTypes.EfsFileLocation? = nil,
            s3FileLocation: TransferClientTypes.S3FileLocation? = nil
        )
        {
            self.efsFileLocation = efsFileLocation
            self.s3FileLocation = s3FileLocation
        }
    }

}

extension TransferClientTypes.HomeDirectoryMapEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entry = "Entry"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entry = entry {
            try encodeContainer.encode(entry, forKey: .entry)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entry)
        entry = entryDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension TransferClientTypes {
    /// Represents an object that contains entries and targets for HomeDirectoryMappings. The following is an Entry and Target pair example for chroot. [ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ] If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place holders for your directory. If using the CLI, use the s3api or efsapi call instead of s3 or efs so you can use the put-object operation. For example, you use the following: aws s3api put-object --bucket bucketname --key path/to/folder/. Make sure that the end of the key name ends in a / for it to be considered a folder.
    public struct HomeDirectoryMapEntry: Swift.Equatable {
        /// Represents an entry for HomeDirectoryMappings.
        /// This member is required.
        public var entry: Swift.String?
        /// Represents the map target that is used in a HomeDirectorymapEntry.
        /// This member is required.
        public var target: Swift.String?

        public init (
            entry: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.entry = entry
            self.target = target
        }
    }

}

extension TransferClientTypes {
    public enum HomeDirectoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case logical
        case path
        case sdkUnknown(Swift.String)

        public static var allCases: [HomeDirectoryType] {
            return [
                .logical,
                .path,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .logical: return "LOGICAL"
            case .path: return "PATH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HomeDirectoryType(rawValue: rawValue) ?? HomeDirectoryType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.IdentityProviderDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case function = "Function"
        case invocationRole = "InvocationRole"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let function = function {
            try encodeContainer.encode(function, forKey: .function)
        }
        if let invocationRole = invocationRole {
            try encodeContainer.encode(invocationRole, forKey: .invocationRole)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let invocationRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationRole)
        invocationRole = invocationRoleDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let functionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .function)
        function = functionDecoded
    }
}

extension TransferClientTypes {
    /// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. A server can have only one method of authentication.
    public struct IdentityProviderDetails: Swift.Equatable {
        /// The identifier of the Amazon Web ServicesDirectory Service directory that you want to stop sharing.
        public var directoryId: Swift.String?
        /// The ARN for a lambda function to use for the Identity provider.
        public var function: Swift.String?
        /// Provides the type of InvocationRole used to authenticate the user account.
        public var invocationRole: Swift.String?
        /// Provides the location of the service endpoint used to authenticate users.
        public var url: Swift.String?

        public init (
            directoryId: Swift.String? = nil,
            function: Swift.String? = nil,
            invocationRole: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
            self.function = function
            self.invocationRole = invocationRole
            self.url = url
        }
    }

}

extension TransferClientTypes {
    /// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. For AWS_DIRECTORY_SERVICE or SERVICE_MANAGED authentication, the Secure Shell (SSH) public keys are stored with a user on the server instance. For API_GATEWAY authentication, your custom authentication method is implemented by using an API call. The server can have only one method of authentication.
    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiGateway
        case awsDirectoryService
        case awsLambda
        case serviceManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .apiGateway,
                .awsDirectoryService,
                .awsLambda,
                .serviceManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiGateway: return "API_GATEWAY"
            case .awsDirectoryService: return "AWS_DIRECTORY_SERVICE"
            case .awsLambda: return "AWS_LAMBDA"
            case .serviceManaged: return "SERVICE_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
        }
    }
}

extension ImportSshPublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyBody = sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension ImportSshPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportSshPublicKeyInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server.
    /// This member is required.
    public var serverId: Swift.String?
    /// The public key portion of an SSH key pair.
    /// This member is required.
    public var sshPublicKeyBody: Swift.String?
    /// The name of the user account that is assigned to one or more servers.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        sshPublicKeyBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.userName = userName
    }
}

struct ImportSshPublicKeyInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let sshPublicKeyBody: Swift.String?
    let userName: Swift.String?
}

extension ImportSshPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension ImportSshPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportSshPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportSshPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportSshPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportSshPublicKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.sshPublicKeyId = output.sshPublicKeyId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.sshPublicKeyId = nil
            self.userName = nil
        }
    }
}

/// Identifies the user, the server they belong to, and the identifier of the SSH public key associated with that user. A user can have more than one key on each server that they are associated with.
public struct ImportSshPublicKeyOutputResponse: Swift.Equatable {
    /// A system-assigned unique identifier for a server.
    /// This member is required.
    public var serverId: Swift.String?
    /// The name given to a public key by the system that was imported.
    /// This member is required.
    public var sshPublicKeyId: Swift.String?
    /// A user name assigned to the ServerID value that you specified.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct ImportSshPublicKeyOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let sshPublicKeyId: Swift.String?
    let userName: Swift.String?
}

extension ImportSshPublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension TransferClientTypes.InputFileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case efsFileLocation = "EfsFileLocation"
        case s3FileLocation = "S3FileLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let efsFileLocation = efsFileLocation {
            try encodeContainer.encode(efsFileLocation, forKey: .efsFileLocation)
        }
        if let s3FileLocation = s3FileLocation {
            try encodeContainer.encode(s3FileLocation, forKey: .s3FileLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3FileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.S3InputFileLocation.self, forKey: .s3FileLocation)
        s3FileLocation = s3FileLocationDecoded
        let efsFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EfsFileLocation.self, forKey: .efsFileLocation)
        efsFileLocation = efsFileLocationDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the location for the file being copied. Only applicable for the Copy type of workflow steps.
    public struct InputFileLocation: Swift.Equatable {
        /// Reserved for future use.
        public var efsFileLocation: TransferClientTypes.EfsFileLocation?
        /// Specifies the details for the S3 file being copied.
        public var s3FileLocation: TransferClientTypes.S3InputFileLocation?

        public init (
            efsFileLocation: TransferClientTypes.EfsFileLocation? = nil,
            s3FileLocation: TransferClientTypes.S3InputFileLocation? = nil
        )
        {
            self.efsFileLocation = efsFileLocation
            self.s3FileLocation = s3FileLocation
        }
    }

}

extension InternalServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when an error occurs in the Amazon Web ServicesTransfer Family service.
public struct InternalServiceError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The NextToken parameter that was passed is invalid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the client submits a malformed request.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension ListAccessesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccessesInput: Swift.Equatable {
    /// Specifies the maximum number of access SIDs to return.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListAccesses call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional accesses.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that has users assigned to it.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListAccessesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let serverId: Swift.String?
}

extension ListAccessesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListAccessesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAccessesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accesses = output.accesses
            self.nextToken = output.nextToken
            self.serverId = output.serverId
        } else {
            self.accesses = nil
            self.nextToken = nil
            self.serverId = nil
        }
    }
}

public struct ListAccessesOutputResponse: Swift.Equatable {
    /// Returns the accesses and their properties for the ServerId value that you specify.
    /// This member is required.
    public var accesses: [TransferClientTypes.ListedAccess]?
    /// When you can get additional results from the ListAccesses call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional accesses.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that has users assigned to it.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        accesses: [TransferClientTypes.ListedAccess]? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.accesses = accesses
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListAccessesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serverId: Swift.String?
    let accesses: [TransferClientTypes.ListedAccess]?
}

extension ListAccessesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accesses = "Accesses"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let accessesContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedAccess?].self, forKey: .accesses)
        var accessesDecoded0:[TransferClientTypes.ListedAccess]? = nil
        if let accessesContainer = accessesContainer {
            accessesDecoded0 = [TransferClientTypes.ListedAccess]()
            for structure0 in accessesContainer {
                if let structure0 = structure0 {
                    accessesDecoded0?.append(structure0)
                }
            }
        }
        accesses = accessesDecoded0
    }
}

extension ListExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workflowId = workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension ListExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExecutionsInput: Swift.Equatable {
    /// Specifies the aximum number of executions to return.
    public var maxResults: Swift.Int?
    /// ListExecutions returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional executions. This is useful for pagination, for instance. If you have 100 executions for a workflow, you might only want to list first 10. If so, callthe API by specifing the max-results: aws transfer list-executions --max-results 10 This returns details for the first 10 executions, as well as the pointer (NextToken) to the eleventh execution. You can now call the API again, suppling the NextToken value you received: aws transfer list-executions --max-results 10 --next-token $somePointerReturnedFromPreviousListResult This call returns the next 10 executions, the 11th through the 20th. You can then repeat the call until the details for all 100 executions have been returned.
    public var nextToken: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

struct ListExecutionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let workflowId: Swift.String?
}

extension ListExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

extension ListExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExecutionsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executions = output.executions
            self.nextToken = output.nextToken
            self.workflowId = output.workflowId
        } else {
            self.executions = nil
            self.nextToken = nil
            self.workflowId = nil
        }
    }
}

public struct ListExecutionsOutputResponse: Swift.Equatable {
    /// Returns the details for each execution.
    ///
    /// * NextToken: returned from a call to several APIs, you can use pass it to a subsequent command to continue listing additional executions.
    ///
    /// * StartTime: timestamp indicating when the execution began.
    ///
    /// * Executions: details of the execution, including the execution ID, initial file location, and Service metadata.
    ///
    /// * Status: one of the following values: IN_PROGRESS, COMPLETED, EXCEPTION, HANDLING_EXEPTION.
    /// This member is required.
    public var executions: [TransferClientTypes.ListedExecution]?
    /// ListExecutions returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional executions.
    public var nextToken: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        executions: [TransferClientTypes.ListedExecution]? = nil,
        nextToken: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.executions = executions
        self.nextToken = nextToken
        self.workflowId = workflowId
    }
}

struct ListExecutionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workflowId: Swift.String?
    let executions: [TransferClientTypes.ListedExecution]?
}

extension ListExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executions = "Executions"
        case nextToken = "NextToken"
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let executionsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedExecution?].self, forKey: .executions)
        var executionsDecoded0:[TransferClientTypes.ListedExecution]? = nil
        if let executionsContainer = executionsContainer {
            executionsDecoded0 = [TransferClientTypes.ListedExecution]()
            for structure0 in executionsContainer {
                if let structure0 = structure0 {
                    executionsDecoded0?.append(structure0)
                }
            }
        }
        executions = executionsDecoded0
    }
}

extension ListSecurityPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSecurityPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSecurityPoliciesInput: Swift.Equatable {
    /// Specifies the number of security policies to return as a response to the ListSecurityPolicies query.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the ListSecurityPolicies command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional security policies.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSecurityPoliciesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSecurityPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecurityPoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSecurityPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityPolicyNames = output.securityPolicyNames
        } else {
            self.nextToken = nil
            self.securityPolicyNames = nil
        }
    }
}

public struct ListSecurityPoliciesOutputResponse: Swift.Equatable {
    /// When you can get additional results from the ListSecurityPolicies operation, a NextToken parameter is returned in the output. In a following command, you can pass in the NextToken parameter to continue listing security policies.
    public var nextToken: Swift.String?
    /// An array of security policies that were listed.
    /// This member is required.
    public var securityPolicyNames: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        securityPolicyNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityPolicyNames = securityPolicyNames
    }
}

struct ListSecurityPoliciesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let securityPolicyNames: [Swift.String]?
}

extension ListSecurityPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case securityPolicyNames = "SecurityPolicyNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let securityPolicyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityPolicyNames)
        var securityPolicyNamesDecoded0:[Swift.String]? = nil
        if let securityPolicyNamesContainer = securityPolicyNamesContainer {
            securityPolicyNamesDecoded0 = [Swift.String]()
            for string0 in securityPolicyNamesContainer {
                if let string0 = string0 {
                    securityPolicyNamesDecoded0?.append(string0)
                }
            }
        }
        securityPolicyNames = securityPolicyNamesDecoded0
    }
}

extension ListServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServersInput: Swift.Equatable {
    /// Specifies the number of servers to return as a response to the ListServers query.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the ListServers command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional servers.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServersOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.servers = output.servers
        } else {
            self.nextToken = nil
            self.servers = nil
        }
    }
}

public struct ListServersOutputResponse: Swift.Equatable {
    /// When you can get additional results from the ListServers operation, a NextToken parameter is returned in the output. In a following command, you can pass in the NextToken parameter to continue listing additional servers.
    public var nextToken: Swift.String?
    /// An array of servers that were listed.
    /// This member is required.
    public var servers: [TransferClientTypes.ListedServer]?

    public init (
        nextToken: Swift.String? = nil,
        servers: [TransferClientTypes.ListedServer]? = nil
    )
    {
        self.nextToken = nextToken
        self.servers = servers
    }
}

struct ListServersOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let servers: [TransferClientTypes.ListedServer]?
}

extension ListServersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case servers = "Servers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serversContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedServer?].self, forKey: .servers)
        var serversDecoded0:[TransferClientTypes.ListedServer]? = nil
        if let serversContainer = serversContainer {
            serversDecoded0 = [TransferClientTypes.ListedServer]()
            for structure0 in serversContainer {
                if let structure0 = structure0 {
                    serversDecoded0?.append(structure0)
                }
            }
        }
        servers = serversDecoded0
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an identifier for a specific Amazon Web Services resource, such as a server, user, or role.
    /// This member is required.
    public var arn: Swift.String?
    /// Specifies the number of tags to return as a response to the ListTagsForResource request.
    public var maxResults: Swift.Int?
    /// When you request additional results from the ListTagsForResource operation, a NextToken parameter is returned in the input. You can then pass in a subsequent command to the NextToken parameter to continue listing additional tags.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.arn = nil
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The ARN you specified to list the tags of.
    public var arn: Swift.String?
    /// When you can get additional results from the ListTagsForResource call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional tags.
    public var nextToken: Swift.String?
    /// Key-value pairs that are assigned to a resource, usually for the purpose of grouping and searching for items. Tags are metadata that you define.
    public var tags: [TransferClientTypes.Tag]?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
    let tags: [TransferClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// Specifies the number of users to return as a response to the ListUsers request.
    public var maxResults: Swift.Int?
    /// When you can get additional results from the ListUsers call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional users.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that has users assigned to it.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListUsersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let serverId: Swift.String?
}

extension ListUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serverId = output.serverId
            self.users = output.users
        } else {
            self.nextToken = nil
            self.serverId = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// When you can get additional results from the ListUsers call, a NextToken parameter is returned in the output. You can then pass in a subsequent command to the NextToken parameter to continue listing additional users.
    public var nextToken: Swift.String?
    /// A system-assigned unique identifier for a server that the users are assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// Returns the user accounts and their properties for the ServerId value that you specify.
    /// This member is required.
    public var users: [TransferClientTypes.ListedUser]?

    public init (
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil,
        users: [TransferClientTypes.ListedUser]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverId = serverId
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serverId: Swift.String?
    let users: [TransferClientTypes.ListedUser]?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serverId = "ServerId"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let usersContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedUser?].self, forKey: .users)
        var usersDecoded0:[TransferClientTypes.ListedUser]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [TransferClientTypes.ListedUser]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension ListWorkflowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorkflowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWorkflowsInput: Swift.Equatable {
    /// Specifies the maximum number of workflows to return.
    public var maxResults: Swift.Int?
    /// ListWorkflows returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional workflows.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkflowsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListWorkflowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkflowsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkflowsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkflowsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkflowsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkflowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workflows = output.workflows
        } else {
            self.nextToken = nil
            self.workflows = nil
        }
    }
}

public struct ListWorkflowsOutputResponse: Swift.Equatable {
    /// ListWorkflows returns the NextToken parameter in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional workflows.
    public var nextToken: Swift.String?
    /// Returns the Arn, WorkflowId, and Description for each workflow.
    /// This member is required.
    public var workflows: [TransferClientTypes.ListedWorkflow]?

    public init (
        nextToken: Swift.String? = nil,
        workflows: [TransferClientTypes.ListedWorkflow]? = nil
    )
    {
        self.nextToken = nextToken
        self.workflows = workflows
    }
}

struct ListWorkflowsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workflows: [TransferClientTypes.ListedWorkflow]?
}

extension ListWorkflowsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workflows = "Workflows"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workflowsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedWorkflow?].self, forKey: .workflows)
        var workflowsDecoded0:[TransferClientTypes.ListedWorkflow]? = nil
        if let workflowsContainer = workflowsContainer {
            workflowsDecoded0 = [TransferClientTypes.ListedWorkflow]()
            for structure0 in workflowsContainer {
                if let structure0 = structure0 {
                    workflowsDecoded0?.append(structure0)
                }
            }
        }
        workflows = workflowsDecoded0
    }
}

extension TransferClientTypes.ListedAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryType = "HomeDirectoryType"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension TransferClientTypes {
    /// Lists the properties for one or more specified associated accesses.
    public struct ListedAccess: Swift.Equatable {
        /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
        public var externalId: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
        public var homeDirectory: Swift.String?
        /// The type of landing directory (folder) you want your users' home directory to be when they log into the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or EFS paths visible to your users.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
        public var role: Swift.String?

        public init (
            externalId: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            role: Swift.String? = nil
        )
        {
            self.externalId = externalId
            self.homeDirectory = homeDirectory
            self.homeDirectoryType = homeDirectoryType
            self.role = role
        }
    }

}

extension TransferClientTypes.ListedExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case initialFileLocation = "InitialFileLocation"
        case serviceMetadata = "ServiceMetadata"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let initialFileLocation = initialFileLocation {
            try encodeContainer.encode(initialFileLocation, forKey: .initialFileLocation)
        }
        if let serviceMetadata = serviceMetadata {
            try encodeContainer.encode(serviceMetadata, forKey: .serviceMetadata)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let initialFileLocationDecoded = try containerValues.decodeIfPresent(TransferClientTypes.FileLocation.self, forKey: .initialFileLocation)
        initialFileLocation = initialFileLocationDecoded
        let serviceMetadataDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ServiceMetadata.self, forKey: .serviceMetadata)
        serviceMetadata = serviceMetadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension TransferClientTypes {
    /// Returns properties of the execution that is specified.
    public struct ListedExecution: Swift.Equatable {
        /// A unique identifier for the execution of a workflow.
        public var executionId: Swift.String?
        /// A structure that describes the Amazon S3 or EFS file location. This is the file location when the execution begins: if the file is being copied, this is the initial (as opposed to destination) file location.
        public var initialFileLocation: TransferClientTypes.FileLocation?
        /// A container object for the session details associated with a workflow.
        public var serviceMetadata: TransferClientTypes.ServiceMetadata?
        /// The status is one of the execution. Can be in progress, completed, exception encountered, or handling the exception.
        public var status: TransferClientTypes.ExecutionStatus?

        public init (
            executionId: Swift.String? = nil,
            initialFileLocation: TransferClientTypes.FileLocation? = nil,
            serviceMetadata: TransferClientTypes.ServiceMetadata? = nil,
            status: TransferClientTypes.ExecutionStatus? = nil
        )
        {
            self.executionId = executionId
            self.initialFileLocation = initialFileLocation
            self.serviceMetadata = serviceMetadata
            self.status = status
        }
    }

}

extension TransferClientTypes.ListedServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case domain = "Domain"
        case endpointType = "EndpointType"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case serverId = "ServerId"
        case state = "State"
        case userCount = "UserCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userCount = userCount {
            try encodeContainer.encode(userCount, forKey: .userCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let domainDecoded = try containerValues.decodeIfPresent(TransferClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TransferClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let userCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userCount)
        userCount = userCountDecoded
    }
}

extension TransferClientTypes {
    /// Returns properties of a file transfer protocol-enabled server that was specified.
    public struct ListedServer: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) for a server to be listed.
        /// This member is required.
        public var arn: Swift.String?
        /// Specifies the domain of the storage system that is used for file transfers.
        public var domain: TransferClientTypes.Domain?
        /// Specifies the type of VPC endpoint that your server is connected to. If your server is connected to a VPC endpoint, your server isn't accessible over the public internet.
        public var endpointType: TransferClientTypes.EndpointType?
        /// Specifies the mode of authentication for a server. The default value is SERVICE_MANAGED, which allows you to store and access user credentials within the Amazon Web Services Transfer Family service. Use AWS_DIRECTORY_SERVICE to provide access to Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to provide a Directory ID using the IdentityProviderDetails parameter. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an API Gateway endpoint URL to call for authentication using the IdentityProviderDetails parameter. Use the LAMBDA value to directly use a Lambda function as your identity provider. If you choose this value, you must specify the ARN for the lambda function in the Function parameter for the IdentityProviderDetails data type.
        public var identityProviderType: TransferClientTypes.IdentityProviderType?
        /// Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in your CloudWatch logs.
        public var loggingRole: Swift.String?
        /// Specifies the unique system assigned identifier for the servers that were listed.
        public var serverId: Swift.String?
        /// Specifies the condition of a server for the server that was described. A value of ONLINE indicates that the server can accept jobs and transfer files. A State value of OFFLINE means that the server cannot perform file transfer operations. The states of STARTING and STOPPING indicate that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of START_FAILED or STOP_FAILED can indicate an error condition.
        public var state: TransferClientTypes.State?
        /// Specifies the number of users that are assigned to a server you specified with the ServerId.
        public var userCount: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            domain: TransferClientTypes.Domain? = nil,
            endpointType: TransferClientTypes.EndpointType? = nil,
            identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
            loggingRole: Swift.String? = nil,
            serverId: Swift.String? = nil,
            state: TransferClientTypes.State? = nil,
            userCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.domain = domain
            self.endpointType = endpointType
            self.identityProviderType = identityProviderType
            self.loggingRole = loggingRole
            self.serverId = serverId
            self.state = state
            self.userCount = userCount
        }
    }

}

extension TransferClientTypes.ListedUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryType = "HomeDirectoryType"
        case role = "Role"
        case sshPublicKeyCount = "SshPublicKeyCount"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sshPublicKeyCount = sshPublicKeyCount {
            try encodeContainer.encode(sshPublicKeyCount, forKey: .sshPublicKeyCount)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let sshPublicKeyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sshPublicKeyCount)
        sshPublicKeyCount = sshPublicKeyCountDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension TransferClientTypes {
    /// Returns properties of the user that you specify.
    public struct ListedUser: Swift.Equatable {
        /// Provides the unique Amazon Resource Name (ARN) for the user that you want to learn about.
        /// This member is required.
        public var arn: Swift.String?
        /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
        public var homeDirectory: Swift.String?
        /// The type of landing directory (folder) you want your users' home directory to be when they log into the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or EFS paths visible to your users.
        public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests. The IAM role that controls your users' access to your Amazon S3 bucket for servers with Domain=S3, or your EFS file system for servers with Domain=EFS. The policies attached to this role determine the level of access you want to provide your users when transferring files into and out of your S3 buckets or EFS file systems.
        public var role: Swift.String?
        /// Specifies the number of SSH public keys stored for the user you specified.
        public var sshPublicKeyCount: Swift.Int?
        /// Specifies the name of the user whose ARN was specified. User names are used for authentication purposes.
        public var userName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            role: Swift.String? = nil,
            sshPublicKeyCount: Swift.Int? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.homeDirectory = homeDirectory
            self.homeDirectoryType = homeDirectoryType
            self.role = role
            self.sshPublicKeyCount = sshPublicKeyCount
            self.userName = userName
        }
    }

}

extension TransferClientTypes.ListedWorkflow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let workflowId = workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension TransferClientTypes {
    /// Contains the ID, text description, and Amazon Resource Name (ARN) for the workflow.
    public struct ListedWorkflow: Swift.Equatable {
        /// Specifies the unique Amazon Resource Name (ARN) for the workflow.
        public var arn: Swift.String?
        /// Specifies the text description for the workflow.
        public var description: Swift.String?
        /// A unique identifier for the workflow.
        public var workflowId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.workflowId = workflowId
        }
    }

}

extension TransferClientTypes.LoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName = "LogGroupName"
        case loggingRole = "LoggingRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension TransferClientTypes {
    /// Consists of the logging role and the log group name.
    public struct LoggingConfiguration: Swift.Equatable {
        /// The name of the CloudWatch logging group for the Amazon Web Services Transfer server to which this workflow belongs.
        public var logGroupName: Swift.String?
        /// Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in your CloudWatch logs.
        public var loggingRole: Swift.String?

        public init (
            logGroupName: Swift.String? = nil,
            loggingRole: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
            self.loggingRole = loggingRole
        }
    }

}

extension TransferClientTypes {
    public enum OverwriteExisting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [OverwriteExisting] {
            return [
                .false,
                .true,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OverwriteExisting(rawValue: rawValue) ?? OverwriteExisting.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.PosixProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gid = "Gid"
        case secondaryGids = "SecondaryGids"
        case uid = "Uid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gid = gid {
            try encodeContainer.encode(gid, forKey: .gid)
        }
        if let secondaryGids = secondaryGids {
            var secondaryGidsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryGids)
            for secondarygids0 in secondaryGids {
                try secondaryGidsContainer.encode(secondarygids0)
            }
        }
        if let uid = uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uid)
        uid = uidDecoded
        let gidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gid)
        gid = gidDecoded
        let secondaryGidsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .secondaryGids)
        var secondaryGidsDecoded0:[Swift.Int]? = nil
        if let secondaryGidsContainer = secondaryGidsContainer {
            secondaryGidsDecoded0 = [Swift.Int]()
            for long0 in secondaryGidsContainer {
                if let long0 = long0 {
                    secondaryGidsDecoded0?.append(long0)
                }
            }
        }
        secondaryGids = secondaryGidsDecoded0
    }
}

extension TransferClientTypes {
    /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public struct PosixProfile: Swift.Equatable {
        /// The POSIX group ID used for all EFS operations by this user.
        /// This member is required.
        public var gid: Swift.Int?
        /// The secondary POSIX group IDs used for all EFS operations by this user.
        public var secondaryGids: [Swift.Int]?
        /// The POSIX user ID used for all EFS operations by this user.
        /// This member is required.
        public var uid: Swift.Int?

        public init (
            gid: Swift.Int? = nil,
            secondaryGids: [Swift.Int]? = nil,
            uid: Swift.Int? = nil
        )
        {
            self.gid = gid
            self.secondaryGids = secondaryGids
            self.uid = uid
        }
    }

}

extension TransferClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ftp
        case ftps
        case sftp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .ftp,
                .ftps,
                .sftp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ftp: return "FTP"
            case .ftps: return "FTPS"
            case .sftp: return "SFTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.ProtocolDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case passiveIp = "PassiveIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let passiveIp = passiveIp {
            try encodeContainer.encode(passiveIp, forKey: .passiveIp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let passiveIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passiveIp)
        passiveIp = passiveIpDecoded
    }
}

extension TransferClientTypes {
    /// The protocol settings that are configured for your server. This type is only valid in the UpdateServer API.
    public struct ProtocolDetails: Swift.Equatable {
        /// Indicates passive mode, for FTP and FTPS protocols. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer. For example:  aws transfer update-server --protocol-details PassiveIp=0.0.0.0  Replace  0.0.0.0  in the example above with the actual IP address you want to use. If you change the PassiveIp value, you must stop and then restart your Transfer server for the change to take effect. For details on using Passive IP (PASV) in a NAT environment, see [Configuring your FTPS server behind a firewall or NAT with Amazon Web Services Transfer Family](http://aws.amazon.com/blogs/storage/configuring-your-ftps-server-behind-a-firewall-or-nat-with-aws-transfer-family/).
        public var passiveIp: Swift.String?

        public init (
            passiveIp: Swift.String? = nil
        )
        {
            self.passiveIp = passiveIp
        }
    }

}

extension ResourceExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resource = output.resource
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resource = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource does not exist.
public struct ResourceExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// This member is required.
    public var resource: Swift.String?
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct ResourceExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resource: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resource = output.resource
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resource = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when a resource is not found by the Amazon Web ServicesTransfer Family service.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// This member is required.
    public var resource: Swift.String?
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resource: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension TransferClientTypes.S3FileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case etag = "Etag"
        case key = "Key"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let etag = etag {
            try encodeContainer.encode(etag, forKey: .etag)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let etagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etag)
        etag = etagDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the details for the file location for the file being used in the workflow. Only applicable if you are using S3 storage.
    public struct S3FileLocation: Swift.Equatable {
        /// Specifies the S3 bucket that contains the file being used.
        public var bucket: Swift.String?
        /// The entity tag is a hash of the object. The ETag reflects changes only to the contents of an object, not its metadata.
        public var etag: Swift.String?
        /// The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
        public var key: Swift.String?
        /// Specifies the file version.
        public var versionId: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            etag: Swift.String? = nil,
            key: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.etag = etag
            self.key = key
            self.versionId = versionId
        }
    }

}

extension TransferClientTypes.S3InputFileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the customer input S3 file location. If it is used inside copyStepDetails.DestinationFileLocation, it should be the S3 copy destination. You need to provide the bucket and key. The key can represent either a path or a file. This is determined by whether or not you end the key value with the forward slash (/) character. If the final character is "/", then your file is copied to the folder, and its name does not change. If, rather, the final character is alphanumeric, your uploaded file is renamed to the path value. In this case, if a file with that name already exists, it is overwritten. For example, if your path is shared-files/bob/, your uploaded files are copied to the shared-files/bob/, folder. If your path is shared-files/today, each uploaded file is copied to the shared-files folder and named today: each upload overwrites the previous version of the bob file.
    public struct S3InputFileLocation: Swift.Equatable {
        /// Specifies the S3 bucket for the customer input file.
        public var bucket: Swift.String?
        /// The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
        public var key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension TransferClientTypes.S3Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the key-value pair that are assigned to a file during the execution of a Tagging step.
    public struct S3Tag: Swift.Equatable {
        /// The name assigned to the tag that you create.
        /// This member is required.
        public var key: Swift.String?
        /// The value that corresponds to the key.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SendWorkflowStepStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case status = "Status"
        case token = "Token"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let workflowId = workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }
}

extension SendWorkflowStepStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendWorkflowStepStateInput: Swift.Equatable {
    /// A unique identifier for the execution of a workflow.
    /// This member is required.
    public var executionId: Swift.String?
    /// Indicates whether the specified step succeeded or failed.
    /// This member is required.
    public var status: TransferClientTypes.CustomStepStatus?
    /// Used to distinguish between multiple callbacks for multiple Lambda steps within the same execution.
    /// This member is required.
    public var token: Swift.String?
    /// A unique identifier for the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init (
        executionId: Swift.String? = nil,
        status: TransferClientTypes.CustomStepStatus? = nil,
        token: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.executionId = executionId
        self.status = status
        self.token = token
        self.workflowId = workflowId
    }
}

struct SendWorkflowStepStateInputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let executionId: Swift.String?
    let token: Swift.String?
    let status: TransferClientTypes.CustomStepStatus?
}

extension SendWorkflowStepStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId = "ExecutionId"
        case status = "Status"
        case token = "Token"
        case workflowId = "WorkflowId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CustomStepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SendWorkflowStepStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendWorkflowStepStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendWorkflowStepStateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendWorkflowStepStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SendWorkflowStepStateOutputResponse: Swift.Equatable {

}

extension TransferClientTypes.ServiceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userDetails = "UserDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userDetails = userDetails {
            try encodeContainer.encode(userDetails, forKey: .userDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.UserDetails.self, forKey: .userDetails)
        userDetails = userDetailsDecoded
    }
}

extension TransferClientTypes {
    /// A container object for the session details associated with a workflow.
    public struct ServiceMetadata: Swift.Equatable {
        /// The Server ID (ServerId), Session ID (SessionId) and user (UserName) make up the UserDetails.
        /// This member is required.
        public var userDetails: TransferClientTypes.UserDetails?

        public init (
            userDetails: TransferClientTypes.UserDetails? = nil
        )
        {
            self.userDetails = userDetails
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed because the Amazon Web ServicesTransfer Family service is not available.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferClientTypes.SshPublicKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateImported = "DateImported"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case sshPublicKeyId = "SshPublicKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateImported = dateImported {
            try encodeContainer.encode(dateImported.timeIntervalSince1970, forKey: .dateImported)
        }
        if let sshPublicKeyBody = sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let sshPublicKeyId = sshPublicKeyId {
            try encodeContainer.encode(sshPublicKeyId, forKey: .sshPublicKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateImportedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dateImported)
        dateImported = dateImportedDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
    }
}

extension TransferClientTypes {
    /// Provides information about the public Secure Shell (SSH) key that is associated with a user account for the specific file transfer protocol-enabled server (as identified by ServerId). The information returned includes the date the key was imported, the public key contents, and the public key ID. A user can store more than one SSH public key associated with their user name on a specific server.
    public struct SshPublicKey: Swift.Equatable {
        /// Specifies the date that the public key was added to the user account.
        /// This member is required.
        public var dateImported: ClientRuntime.Date?
        /// Specifies the content of the SSH public key as specified by the PublicKeyId.
        /// This member is required.
        public var sshPublicKeyBody: Swift.String?
        /// Specifies the SshPublicKeyId parameter contains the identifier of the public key.
        /// This member is required.
        public var sshPublicKeyId: Swift.String?

        public init (
            dateImported: ClientRuntime.Date? = nil,
            sshPublicKeyBody: Swift.String? = nil,
            sshPublicKeyId: Swift.String? = nil
        )
        {
            self.dateImported = dateImported
            self.sshPublicKeyBody = sshPublicKeyBody
            self.sshPublicKeyId = sshPublicKeyId
        }
    }

}

extension StartServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension StartServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartServerInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server that you start.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct StartServerInputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension StartServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension StartServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartServerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartServerOutputResponse: Swift.Equatable {

}

extension TransferClientTypes {
    /// Describes the condition of a file transfer protocol-enabled server with respect to its ability to perform file operations. There are six possible states: OFFLINE, ONLINE, STARTING, STOPPING, START_FAILED, and STOP_FAILED. OFFLINE indicates that the server exists, but that it is not available for file operations. ONLINE indicates that the server is available to perform file operations. STARTING indicates that the server's was instantiated, but the server is not yet available to perform file operations. Under normal conditions, it can take a couple of minutes for the server to be completely operational. Both START_FAILED and STOP_FAILED are error conditions.
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case offline
        case online
        case starting
        case startFailed
        case stopping
        case stopFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .offline,
                .online,
                .starting,
                .startFailed,
                .stopping,
                .stopFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .starting: return "STARTING"
            case .startFailed: return "START_FAILED"
            case .stopping: return "STOPPING"
            case .stopFailed: return "STOP_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension StopServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension StopServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopServerInput: Swift.Equatable {
    /// A system-assigned unique identifier for a server that you stopped.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct StopServerInputBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension StopServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension StopServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopServerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopServerOutputResponse: Swift.Equatable {

}

extension TransferClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TransferClientTypes {
    /// Creates a key-value pair for a specific resource. Tags are metadata that you can use to search for and group a resource for various purposes. You can apply tags to servers, users, and roles. A tag key can take more than one value. For example, to group servers for accounting purposes, you might create a tag called Group and assign the values Research and Accounting to that group.
    public struct Tag: Swift.Equatable {
        /// The name assigned to the tag that you create.
        /// This member is required.
        public var key: Swift.String?
        /// Contains one or more values that you assigned to the key name you create.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a server, user, or role.
    /// This member is required.
    public var arn: Swift.String?
    /// Key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to user accounts for any purpose.
    /// This member is required.
    public var tags: [TransferClientTypes.Tag]?

    public init (
        arn: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let tags: [TransferClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension TransferClientTypes.TagStepDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for s3tags0 in tags {
                try tagsContainer.encode(s3tags0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.S3Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.S3Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.S3Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TransferClientTypes {
    /// Each step type has its own StepDetails structure. The key/value pairs used to tag a file during the execution of a workflow step.
    public struct TagStepDetails: Swift.Equatable {
        /// The name of the step, used as an identifier.
        public var name: Swift.String?
        /// Array that contains from 1 to 10 key/value pairs.
        public var tags: [TransferClientTypes.S3Tag]?

        public init (
            name: Swift.String? = nil,
            tags: [TransferClientTypes.S3Tag]? = nil
        )
        {
            self.name = name
            self.tags = tags
        }
    }

}

extension TestIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case serverProtocol = "ServerProtocol"
        case sourceIp = "SourceIp"
        case userName = "UserName"
        case userPassword = "UserPassword"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let serverProtocol = serverProtocol {
            try encodeContainer.encode(serverProtocol.rawValue, forKey: .serverProtocol)
        }
        if let sourceIp = sourceIp {
            try encodeContainer.encode(sourceIp, forKey: .sourceIp)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userPassword = userPassword {
            try encodeContainer.encode(userPassword, forKey: .userPassword)
        }
    }
}

extension TestIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TestIdentityProviderInput: Swift.Equatable {
    /// A system-assigned identifier for a specific server. That server's user authentication method is tested with a user name and password.
    /// This member is required.
    public var serverId: Swift.String?
    /// The type of file transfer protocol to be tested. The available protocols are:
    ///
    /// * Secure Shell (SSH) File Transfer Protocol (SFTP)
    ///
    /// * File Transfer Protocol Secure (FTPS)
    ///
    /// * File Transfer Protocol (FTP)
    public var serverProtocol: TransferClientTypes.ModelProtocol?
    /// The source IP address of the user account to be tested.
    public var sourceIp: Swift.String?
    /// The name of the user account to be tested.
    /// This member is required.
    public var userName: Swift.String?
    /// The password of the user account to be tested.
    public var userPassword: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        serverProtocol: TransferClientTypes.ModelProtocol? = nil,
        sourceIp: Swift.String? = nil,
        userName: Swift.String? = nil,
        userPassword: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.serverProtocol = serverProtocol
        self.sourceIp = sourceIp
        self.userName = userName
        self.userPassword = userPassword
    }
}

struct TestIdentityProviderInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let serverProtocol: TransferClientTypes.ModelProtocol?
    let sourceIp: Swift.String?
    let userName: Swift.String?
    let userPassword: Swift.String?
}

extension TestIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case serverProtocol = "ServerProtocol"
        case sourceIp = "SourceIp"
        case userName = "UserName"
        case userPassword = "UserPassword"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let serverProtocolDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ModelProtocol.self, forKey: .serverProtocol)
        serverProtocol = serverProtocolDecoded
        let sourceIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIp)
        sourceIp = sourceIpDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPassword)
        userPassword = userPasswordDecoded
    }
}

extension TestIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TestIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.response = output.response
            self.statusCode = output.statusCode
            self.url = output.url
        } else {
            self.message = nil
            self.response = nil
            self.statusCode = 0
            self.url = nil
        }
    }
}

public struct TestIdentityProviderOutputResponse: Swift.Equatable {
    /// A message that indicates whether the test was successful or not.
    public var message: Swift.String?
    /// The response that is returned from your API Gateway.
    public var response: Swift.String?
    /// The HTTP status code that is the response from your API Gateway.
    /// This member is required.
    public var statusCode: Swift.Int
    /// The endpoint of the service used to authenticate a user.
    /// This member is required.
    public var url: Swift.String?

    public init (
        message: Swift.String? = nil,
        response: Swift.String? = nil,
        statusCode: Swift.Int = 0,
        url: Swift.String? = nil
    )
    {
        self.message = message
        self.response = response
        self.statusCode = statusCode
        self.url = url
    }
}

struct TestIdentityProviderOutputResponseBody: Swift.Equatable {
    let response: Swift.String?
    let statusCode: Swift.Int
    let message: Swift.String?
    let url: Swift.String?
}

extension TestIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case response = "Response"
        case statusCode = "StatusCode"
        case url = "Url"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .response)
        response = responseDecoded
        let statusCodeDecoded = try containerValues.decode(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling. HTTP Status Code: 400
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var retryAfterSeconds: Swift.String?

    public init (
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.retryAfterSeconds = retryAfterSeconds
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The value of the resource that will have the tag removed. An Amazon Resource Name (ARN) is an identifier for a specific Amazon Web Services resource, such as a server, user, or role.
    /// This member is required.
    public var arn: Swift.String?
    /// TagKeys are key-value pairs assigned to ARNs that can be used to group and search for resources by type. This metadata can be attached to resources for any purpose.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension UpdateAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAccessInput: Swift.Equatable {
    /// A unique identifier that is required to identify specific groups within your directory. The users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name, you can view the SID values by running the following command using Windows PowerShell. Get-ADGroup -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid In that command, replace YourGroupName with the name of your Active Directory group. The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces. You can also include underscores or any of the following characters: =,.@:/-
    /// This member is required.
    public var externalId: Swift.String?
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity and Access Management (IAM) role provides access to paths in Target. This value can only be set when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock down your user to the designated home directory ("chroot"). To do this, you can set Entry to / and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ] If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place holders for your directory. If using the CLI, use the s3api or efsapi call instead of s3 or efs so you can use the put-object operation. For example, you use the following: aws s3api put-object --bucket bucketname --key path/to/folder/. Make sure that the end of the key name ends in a / for it to be considered a folder.
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) you want your users' home directory to be when they log into the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or EFS paths visible to your users.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This only applies when the domain of ServerId is S3. EFS does not use session policies. For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Example session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web ServicesSecurity Token Service API Reference.
    public var policy: Swift.String?
    /// The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
    }
}

struct UpdateAccessInputBody: Swift.Equatable {
    let homeDirectory: Swift.String?
    let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    let policy: Swift.String?
    let posixProfile: TransferClientTypes.PosixProfile?
    let role: Swift.String?
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension UpdateAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension UpdateAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.externalId = output.externalId
            self.serverId = output.serverId
        } else {
            self.externalId = nil
            self.serverId = nil
        }
    }
}

public struct UpdateAccessOutputResponse: Swift.Equatable {
    /// The external ID of the group whose users have access to your Amazon S3 or Amazon EFS resources over the enabled protocols using Amazon Web ServicesTransfer Family.
    /// This member is required.
    public var externalId: Swift.String?
    /// The ID of the server that the user is attached to.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct UpdateAccessOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let externalId: Swift.String?
}

extension UpdateAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension UpdateServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case loggingRole = "LoggingRole"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
        case workflowDetails = "WorkflowDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let endpointDetails = endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKey = hostKey {
            try encodeContainer.encode(hostKey, forKey: .hostKey)
        }
        if let identityProviderDetails = identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let protocolDetails = protocolDetails {
            try encodeContainer.encode(protocolDetails, forKey: .protocolDetails)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let workflowDetails = workflowDetails {
            try encodeContainer.encode(workflowDetails, forKey: .workflowDetails)
        }
    }
}

extension UpdateServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when Protocols is set to FTPS. To request a new public certificate, see [Request a public certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) in the Amazon Web ServicesCertificate Manager User Guide. To import an existing certificate into ACM, see [Importing certificates into ACM](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the Amazon Web ServicesCertificate Manager User Guide. To request a private certificate to use FTPS through private IP addresses, see [Request a private certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html) in the Amazon Web ServicesCertificate Manager User Guide. Certificates with the following cryptographic algorithms and key sizes are supported:
    ///
    /// * 2048-bit RSA (RSA_2048)
    ///
    /// * 4096-bit RSA (RSA_4096)
    ///
    /// * Elliptic Prime Curve 256 bit (EC_prime256v1)
    ///
    /// * Elliptic Prime Curve 384 bit (EC_secp384r1)
    ///
    /// * Elliptic Prime Curve 521 bit (EC_secp521r1)
    ///
    ///
    /// The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP address specified and information about the issuer.
    public var certificate: Swift.String?
    /// The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make it accessible only to resources within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.
    public var endpointDetails: TransferClientTypes.EndpointDetails?
    /// The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC) or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it. After May 19, 2021, you won't be able to create a server using EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount if your account hasn't already done so before May 19, 2021. If you have already created servers with EndpointType=VPC_ENDPOINT in your Amazon Web Servicesaccount on or before May 19, 2021, you will not be affected. After this date, use EndpointType=VPC. For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint. It is recommended that you use VPC as the EndpointType. With this endpoint type, you have the option to directly associate up to three Elastic IPv4 addresses (BYO IP included) with your server's endpoint and use VPC security groups to restrict traffic by the client's public IP address. This is not possible with EndpointType set to VPC_ENDPOINT.
    public var endpointType: TransferClientTypes.EndpointType?
    /// The RSA private key as generated by ssh-keygen -N "" -m PEM -f my-new-server-key. If you aren't planning to migrate existing users from an existing server to a new server, don't update the host key. Accidentally changing a server's host key can be disruptive. For more information, see [Change the host key for your SFTP-enabled server](https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key) in the Amazon Web ServicesTransfer Family User Guide.
    public var hostKey: Swift.String?
    /// An array containing all of the information required to call a customer's authentication API method.
    public var identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    /// Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in your CloudWatch logs.
    public var loggingRole: Swift.String?
    /// The protocol settings that are configured for your server. Use the PassiveIp parameter to indicate passive mode (for FTP and FTPS protocols). Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
    public var protocolDetails: TransferClientTypes.ProtocolDetails?
    /// Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:
    ///
    /// * Secure Shell (SSH) File Transfer Protocol (SFTP): File transfer over SSH
    ///
    /// * File Transfer Protocol Secure (FTPS): File transfer with TLS encryption
    ///
    /// * File Transfer Protocol (FTP): Unencrypted file transfer
    ///
    ///
    /// If you select FTPS, you must choose a certificate stored in Amazon Web ServicesCertificate Manager (ACM) which will be used to identify your server when clients connect to it over FTPS. If Protocol includes either FTP or FTPS, then the EndpointType must be VPC and the IdentityProviderType must be AWS_DIRECTORY_SERVICE or API_GATEWAY. If Protocol includes FTP, then AddressAllocationIds cannot be associated. If Protocol is set only to SFTP, the EndpointType can be set to PUBLIC and the IdentityProviderType can be set to SERVICE_MANAGED.
    public var protocols: [TransferClientTypes.ModelProtocol]?
    /// Specifies the name of the security policy that is attached to the server.
    public var securityPolicyName: Swift.String?
    /// A system-assigned unique identifier for a server instance that the user account is assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// Specifies the workflow ID for the workflow to assign and the execution role used for executing the workflow.
    public var workflowDetails: TransferClientTypes.WorkflowDetails?

    public init (
        certificate: Swift.String? = nil,
        endpointDetails: TransferClientTypes.EndpointDetails? = nil,
        endpointType: TransferClientTypes.EndpointType? = nil,
        hostKey: Swift.String? = nil,
        identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
        loggingRole: Swift.String? = nil,
        protocolDetails: TransferClientTypes.ProtocolDetails? = nil,
        protocols: [TransferClientTypes.ModelProtocol]? = nil,
        securityPolicyName: Swift.String? = nil,
        serverId: Swift.String? = nil,
        workflowDetails: TransferClientTypes.WorkflowDetails? = nil
    )
    {
        self.certificate = certificate
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKey = hostKey
        self.identityProviderDetails = identityProviderDetails
        self.loggingRole = loggingRole
        self.protocolDetails = protocolDetails
        self.protocols = protocols
        self.securityPolicyName = securityPolicyName
        self.serverId = serverId
        self.workflowDetails = workflowDetails
    }
}

struct UpdateServerInputBody: Swift.Equatable {
    let certificate: Swift.String?
    let protocolDetails: TransferClientTypes.ProtocolDetails?
    let endpointDetails: TransferClientTypes.EndpointDetails?
    let endpointType: TransferClientTypes.EndpointType?
    let hostKey: Swift.String?
    let identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    let loggingRole: Swift.String?
    let protocols: [TransferClientTypes.ModelProtocol]?
    let securityPolicyName: Swift.String?
    let serverId: Swift.String?
    let workflowDetails: TransferClientTypes.WorkflowDetails?
}

extension UpdateServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case loggingRole = "LoggingRole"
        case protocolDetails = "ProtocolDetails"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
        case workflowDetails = "WorkflowDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let protocolDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ProtocolDetails.self, forKey: .protocolDetails)
        protocolDetails = protocolDetailsDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKey)
        hostKey = hostKeyDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.ModelProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let workflowDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowDetails.self, forKey: .workflowDetails)
        workflowDetails = workflowDetailsDecoded
    }
}

extension UpdateServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
        } else {
            self.serverId = nil
        }
    }
}

public struct UpdateServerOutputResponse: Swift.Equatable {
    /// A system-assigned unique identifier for a server that the user account is assigned to.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct UpdateServerOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
}

extension UpdateServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// The landing directory (folder) for a user when they log in to the server using the client. A HomeDirectory example is /bucket_name/home/mydirectory.
    public var homeDirectory: Swift.String?
    /// Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible. You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity and Access Management (IAM) role provides access to paths in Target. This value can only be set when HomeDirectoryType is set to LOGICAL. The following is an Entry and Target pair example. [ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ] In most cases, you can use this value instead of the session policy to lock down your user to the designated home directory ("chroot"). To do this, you can set Entry to '/' and set Target to the HomeDirectory parameter value. The following is an Entry and Target pair example for chroot. [ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ] If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place holders for your directory. If using the CLI, use the s3api or efsapi call instead of s3 or efs so you can use the put-object operation. For example, you use the following: aws s3api put-object --bucket bucketname --key path/to/folder/. Make sure that the end of the key name ends in a / for it to be considered a folder.
    public var homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// The type of landing directory (folder) you want your users' home directory to be when they log into the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it LOGICAL, you need to provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or EFS paths visible to your users.
    public var homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}. This only applies when the domain of ServerId is S3. EFS does not use session policies. For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the Policy argument. For an example of a session policy, see [Creating a session policy](https://docs.aws.amazon.com/transfer/latest/userguide/session-policy). For more information, see [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html) in the Amazon Web Services Security Token Service API Reference.
    public var policy: Swift.String?
    /// Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon Elastic File Systems (Amazon EFS). The POSIX permissions that are set on files and directories in your file system determines the level of access your users get when transferring files into and out of your Amazon EFS file systems.
    public var posixProfile: TransferClientTypes.PosixProfile?
    /// Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
    public var role: Swift.String?
    /// A system-assigned unique identifier for a server instance that the user account is assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// A unique string that identifies a user and is associated with a server as specified by the ServerId. This user name must be a minimum of 3 and a maximum of 100 characters long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen '-', period '.', and at sign '@'. The user name can't start with a hyphen, period, or at sign.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.userName = userName
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let homeDirectory: Swift.String?
    let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    let policy: Swift.String?
    let posixProfile: TransferClientTypes.PosixProfile?
    let role: Swift.String?
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension UpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.userName = nil
        }
    }
}

/// UpdateUserResponse returns the user name and identifier for the request to update a user's properties.
public struct UpdateUserOutputResponse: Swift.Equatable {
    /// A system-assigned unique identifier for a server instance that the user account is assigned to.
    /// This member is required.
    public var serverId: Swift.String?
    /// The unique identifier for a user that is assigned to a server instance that was specified in the request.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct UpdateUserOutputResponseBody: Swift.Equatable {
    let serverId: Swift.String?
    let userName: Swift.String?
}

extension UpdateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension TransferClientTypes.UserDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sessionId = "SessionId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the user name, server ID, and session ID for a workflow.
    public struct UserDetails: Swift.Equatable {
        /// The system-assigned unique identifier for a Transfer server instance.
        /// This member is required.
        public var serverId: Swift.String?
        /// The system-assigned unique identifier for a session that corresponds to the workflow.
        public var sessionId: Swift.String?
        /// A unique string that identifies a user account associated with a server.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            serverId: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.serverId = serverId
            self.sessionId = sessionId
            self.userName = userName
        }
    }

}

extension TransferClientTypes.WorkflowDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionRole = "ExecutionRole"
        case workflowId = "WorkflowId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionRole = executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let workflowId = workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
    }
}

extension TransferClientTypes {
    /// Specifies the workflow ID for the workflow to assign and the execution role used for executing the workflow.
    public struct WorkflowDetail: Swift.Equatable {
        /// Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources
        /// This member is required.
        public var executionRole: Swift.String?
        /// A unique identifier for the workflow.
        /// This member is required.
        public var workflowId: Swift.String?

        public init (
            executionRole: Swift.String? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.executionRole = executionRole
            self.workflowId = workflowId
        }
    }

}

extension TransferClientTypes.WorkflowDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onUpload = "OnUpload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onUpload = onUpload {
            var onUploadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .onUpload)
            for onuploadworkflowdetails0 in onUpload {
                try onUploadContainer.encode(onuploadworkflowdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onUploadContainer = try containerValues.decodeIfPresent([TransferClientTypes.WorkflowDetail?].self, forKey: .onUpload)
        var onUploadDecoded0:[TransferClientTypes.WorkflowDetail]? = nil
        if let onUploadContainer = onUploadContainer {
            onUploadDecoded0 = [TransferClientTypes.WorkflowDetail]()
            for structure0 in onUploadContainer {
                if let structure0 = structure0 {
                    onUploadDecoded0?.append(structure0)
                }
            }
        }
        onUpload = onUploadDecoded0
    }
}

extension TransferClientTypes {
    /// Container for the WorkflowDetail data type. It is used by actions that trigger a workflow to begin execution.
    public struct WorkflowDetails: Swift.Equatable {
        /// A trigger that starts a workflow: the workflow begins to execute after a file is uploaded.
        /// This member is required.
        public var onUpload: [TransferClientTypes.WorkflowDetail]?

        public init (
            onUpload: [TransferClientTypes.WorkflowDetail]? = nil
        )
        {
            self.onUpload = onUpload
        }
    }

}

extension TransferClientTypes.WorkflowStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyStepDetails = "CopyStepDetails"
        case customStepDetails = "CustomStepDetails"
        case deleteStepDetails = "DeleteStepDetails"
        case tagStepDetails = "TagStepDetails"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyStepDetails = copyStepDetails {
            try encodeContainer.encode(copyStepDetails, forKey: .copyStepDetails)
        }
        if let customStepDetails = customStepDetails {
            try encodeContainer.encode(customStepDetails, forKey: .customStepDetails)
        }
        if let deleteStepDetails = deleteStepDetails {
            try encodeContainer.encode(deleteStepDetails, forKey: .deleteStepDetails)
        }
        if let tagStepDetails = tagStepDetails {
            try encodeContainer.encode(tagStepDetails, forKey: .tagStepDetails)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.WorkflowStepType.self, forKey: .type)
        type = typeDecoded
        let copyStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CopyStepDetails.self, forKey: .copyStepDetails)
        copyStepDetails = copyStepDetailsDecoded
        let customStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.CustomStepDetails.self, forKey: .customStepDetails)
        customStepDetails = customStepDetailsDecoded
        let deleteStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DeleteStepDetails.self, forKey: .deleteStepDetails)
        deleteStepDetails = deleteStepDetailsDecoded
        let tagStepDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.TagStepDetails.self, forKey: .tagStepDetails)
        tagStepDetails = tagStepDetailsDecoded
    }
}

extension TransferClientTypes {
    /// The basic building block of a workflow.
    public struct WorkflowStep: Swift.Equatable {
        /// Details for a step that performs a file copy. Consists of the following values:
        ///
        /// * A description
        ///
        /// * An S3 location for the destination of the file copy.
        ///
        /// * A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE.
        public var copyStepDetails: TransferClientTypes.CopyStepDetails?
        /// Details for a step that invokes a lambda function. Consists of the lambda function name, target, and timeout (in seconds).
        public var customStepDetails: TransferClientTypes.CustomStepDetails?
        /// Details for a step that deletes the file.
        public var deleteStepDetails: TransferClientTypes.DeleteStepDetails?
        /// Details for a step that creates one or more tags. You specify one or more tags: each tag contains a key/value pair.
        public var tagStepDetails: TransferClientTypes.TagStepDetails?
        /// Currently, the following step types are supported.
        ///
        /// * Copy: copy the file to another location
        ///
        /// * Custom: custom step with a lambda target
        ///
        /// * Delete: delete the file
        ///
        /// * Tag: add a tag to the file
        public var type: TransferClientTypes.WorkflowStepType?

        public init (
            copyStepDetails: TransferClientTypes.CopyStepDetails? = nil,
            customStepDetails: TransferClientTypes.CustomStepDetails? = nil,
            deleteStepDetails: TransferClientTypes.DeleteStepDetails? = nil,
            tagStepDetails: TransferClientTypes.TagStepDetails? = nil,
            type: TransferClientTypes.WorkflowStepType? = nil
        )
        {
            self.copyStepDetails = copyStepDetails
            self.customStepDetails = customStepDetails
            self.deleteStepDetails = deleteStepDetails
            self.tagStepDetails = tagStepDetails
            self.type = type
        }
    }

}

extension TransferClientTypes {
    public enum WorkflowStepType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case copy
        case custom
        case delete
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStepType] {
            return [
                .copy,
                .custom,
                .delete,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .copy: return "COPY"
            case .custom: return "CUSTOM"
            case .delete: return "DELETE"
            case .tag: return "TAG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowStepType(rawValue: rawValue) ?? WorkflowStepType.sdkUnknown(rawValue)
        }
    }
}
