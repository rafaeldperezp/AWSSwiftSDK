// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have sufficient permissions to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RumClientTypes.AppMonitor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appMonitorConfiguration = "AppMonitorConfiguration"
        case created = "Created"
        case dataStorage = "DataStorage"
        case domain = "Domain"
        case id = "Id"
        case lastModified = "LastModified"
        case name = "Name"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appMonitorConfiguration = appMonitorConfiguration {
            try encodeContainer.encode(appMonitorConfiguration, forKey: .appMonitorConfiguration)
        }
        if let created = created {
            try encodeContainer.encode(created, forKey: .created)
        }
        if let dataStorage = dataStorage {
            try encodeContainer.encode(dataStorage, forKey: .dataStorage)
        }
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .created)
        created = createdDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(RumClientTypes.StateEnum.self, forKey: .state)
        state = stateDecoded
        let appMonitorConfigurationDecoded = try containerValues.decodeIfPresent(RumClientTypes.AppMonitorConfiguration.self, forKey: .appMonitorConfiguration)
        appMonitorConfiguration = appMonitorConfigurationDecoded
        let dataStorageDecoded = try containerValues.decodeIfPresent(RumClientTypes.DataStorage.self, forKey: .dataStorage)
        dataStorage = dataStorageDecoded
    }
}

extension RumClientTypes {
    /// A RUM app monitor collects telemetry data from your application and sends that data to RUM. The data includes performance and reliability information such as page load time, client-side errors, and user behavior.
    public struct AppMonitor: Swift.Equatable {
        /// A structure that contains much of the configuration data for the app monitor.
        public var appMonitorConfiguration: RumClientTypes.AppMonitorConfiguration?
        /// The date and time that this app monitor was created.
        public var created: Swift.String?
        /// A structure that contains information about whether this app monitor stores a copy of the telemetry data that RUM collects using CloudWatch Logs.
        public var dataStorage: RumClientTypes.DataStorage?
        /// The top-level internet domain name for which your application has administrative authority.
        public var domain: Swift.String?
        /// The unique ID of this app monitor.
        public var id: Swift.String?
        /// The date and time of the most recent changes to this app monitor's configuration.
        public var lastModified: Swift.String?
        /// The name of the app monitor.
        public var name: Swift.String?
        /// The current state of the app monitor.
        public var state: RumClientTypes.StateEnum?
        /// The list of tag keys and values associated with this app monitor.
        public var tags: [Swift.String:Swift.String]?

        public init (
            appMonitorConfiguration: RumClientTypes.AppMonitorConfiguration? = nil,
            created: Swift.String? = nil,
            dataStorage: RumClientTypes.DataStorage? = nil,
            domain: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            name: Swift.String? = nil,
            state: RumClientTypes.StateEnum? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.appMonitorConfiguration = appMonitorConfiguration
            self.created = created
            self.dataStorage = dataStorage
            self.domain = domain
            self.id = id
            self.lastModified = lastModified
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension RumClientTypes.AppMonitorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCookies = "AllowCookies"
        case enableXRay = "EnableXRay"
        case excludedPages = "ExcludedPages"
        case favoritePages = "FavoritePages"
        case guestRoleArn = "GuestRoleArn"
        case identityPoolId = "IdentityPoolId"
        case includedPages = "IncludedPages"
        case sessionSampleRate = "SessionSampleRate"
        case telemetries = "Telemetries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowCookies = allowCookies {
            try encodeContainer.encode(allowCookies, forKey: .allowCookies)
        }
        if let enableXRay = enableXRay {
            try encodeContainer.encode(enableXRay, forKey: .enableXRay)
        }
        if let excludedPages = excludedPages {
            var excludedPagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedPages)
            for pages0 in excludedPages {
                try excludedPagesContainer.encode(pages0)
            }
        }
        if let favoritePages = favoritePages {
            var favoritePagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .favoritePages)
            for favoritepages0 in favoritePages {
                try favoritePagesContainer.encode(favoritepages0)
            }
        }
        if let guestRoleArn = guestRoleArn {
            try encodeContainer.encode(guestRoleArn, forKey: .guestRoleArn)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let includedPages = includedPages {
            var includedPagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includedPages)
            for pages0 in includedPages {
                try includedPagesContainer.encode(pages0)
            }
        }
        if sessionSampleRate != 0.0 {
            try encodeContainer.encode(sessionSampleRate, forKey: .sessionSampleRate)
        }
        if let telemetries = telemetries {
            var telemetriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .telemetries)
            for telemetries0 in telemetries {
                try telemetriesContainer.encode(telemetries0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let excludedPagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludedPages)
        var excludedPagesDecoded0:[Swift.String]? = nil
        if let excludedPagesContainer = excludedPagesContainer {
            excludedPagesDecoded0 = [Swift.String]()
            for string0 in excludedPagesContainer {
                if let string0 = string0 {
                    excludedPagesDecoded0?.append(string0)
                }
            }
        }
        excludedPages = excludedPagesDecoded0
        let includedPagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .includedPages)
        var includedPagesDecoded0:[Swift.String]? = nil
        if let includedPagesContainer = includedPagesContainer {
            includedPagesDecoded0 = [Swift.String]()
            for string0 in includedPagesContainer {
                if let string0 = string0 {
                    includedPagesDecoded0?.append(string0)
                }
            }
        }
        includedPages = includedPagesDecoded0
        let favoritePagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .favoritePages)
        var favoritePagesDecoded0:[Swift.String]? = nil
        if let favoritePagesContainer = favoritePagesContainer {
            favoritePagesDecoded0 = [Swift.String]()
            for string0 in favoritePagesContainer {
                if let string0 = string0 {
                    favoritePagesDecoded0?.append(string0)
                }
            }
        }
        favoritePages = favoritePagesDecoded0
        let sessionSampleRateDecoded = try containerValues.decode(Swift.Double.self, forKey: .sessionSampleRate)
        sessionSampleRate = sessionSampleRateDecoded
        let guestRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .guestRoleArn)
        guestRoleArn = guestRoleArnDecoded
        let allowCookiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowCookies)
        allowCookies = allowCookiesDecoded
        let telemetriesContainer = try containerValues.decodeIfPresent([RumClientTypes.Telemetry?].self, forKey: .telemetries)
        var telemetriesDecoded0:[RumClientTypes.Telemetry]? = nil
        if let telemetriesContainer = telemetriesContainer {
            telemetriesDecoded0 = [RumClientTypes.Telemetry]()
            for string0 in telemetriesContainer {
                if let string0 = string0 {
                    telemetriesDecoded0?.append(string0)
                }
            }
        }
        telemetries = telemetriesDecoded0
        let enableXRayDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableXRay)
        enableXRay = enableXRayDecoded
    }
}

extension RumClientTypes {
    /// This structure contains much of the configuration data for the app monitor.
    public struct AppMonitorConfiguration: Swift.Equatable {
        /// If you set this to true, the RUM web client sets two cookies, a session cookie and a user cookie. The cookies allow the RUM web client to collect data relating to the number of users an application has and the behavior of the application across a sequence of events. Cookies are stored in the top-level domain of the current page.
        public var allowCookies: Swift.Bool?
        /// If you set this to true, RUM enables X-Ray tracing for the user sessions that RUM samples. RUM adds an X-Ray trace header to allowed HTTP requests. It also records an X-Ray segment for allowed HTTP requests. You can see traces and segments from these user sessions in the X-Ray console and the CloudWatch ServiceLens console. For more information, see [What is X-Ray?](https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html)
        public var enableXRay: Swift.Bool?
        /// A list of URLs in your website or application to exclude from RUM data collection. You can't include both ExcludedPages and IncludedPages in the same operation.
        public var excludedPages: [Swift.String]?
        /// A list of pages in the CloudWatch RUM console that are to be displayed with a "favorite" icon.
        public var favoritePages: [Swift.String]?
        /// The ARN of the guest IAM role that is attached to the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.
        public var guestRoleArn: Swift.String?
        /// The ID of the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.
        public var identityPoolId: Swift.String?
        /// If this app monitor is to collect data from only certain pages in your application, this structure lists those pages. You can't include both ExcludedPages and IncludedPages in the same operation.
        public var includedPages: [Swift.String]?
        /// Specifies the percentage of user sessions to use for RUM data collection. Choosing a higher percentage gives you more data but also incurs more costs. The number you specify is the percentage of user sessions that will be used. If you omit this parameter, the default of 10 is used.
        public var sessionSampleRate: Swift.Double
        /// An array that lists the types of telemetry data that this app monitor is to collect.
        ///
        /// * errors indicates that RUM collects data about unhandled JavaScript errors raised by your application.
        ///
        /// * performance indicates that RUM collects performance data about how your application and its resources are loaded and rendered. This includes Core Web Vitals.
        ///
        /// * http indicates that RUM collects data about HTTP errors thrown by your application.
        public var telemetries: [RumClientTypes.Telemetry]?

        public init (
            allowCookies: Swift.Bool? = nil,
            enableXRay: Swift.Bool? = nil,
            excludedPages: [Swift.String]? = nil,
            favoritePages: [Swift.String]? = nil,
            guestRoleArn: Swift.String? = nil,
            identityPoolId: Swift.String? = nil,
            includedPages: [Swift.String]? = nil,
            sessionSampleRate: Swift.Double = 0.0,
            telemetries: [RumClientTypes.Telemetry]? = nil
        )
        {
            self.allowCookies = allowCookies
            self.enableXRay = enableXRay
            self.excludedPages = excludedPages
            self.favoritePages = favoritePages
            self.guestRoleArn = guestRoleArn
            self.identityPoolId = identityPoolId
            self.includedPages = includedPages
            self.sessionSampleRate = sessionSampleRate
            self.telemetries = telemetries
        }
    }

}

extension RumClientTypes.AppMonitorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension RumClientTypes {
    /// A structure that contains information about the RUM app monitor.
    public struct AppMonitorDetails: Swift.Equatable {
        /// The unique ID of the app monitor.
        public var id: Swift.String?
        /// The name of the app monitor.
        public var name: Swift.String?
        /// The version of the app monitor.
        public var version: Swift.String?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.version = version
        }
    }

}

extension RumClientTypes.AppMonitorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case id = "Id"
        case lastModified = "LastModified"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created, forKey: .created)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .created)
        created = createdDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RumClientTypes.StateEnum.self, forKey: .state)
        state = stateDecoded
    }
}

extension RumClientTypes {
    /// A structure that includes some data about app monitors and their settings.
    public struct AppMonitorSummary: Swift.Equatable {
        /// The date and time that the app monitor was created.
        public var created: Swift.String?
        /// The unique ID of this app monitor.
        public var id: Swift.String?
        /// The date and time of the most recent changes to this app monitor's configuration.
        public var lastModified: Swift.String?
        /// The name of this app monitor.
        public var name: Swift.String?
        /// The current state of this app monitor.
        public var state: RumClientTypes.StateEnum?

        public init (
            created: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            name: Swift.String? = nil,
            state: RumClientTypes.StateEnum? = nil
        )
        {
            self.created = created
            self.id = id
            self.lastModified = lastModified
            self.name = name
            self.state = state
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceName = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This operation attempted to create a resource that already exists.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The name of the resource that is associated with the error.
    /// This member is required.
    public var resourceName: Swift.String?
    /// The type of the resource that is associated with the error.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateAppMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appMonitorConfiguration = "AppMonitorConfiguration"
        case cwLogEnabled = "CwLogEnabled"
        case domain = "Domain"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appMonitorConfiguration = appMonitorConfiguration {
            try encodeContainer.encode(appMonitorConfiguration, forKey: .appMonitorConfiguration)
        }
        if let cwLogEnabled = cwLogEnabled {
            try encodeContainer.encode(cwLogEnabled, forKey: .cwLogEnabled)
        }
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAppMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/appmonitor"
    }
}

public struct CreateAppMonitorInput: Swift.Equatable {
    /// A structure that contains much of the configuration data for the app monitor. If you are using Amazon Cognito for authorization, you must include this structure in your request, and it must include the ID of the Amazon Cognito identity pool to use for authorization. If you don't include AppMonitorConfiguration, you must set up your own authorization method. For more information, see [Authorize your application to send data to Amazon Web Services](https://docs.aws.amazon.com/monitoring/CloudWatch-RUM-get-started-authorization.html). If you omit this argument, the sample rate used for RUM is set to 10% of the user sessions.
    public var appMonitorConfiguration: RumClientTypes.AppMonitorConfiguration?
    /// Data collected by RUM is kept by RUM for 30 days and then deleted. This parameter specifies whether RUM sends a copy of this telemetry data to Amazon CloudWatch Logs in your account. This enables you to keep the telemetry data for more than 30 days, but it does incur Amazon CloudWatch Logs charges. If you omit this parameter, the default is false.
    public var cwLogEnabled: Swift.Bool?
    /// The top-level internet domain name for which your application has administrative authority.
    /// This member is required.
    public var domain: Swift.String?
    /// A name for the app monitor.
    /// This member is required.
    public var name: Swift.String?
    /// Assigns one or more tags (key-value pairs) to the app monitor. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with an app monitor. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        appMonitorConfiguration: RumClientTypes.AppMonitorConfiguration? = nil,
        cwLogEnabled: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.appMonitorConfiguration = appMonitorConfiguration
        self.cwLogEnabled = cwLogEnabled
        self.domain = domain
        self.name = name
        self.tags = tags
    }
}

struct CreateAppMonitorInputBody: Swift.Equatable {
    let name: Swift.String?
    let domain: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let appMonitorConfiguration: RumClientTypes.AppMonitorConfiguration?
    let cwLogEnabled: Swift.Bool?
}

extension CreateAppMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appMonitorConfiguration = "AppMonitorConfiguration"
        case cwLogEnabled = "CwLogEnabled"
        case domain = "Domain"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let appMonitorConfigurationDecoded = try containerValues.decodeIfPresent(RumClientTypes.AppMonitorConfiguration.self, forKey: .appMonitorConfiguration)
        appMonitorConfiguration = appMonitorConfigurationDecoded
        let cwLogEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cwLogEnabled)
        cwLogEnabled = cwLogEnabledDecoded
    }
}

extension CreateAppMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppMonitorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppMonitorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateAppMonitorOutputResponse: Swift.Equatable {
    /// The unique ID of the new app monitor.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CreateAppMonitorOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
}

extension CreateAppMonitorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension RumClientTypes.CwLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cwLogEnabled = "CwLogEnabled"
        case cwLogGroup = "CwLogGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cwLogEnabled = cwLogEnabled {
            try encodeContainer.encode(cwLogEnabled, forKey: .cwLogEnabled)
        }
        if let cwLogGroup = cwLogGroup {
            try encodeContainer.encode(cwLogGroup, forKey: .cwLogGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cwLogEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cwLogEnabled)
        cwLogEnabled = cwLogEnabledDecoded
        let cwLogGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cwLogGroup)
        cwLogGroup = cwLogGroupDecoded
    }
}

extension RumClientTypes {
    /// A structure that contains the information about whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs. If it does, this structure also contains the name of the log group.
    public struct CwLog: Swift.Equatable {
        /// Indicated whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs.
        public var cwLogEnabled: Swift.Bool?
        /// The name of the log group where the copies are stored.
        public var cwLogGroup: Swift.String?

        public init (
            cwLogEnabled: Swift.Bool? = nil,
            cwLogGroup: Swift.String? = nil
        )
        {
            self.cwLogEnabled = cwLogEnabled
            self.cwLogGroup = cwLogGroup
        }
    }

}

extension RumClientTypes.DataStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cwLog = "CwLog"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cwLog = cwLog {
            try encodeContainer.encode(cwLog, forKey: .cwLog)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cwLogDecoded = try containerValues.decodeIfPresent(RumClientTypes.CwLog.self, forKey: .cwLog)
        cwLog = cwLogDecoded
    }
}

extension RumClientTypes {
    /// A structure that contains information about whether this app monitor stores a copy of the telemetry data that RUM collects using CloudWatch Logs.
    public struct DataStorage: Swift.Equatable {
        /// A structure that contains the information about whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs. If it does, this structure also contains the name of the log group.
        public var cwLog: RumClientTypes.CwLog?

        public init (
            cwLog: RumClientTypes.CwLog? = nil
        )
        {
            self.cwLog = cwLog
        }
    }

}

extension DeleteAppMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/appmonitor/\(name.urlPercentEncoding())"
    }
}

public struct DeleteAppMonitorInput: Swift.Equatable {
    /// The name of the app monitor to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteAppMonitorInputBody: Swift.Equatable {
}

extension DeleteAppMonitorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppMonitorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppMonitorOutputResponse: Swift.Equatable {

}

extension GetAppMonitorDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timeRange = "TimeRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for queryfilters0 in filters {
                try filtersContainer.encode(queryfilters0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timeRange = timeRange {
            try encodeContainer.encode(timeRange, forKey: .timeRange)
        }
    }
}

extension GetAppMonitorDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/appmonitor/\(name.urlPercentEncoding())/data"
    }
}

public struct GetAppMonitorDataInput: Swift.Equatable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.
    public var filters: [RumClientTypes.QueryFilter]?
    /// The maximum number of results to return in one operation.
    public var maxResults: Swift.Int
    /// The name of the app monitor that collected the data that you want to retrieve.
    /// This member is required.
    public var name: Swift.String?
    /// Use the token returned by the previous operation to request the next page of results.
    public var nextToken: Swift.String?
    /// A structure that defines the time range that you want to retrieve results from.
    /// This member is required.
    public var timeRange: RumClientTypes.TimeRange?

    public init (
        filters: [RumClientTypes.QueryFilter]? = nil,
        maxResults: Swift.Int = 0,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        timeRange: RumClientTypes.TimeRange? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.timeRange = timeRange
    }
}

struct GetAppMonitorDataInputBody: Swift.Equatable {
    let timeRange: RumClientTypes.TimeRange?
    let filters: [RumClientTypes.QueryFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension GetAppMonitorDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timeRange = "TimeRange"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeRangeDecoded = try containerValues.decodeIfPresent(RumClientTypes.TimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([RumClientTypes.QueryFilter?].self, forKey: .filters)
        var filtersDecoded0:[RumClientTypes.QueryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [RumClientTypes.QueryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAppMonitorDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppMonitorDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppMonitorDataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppMonitorDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAppMonitorDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct GetAppMonitorDataOutputResponse: Swift.Equatable {
    /// The events that RUM collected that match your request.
    public var events: [Swift.String]?
    /// A token that you can use in a subsequent operation to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        events: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct GetAppMonitorDataOutputResponseBody: Swift.Equatable {
    let events: [Swift.String]?
    let nextToken: Swift.String?
}

extension GetAppMonitorDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .events)
        var eventsDecoded0:[Swift.String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String]()
            for string0 in eventsContainer {
                if let string0 = string0 {
                    eventsDecoded0?.append(string0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAppMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/appmonitor/\(name.urlPercentEncoding())"
    }
}

public struct GetAppMonitorInput: Swift.Equatable {
    /// The app monitor to retrieve information for.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetAppMonitorInputBody: Swift.Equatable {
}

extension GetAppMonitorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAppMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppMonitorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAppMonitorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appMonitor = output.appMonitor
        } else {
            self.appMonitor = nil
        }
    }
}

public struct GetAppMonitorOutputResponse: Swift.Equatable {
    /// A structure containing all the configuration information for the app monitor.
    public var appMonitor: RumClientTypes.AppMonitor?

    public init (
        appMonitor: RumClientTypes.AppMonitor? = nil
    )
    {
        self.appMonitor = appMonitor
    }
}

struct GetAppMonitorOutputResponseBody: Swift.Equatable {
    let appMonitor: RumClientTypes.AppMonitor?
}

extension GetAppMonitorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appMonitor = "AppMonitor"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appMonitorDecoded = try containerValues.decodeIfPresent(RumClientTypes.AppMonitor.self, forKey: .appMonitor)
        appMonitor = appMonitorDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Internal service exception.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The value of a parameter in the request caused an error.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAppMonitorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAppMonitorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/appmonitors"
    }
}

public struct ListAppMonitorsInput: Swift.Equatable {
    /// The maximum number of results to return in one operation.
    public var maxResults: Swift.Int?
    /// Use the token returned by the previous operation to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppMonitorsInputBody: Swift.Equatable {
}

extension ListAppMonitorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppMonitorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppMonitorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppMonitorsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppMonitorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppMonitorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appMonitorSummaries = output.appMonitorSummaries
            self.nextToken = output.nextToken
        } else {
            self.appMonitorSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppMonitorsOutputResponse: Swift.Equatable {
    /// An array of structures that contain information about the returned app monitors.
    public var appMonitorSummaries: [RumClientTypes.AppMonitorSummary]?
    /// A token that you can use in a subsequent operation to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        appMonitorSummaries: [RumClientTypes.AppMonitorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appMonitorSummaries = appMonitorSummaries
        self.nextToken = nextToken
    }
}

struct ListAppMonitorsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let appMonitorSummaries: [RumClientTypes.AppMonitorSummary]?
}

extension ListAppMonitorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appMonitorSummaries = "AppMonitorSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let appMonitorSummariesContainer = try containerValues.decodeIfPresent([RumClientTypes.AppMonitorSummary?].self, forKey: .appMonitorSummaries)
        var appMonitorSummariesDecoded0:[RumClientTypes.AppMonitorSummary]? = nil
        if let appMonitorSummariesContainer = appMonitorSummariesContainer {
            appMonitorSummariesDecoded0 = [RumClientTypes.AppMonitorSummary]()
            for structure0 in appMonitorSummariesContainer {
                if let structure0 = structure0 {
                    appMonitorSummariesDecoded0?.append(structure0)
                }
            }
        }
        appMonitorSummaries = appMonitorSummariesDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource that you want to see the tags of.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.tags = output.tags
        } else {
            self.resourceArn = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The ARN of the resource that you are viewing.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys and values associated with the resource you specified.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutRumEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appMonitorDetails = "AppMonitorDetails"
        case batchId = "BatchId"
        case rumEvents = "RumEvents"
        case userDetails = "UserDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appMonitorDetails = appMonitorDetails {
            try encodeContainer.encode(appMonitorDetails, forKey: .appMonitorDetails)
        }
        if let batchId = batchId {
            try encodeContainer.encode(batchId, forKey: .batchId)
        }
        if let rumEvents = rumEvents {
            var rumEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rumEvents)
            for rumeventlist0 in rumEvents {
                try rumEventsContainer.encode(rumeventlist0)
            }
        }
        if let userDetails = userDetails {
            try encodeContainer.encode(userDetails, forKey: .userDetails)
        }
    }
}

extension PutRumEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/appmonitors/\(id.urlPercentEncoding())"
    }
}

public struct PutRumEventsInput: Swift.Equatable {
    /// A structure that contains information about the app monitor that collected this telemetry information.
    /// This member is required.
    public var appMonitorDetails: RumClientTypes.AppMonitorDetails?
    /// A unique identifier for this batch of RUM event data.
    /// This member is required.
    public var batchId: Swift.String?
    /// The ID of the app monitor that is sending this data.
    /// This member is required.
    public var id: Swift.String?
    /// An array of structures that contain the telemetry event data.
    /// This member is required.
    public var rumEvents: [RumClientTypes.RumEvent]?
    /// A structure that contains information about the user session that this batch of events was collected from.
    /// This member is required.
    public var userDetails: RumClientTypes.UserDetails?

    public init (
        appMonitorDetails: RumClientTypes.AppMonitorDetails? = nil,
        batchId: Swift.String? = nil,
        id: Swift.String? = nil,
        rumEvents: [RumClientTypes.RumEvent]? = nil,
        userDetails: RumClientTypes.UserDetails? = nil
    )
    {
        self.appMonitorDetails = appMonitorDetails
        self.batchId = batchId
        self.id = id
        self.rumEvents = rumEvents
        self.userDetails = userDetails
    }
}

struct PutRumEventsInputBody: Swift.Equatable {
    let batchId: Swift.String?
    let appMonitorDetails: RumClientTypes.AppMonitorDetails?
    let userDetails: RumClientTypes.UserDetails?
    let rumEvents: [RumClientTypes.RumEvent]?
}

extension PutRumEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appMonitorDetails = "AppMonitorDetails"
        case batchId = "BatchId"
        case rumEvents = "RumEvents"
        case userDetails = "UserDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchId)
        batchId = batchIdDecoded
        let appMonitorDetailsDecoded = try containerValues.decodeIfPresent(RumClientTypes.AppMonitorDetails.self, forKey: .appMonitorDetails)
        appMonitorDetails = appMonitorDetailsDecoded
        let userDetailsDecoded = try containerValues.decodeIfPresent(RumClientTypes.UserDetails.self, forKey: .userDetails)
        userDetails = userDetailsDecoded
        let rumEventsContainer = try containerValues.decodeIfPresent([RumClientTypes.RumEvent?].self, forKey: .rumEvents)
        var rumEventsDecoded0:[RumClientTypes.RumEvent]? = nil
        if let rumEventsContainer = rumEventsContainer {
            rumEventsDecoded0 = [RumClientTypes.RumEvent]()
            for structure0 in rumEventsContainer {
                if let structure0 = structure0 {
                    rumEventsDecoded0?.append(structure0)
                }
            }
        }
        rumEvents = rumEventsDecoded0
    }
}

extension PutRumEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRumEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRumEventsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRumEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutRumEventsOutputResponse: Swift.Equatable {

}

extension RumClientTypes.QueryFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for queryfiltervaluelist0 in values {
                try valuesContainer.encode(queryfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension RumClientTypes {
    /// A structure that defines a key and values that you can use to filter the results. The only performance events that are returned are those that have values matching the ones that you specify in one of your QueryFilter structures. For example, you could specify Browser as the Name and specify Chrome,Firefox as the Values to return events generated only from those browsers. Specifying Invert as the Name works as a "not equal to" filter. For example, specify Invert as the Name and specify Chrome as the value to return all events except events from user sessions with the Chrome browser.
    public struct QueryFilter: Swift.Equatable {
        /// The name of a key to search for. The filter returns only the events that match the Name and Values that you specify. Valid values for Name are Browser | Device | Country | Page | OS | EventType | Invert
        public var name: Swift.String?
        /// The values of the Name that are to be be included in the returned results.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceName = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Resource not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The name of the resource that is associated with the error.
    /// This member is required.
    public var resourceName: Swift.String?
    /// The type of the resource that is associated with the error.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension RumClientTypes.RumEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case id
        case metadata
        case timestamp
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
    }
}

extension RumClientTypes {
    /// A structure that contains the information for one performance event that RUM collects from a user session with your application.
    public struct RumEvent: Swift.Equatable {
        /// A string containing details about the event.
        /// This member is required.
        public var details: Swift.String?
        /// A unique ID for this event.
        /// This member is required.
        public var id: Swift.String?
        /// Metadata about this event, which contains a JSON serialization of the identity of the user for this session. The user information comes from information such as the HTTP user-agent request header and document interface.
        public var metadata: Swift.String?
        /// The exact time that this event occurred.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The JSON schema that denotes the type of event this is, such as a page load or a new session.
        /// This member is required.
        public var type: Swift.String?

        public init (
            details: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil,
            type: Swift.String? = nil
        )
        {
            self.details = details
            self.id = id
            self.metadata = metadata
            self.timestamp = timestamp
            self.type = type
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This request exceeds a service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RumClientTypes {
    public enum StateEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case created
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [StateEnum] {
            return [
                .active,
                .created,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .created: return "CREATED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StateEnum(rawValue: rawValue) ?? StateEnum.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the CloudWatch RUM resource that you're adding tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of key-value pairs to associate with the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension RumClientTypes {
    public enum Telemetry: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Includes JS error event plugin
        case errors
        /// Includes X-Ray Xhr and X-Ray Fetch plugin
        case http
        /// Includes navigation, paint, resource and web vital event plugins
        case performance
        case sdkUnknown(Swift.String)

        public static var allCases: [Telemetry] {
            return [
                .errors,
                .http,
                .performance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .errors: return "errors"
            case .http: return "http"
            case .performance: return "performance"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Telemetry(rawValue: rawValue) ?? Telemetry.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was throttled because of quota limits.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the service quota that was exceeded.
    public var quotaCode: Swift.String?
    /// The value of a parameter in the request caused an error.
    public var retryAfterSeconds: Swift.Int?
    /// The ID of the service that is associated with the error.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension RumClientTypes.TimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case after = "After"
        case before = "Before"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if after != 0 {
            try encodeContainer.encode(after, forKey: .after)
        }
        if before != 0 {
            try encodeContainer.encode(before, forKey: .before)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterDecoded = try containerValues.decode(Swift.Int.self, forKey: .after)
        after = afterDecoded
        let beforeDecoded = try containerValues.decode(Swift.Int.self, forKey: .before)
        before = beforeDecoded
    }
}

extension RumClientTypes {
    /// A structure that defines the time range that you want to retrieve results from.
    public struct TimeRange: Swift.Equatable {
        /// The beginning of the time range to retrieve performance events from.
        /// This member is required.
        public var after: Swift.Int
        /// The end of the time range to retrieve performance events from. If you omit this, the time range extends to the time that this operation is performed.
        public var before: Swift.Int

        public init (
            after: Swift.Int = 0,
            before: Swift.Int = 0
        )
        {
            self.after = after
            self.before = before
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the CloudWatch RUM resource that you're removing tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateAppMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appMonitorConfiguration = "AppMonitorConfiguration"
        case cwLogEnabled = "CwLogEnabled"
        case domain = "Domain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appMonitorConfiguration = appMonitorConfiguration {
            try encodeContainer.encode(appMonitorConfiguration, forKey: .appMonitorConfiguration)
        }
        if let cwLogEnabled = cwLogEnabled {
            try encodeContainer.encode(cwLogEnabled, forKey: .cwLogEnabled)
        }
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }
}

extension UpdateAppMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/appmonitor/\(name.urlPercentEncoding())"
    }
}

public struct UpdateAppMonitorInput: Swift.Equatable {
    /// A structure that contains much of the configuration data for the app monitor. If you are using Amazon Cognito for authorization, you must include this structure in your request, and it must include the ID of the Amazon Cognito identity pool to use for authorization. If you don't include AppMonitorConfiguration, you must set up your own authorization method. For more information, see [Authorize your application to send data to Amazon Web Services](https://docs.aws.amazon.com/monitoring/CloudWatch-RUM-get-started-authorization.html).
    public var appMonitorConfiguration: RumClientTypes.AppMonitorConfiguration?
    /// Data collected by RUM is kept by RUM for 30 days and then deleted. This parameter specifies whether RUM sends a copy of this telemetry data to Amazon CloudWatch Logs in your account. This enables you to keep the telemetry data for more than 30 days, but it does incur Amazon CloudWatch Logs charges.
    public var cwLogEnabled: Swift.Bool?
    /// The top-level internet domain name for which your application has administrative authority.
    public var domain: Swift.String?
    /// The name of the app monitor to update.
    /// This member is required.
    public var name: Swift.String?

    public init (
        appMonitorConfiguration: RumClientTypes.AppMonitorConfiguration? = nil,
        cwLogEnabled: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appMonitorConfiguration = appMonitorConfiguration
        self.cwLogEnabled = cwLogEnabled
        self.domain = domain
        self.name = name
    }
}

struct UpdateAppMonitorInputBody: Swift.Equatable {
    let domain: Swift.String?
    let appMonitorConfiguration: RumClientTypes.AppMonitorConfiguration?
    let cwLogEnabled: Swift.Bool?
}

extension UpdateAppMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appMonitorConfiguration = "AppMonitorConfiguration"
        case cwLogEnabled = "CwLogEnabled"
        case domain = "Domain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let appMonitorConfigurationDecoded = try containerValues.decodeIfPresent(RumClientTypes.AppMonitorConfiguration.self, forKey: .appMonitorConfiguration)
        appMonitorConfiguration = appMonitorConfigurationDecoded
        let cwLogEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cwLogEnabled)
        cwLogEnabled = cwLogEnabledDecoded
    }
}

extension UpdateAppMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppMonitorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAppMonitorOutputResponse: Swift.Equatable {

}

extension RumClientTypes.UserDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension RumClientTypes {
    /// A structure that contains information about the user session that this batch of events was collected from.
    public struct UserDetails: Swift.Equatable {
        /// The session ID that the performance events are from.
        public var sessionId: Swift.String?
        /// The ID of the user for this user session. This ID is generated by RUM and does not include any personally identifiable information about the user.
        public var userId: Swift.String?

        public init (
            sessionId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.sessionId = sessionId
            self.userId = userId
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the arguments for the request is not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
